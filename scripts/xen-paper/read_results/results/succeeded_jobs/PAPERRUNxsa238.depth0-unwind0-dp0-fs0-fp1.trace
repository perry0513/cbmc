Start analysis: 1537519894
Done slicing 1537520295
Reading GOTO program from `xsa238.sliced.binary'
Effective lines of code: 1291
Reading GOTO program from `xsa238.binary'
Effective lines of code: 102055
497.520256 CBMC version 5.10 (cbmc-5.10-163-g755b00c) 64-bit x86_64 linux
497.520897 Reading GOTO program from file
497.520907 Reading: xsa238.sliced.binary
498.491227 Generating GOTO Program
498.515530 Adding CPROVER library (x86_64)
498.524654 Removal of function pointers and virtual functions
498.669870 Generic Property Instrumentation
498.761922 Running with 16 object bits, 48 offset bits (user-specified)
498.768885 Starting Bounded Model Checking
500.028893 **** WARNING: no body for function do_set_trap_table; assigning non-deterministic values to any pointer arguments
500.036617 **** WARNING: no body for function do_mmu_update; assigning non-deterministic values to any pointer arguments
500.044317 **** WARNING: no body for function do_set_gdt; assigning non-deterministic values to any pointer arguments
500.052083 **** WARNING: no body for function do_stack_switch; assigning non-deterministic values to any pointer arguments
500.059949 **** WARNING: no body for function do_set_callbacks; assigning non-deterministic values to any pointer arguments
500.067863 **** WARNING: no body for function do_fpu_taskswitch; assigning non-deterministic values to any pointer arguments
500.075812 **** WARNING: no body for function do_sched_op_compat; assigning non-deterministic values to any pointer arguments
500.083784 **** WARNING: no body for function do_platform_op; assigning non-deterministic values to any pointer arguments
500.091833 **** WARNING: no body for function do_set_debugreg; assigning non-deterministic values to any pointer arguments
500.099940 **** WARNING: no body for function do_get_debugreg; assigning non-deterministic values to any pointer arguments
500.108170 **** WARNING: no body for function do_update_descriptor; assigning non-deterministic values to any pointer arguments
500.116131 **** WARNING: no body for function do_ni_hypercall; assigning non-deterministic values to any pointer arguments
500.124530 **** WARNING: no body for function do_memory_op; assigning non-deterministic values to any pointer arguments
500.132872 **** WARNING: no body for function do_update_va_mapping; assigning non-deterministic values to any pointer arguments
500.141265 **** WARNING: no body for function do_set_timer_op; assigning non-deterministic values to any pointer arguments
500.149708 **** WARNING: no body for function do_event_channel_op_compat; assigning non-deterministic values to any pointer arguments
500.158222 **** WARNING: no body for function do_xen_version; assigning non-deterministic values to any pointer arguments
500.166849 **** WARNING: no body for function do_console_io; assigning non-deterministic values to any pointer arguments
500.175491 **** WARNING: no body for function do_physdev_op_compat; assigning non-deterministic values to any pointer arguments
500.184252 **** WARNING: no body for function do_grant_table_op; assigning non-deterministic values to any pointer arguments
500.193080 **** WARNING: no body for function do_vm_assist; assigning non-deterministic values to any pointer arguments
500.202035 **** WARNING: no body for function do_update_va_mapping_otherdomain; assigning non-deterministic values to any pointer arguments
500.210811 **** WARNING: no body for function do_iret; assigning non-deterministic values to any pointer arguments
500.220083 **** WARNING: no body for function do_vcpu_op; assigning non-deterministic values to any pointer arguments
500.229211 **** WARNING: no body for function do_set_segment_base; assigning non-deterministic values to any pointer arguments
500.238483 **** WARNING: no body for function do_mmuext_op; assigning non-deterministic values to any pointer arguments
500.247766 **** WARNING: no body for function do_xsm_op; assigning non-deterministic values to any pointer arguments
500.257167 **** WARNING: no body for function do_nmi_op; assigning non-deterministic values to any pointer arguments
500.266626 **** WARNING: no body for function do_sched_op; assigning non-deterministic values to any pointer arguments
500.276145 **** WARNING: no body for function do_callback_op; assigning non-deterministic values to any pointer arguments
500.285730 **** WARNING: no body for function do_xenoprof_op; assigning non-deterministic values to any pointer arguments
500.294182 **** WARNING: no body for function do_event_channel_op; assigning non-deterministic values to any pointer arguments
500.302713 **** WARNING: no body for function do_physdev_op; assigning non-deterministic values to any pointer arguments
500.366072 **** WARNING: no body for function hvmop_create_ioreq_server; assigning non-deterministic values to any pointer arguments
500.374272 **** WARNING: no body for function hvmop_get_ioreq_server_info; assigning non-deterministic values to any pointer arguments
500.382410 **** WARNING: no body for function hvmop_map_io_range_to_ioreq_server; assigning non-deterministic values to any pointer arguments
500.447645 **** WARNING: no body for function get_cpu_info$link3$link3; assigning non-deterministic values to any pointer arguments
500.456647 **** WARNING: no body for function copy_from_user_hvm; assigning non-deterministic values to any pointer arguments
500.467017 **** WARNING: no body for function copy_from_user; assigning non-deterministic values to any pointer arguments
500.490882 **** WARNING: no body for function rcu_lock_remote_domain_by_id; assigning non-deterministic values to any pointer arguments
500.520343 **** WARNING: no body for function xsm_hvm_ioreq_server; assigning non-deterministic values to any pointer arguments
500.550171 **** WARNING: no body for function _spin_lock_recursive; assigning non-deterministic values to any pointer arguments
500.595230 **** WARNING: no body for function rangeset_contains_range; assigning non-deterministic values to any pointer arguments
500.597104 **** WARNING: no body for function rangeset_remove_range; assigning non-deterministic values to any pointer arguments
500.616855 Not unwinding loop hvm_unmap_io_range_from_ioreq_server.0 iteration 1 file ioreq.c line 879 function hvm_unmap_io_range_from_ioreq_server thread 0
500.655862 **** WARNING: no body for function _spin_unlock_recursive; assigning non-deterministic values to any pointer arguments
500.681633 **** WARNING: no body for function rcu_unlock_domain$link2$link2; assigning non-deterministic values to any pointer arguments
500.758832 **** WARNING: no body for function hvmop_set_ioreq_server_state; assigning non-deterministic values to any pointer arguments
500.774855 **** WARNING: no body for function hvmop_destroy_ioreq_server; assigning non-deterministic values to any pointer arguments
500.790768 **** WARNING: no body for function hvmop_set_evtchn_upcall_vector; assigning non-deterministic values to any pointer arguments
500.806894 **** WARNING: no body for function hvmop_set_param; assigning non-deterministic values to any pointer arguments
500.823021 **** WARNING: no body for function hvmop_get_param; assigning non-deterministic values to any pointer arguments
500.839282 **** WARNING: no body for function hvmop_set_pci_intx_level; assigning non-deterministic values to any pointer arguments
500.855537 **** WARNING: no body for function hvmop_set_isa_irq_level; assigning non-deterministic values to any pointer arguments
500.871830 **** WARNING: no body for function hvmop_inject_msi; assigning non-deterministic values to any pointer arguments
500.888219 **** WARNING: no body for function hvmop_set_pci_link_route; assigning non-deterministic values to any pointer arguments
500.905206 **** WARNING: no body for function hvmop_flush_tlb_all; assigning non-deterministic values to any pointer arguments
501.018607 **** WARNING: no body for function xsm_hvm_control; assigning non-deterministic values to any pointer arguments
501.097895 **** WARNING: no body for function shadow_track_dirty_vram; assigning non-deterministic values to any pointer arguments
501.134392 **** WARNING: no body for function hap_track_dirty_vram; assigning non-deterministic values to any pointer arguments
501.431422 **** WARNING: no body for function domain_get_maximum_gpfn; assigning non-deterministic values to any pointer arguments
501.481703 **** WARNING: no body for function get_page_from_gfn$link1$link2; assigning non-deterministic values to any pointer arguments
501.502769 **** WARNING: no body for function pdx_to_pfn$link13; assigning non-deterministic values to any pointer arguments
501.504588 **** WARNING: no body for function paging_mark_dirty; assigning non-deterministic values to any pointer arguments
501.524447 **** WARNING: no body for function _mfn$link13; assigning non-deterministic values to any pointer arguments
501.525644 **** WARNING: no body for function sh_remove_shadows; assigning non-deterministic values to any pointer arguments
501.545371 **** WARNING: no body for function put_page; assigning non-deterministic values to any pointer arguments
501.569892 **** WARNING: no body for function local_events_need_delivery$link5$link2; assigning non-deterministic values to any pointer arguments
501.606718 Not unwinding loop do_hvm_op.0 iteration 1 file hvm.c line 5851 function do_hvm_op thread 0
501.777686 **** WARNING: no body for function hvmop_get_mem_type; assigning non-deterministic values to any pointer arguments
501.819761 **** WARNING: no body for function hvmop_set_mem_type; assigning non-deterministic values to any pointer arguments
501.920182 **** WARNING: no body for function rcu_lock_domain_by_any_id; assigning non-deterministic values to any pointer arguments
501.966569 **** WARNING: no body for function xsm_hvm_param; assigning non-deterministic values to any pointer arguments
502.021593 **** WARNING: no body for function pagetable_dying; assigning non-deterministic values to any pointer arguments
502.130679 **** WARNING: no body for function get_s_time; assigning non-deterministic values to any pointer arguments
502.142463 **** WARNING: no body for function copy_to_user_hvm; assigning non-deterministic values to any pointer arguments
502.154964 **** WARNING: no body for function copy_to_user; assigning non-deterministic values to any pointer arguments
502.288436 **** WARNING: no body for function trace_var$link1$link1; assigning non-deterministic values to any pointer arguments
503.223039 **** WARNING: no body for function monitor_guest_request; assigning non-deterministic values to any pointer arguments
503.325598 **** WARNING: no body for function do_altp2m_op; assigning non-deterministic values to any pointer arguments
503.404975 **** WARNING: no body for function gdprintk$link2$link3; assigning non-deterministic values to any pointer arguments
505.513113 **** WARNING: no body for function hypercall_create_continuation; assigning non-deterministic values to any pointer arguments
506.618436 **** WARNING: no body for function do_sysctl; assigning non-deterministic values to any pointer arguments
506.678534 **** WARNING: no body for function do_domctl; assigning non-deterministic values to any pointer arguments
506.740542 **** WARNING: no body for function do_kexec_op; assigning non-deterministic values to any pointer arguments
506.800871 **** WARNING: no body for function do_tmem_op; assigning non-deterministic values to any pointer arguments
509.003381 **** WARNING: no body for function test_all_events; assigning non-deterministic values to any pointer arguments
509.003919 Not unwinding loop start_function.0 iteration 1 file stub_syscall.c line 276 function start_function thread 0
509.261553 size of program expression: 14951 steps
509.263292 simple slicing removed 11509 assignments
509.264168 Generated 1 VCC(s), 1 remaining after simplification
509.264889 Passing problem to propositional reduction
509.265025 converting SSA
509.381125 Running propositional reduction
509.381143 Post-processing
509.381164 Solving with MiniSAT 2.2.1 without simplifier
509.381169 83235 variables, 18886 clauses
509.387714 SAT checker: instance is SATISFIABLE
509.387742 Runtime decision procedure: 0.122698s
509.387748 Building error trace
509.825399 Counterexample:
509.865647 
#### Function call: __CPROVER_initialize() (depth 1) ####

#### Function return: __CPROVER_initialize (depth 0) ####

#### Function call: start_function() (depth 1) ####

State 934 file stub_syscall.c line 274 function start_function thread 0
----------------------------------------------------
signed int nondet;
----------------------------------------------------
  nondet=2 (0x2)

State 935 file stub_syscall.c line 276 function start_function thread 0
----------------------------------------------------
signed int i;
----------------------------------------------------
  i=0 (0x0)

State 936 file stub_syscall.c line 276 function start_function thread 0
----------------------------------------------------
i = 0;
----------------------------------------------------
  i=0 (0x0)

#### Function call: do_hypercall() (depth 2) ####

State 940 file stub_syscall.c line 9 function do_hypercall thread 0
----------------------------------------------------
signed int nondet;
----------------------------------------------------
  nondet=34 (0x22)

State 976 file stub_syscall.c line 200 function do_hypercall thread 0
----------------------------------------------------
unsigned long int op34;
----------------------------------------------------
  op34=20ul (0x14)

State 977 file stub_syscall.c line 201 function do_hypercall thread 0
----------------------------------------------------
__guest_handle_void arg34;
----------------------------------------------------
  arg34={ .p=NULL } ({ 0x0 })

#### Function call: do_hvm_op(20ul, { .p=NULL }) (depth 3) ####

State 980 file stub_syscall.c line 202 function do_hypercall thread 0
----------------------------------------------------
do_hvm_op(op34, arg34);
----------------------------------------------------
  op=20ul (0x14)

State 981 file stub_syscall.c line 202 function do_hypercall thread 0
----------------------------------------------------
do_hvm_op(op34, arg34);
----------------------------------------------------
  arg={ .p=NULL } ({ 0x0 })

State 982 file hvm.c line 5694 function do_hvm_op thread 0
----------------------------------------------------
unsigned long int start_iter;
----------------------------------------------------
  start_iter=0ul (0x0)

State 983 file hvm.c line 5694 function do_hvm_op thread 0
----------------------------------------------------
unsigned long int mask;
----------------------------------------------------
  mask=0ul (0x0)

State 984 file hvm.c line 5695 function do_hvm_op thread 0
----------------------------------------------------
signed long int rc;
----------------------------------------------------
  rc=0l (0x0)

State 985 file hvm.c line 5695 function do_hvm_op thread 0
----------------------------------------------------
rc = (signed long int)0;
----------------------------------------------------
  rc=0l (0x0)

State 988 file hvm.c line 5700 function do_hvm_op thread 0
----------------------------------------------------
mask = ~0ul;
----------------------------------------------------
  mask=18446744073709551615ul (0xFFFFFFFF FFFFFFFF)

State 990 file hvm.c line 5708 function do_hvm_op thread 0
----------------------------------------------------
start_iter = op & ~mask;
----------------------------------------------------
  start_iter=0ul (0x0)

State 992 file hvm.c line 5709 function do_hvm_op thread 0
----------------------------------------------------
op = op & mask;
----------------------------------------------------
  op=20ul (0x14)

State 998 file hvm.c line 5728 function do_hvm_op thread 0
----------------------------------------------------
xen_hvm_io_range_t *_x;
----------------------------------------------------
  _x=((struct xen_hvm_io_range { unsigned short int domid; unsigned short int id; u32 type; unsigned long int start; unsigned long int end; } *)NULL) (0x0)

State 999 file hvm.c line 5728 function do_hvm_op thread 0
----------------------------------------------------
_x = (xen_hvm_io_range_t *)arg.p;
----------------------------------------------------
  _x=((struct xen_hvm_io_range { unsigned short int domid; unsigned short int id; u32 type; unsigned long int start; unsigned long int end; } *)NULL) (0x0)

#### Function call: hvmop_unmap_io_range_from_ioreq_server({ .p=((xen_hvm_io_range_t *)NULL) }) (depth 4) ####

State 1004 file hvm.c line 5727 function do_hvm_op thread 0
----------------------------------------------------
hvmop_unmap_io_range_from_ioreq_server(tmp_statement_expression$2);
----------------------------------------------------
  uop={ .p=((xen_hvm_io_range_t *)NULL) } ({ 0x0 })

State 1005 file hvm.c line 4917 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
xen_hvm_io_range_t op;
----------------------------------------------------
  op={ .domid=0, .id=0, .type=0u, .start=0ul, .end=0ul } ({ 0x0, 0x0, 0x0, 0x0, 0x0 })

State 1006 file hvm.c line 4918 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
struct domain *d;
----------------------------------------------------
  d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 1007 file hvm.c line 4919 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
signed int rc;
----------------------------------------------------
  rc=0 (0x0)

State 1009 file hvm.c line 4921 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
const xen_hvm_io_range_t *_s;
----------------------------------------------------
  _s=((struct xen_hvm_io_range { unsigned short int domid; unsigned short int id; u32 type; unsigned long int start; unsigned long int end; } *)NULL) (0x0)

State 1010 file hvm.c line 4921 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
_s = uop.p;
----------------------------------------------------
  _s=((struct xen_hvm_io_range { unsigned short int domid; unsigned short int id; u32 type; unsigned long int start; unsigned long int end; } *)NULL) (0x0)

State 1011 file hvm.c line 4921 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
xen_hvm_io_range_t *_d;
----------------------------------------------------
  _d=((struct xen_hvm_io_range { unsigned short int domid; unsigned short int id; u32 type; unsigned long int start; unsigned long int end; } *)NULL) (0x0)

State 1012 file hvm.c line 4921 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
_d = &op;
----------------------------------------------------
  _d=&op!0@1.domid (0x24300000 0000000)

#### Function call: get_cpu_info$link3$link3() (depth 5) ####

#### Function return: get_cpu_info$link3$link3 (depth 4) ####

#### Function call: copy_from_user_hvm(&op!0@1.domid, NULL, 24u) (depth 5) ####

#### Function return: copy_from_user_hvm (depth 4) ####

State 1024 file hvm.c line 4921 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
copy_from_user_hvm((void *)_d, (const void *)(_s + (signed long int)0), (unsigned int)(sizeof(xen_hvm_io_range_t) /*24ul*/  * (unsigned long int)1));
----------------------------------------------------
  op={ .domid=0, .id=0, .type=0u, .start=1ul, .end=0ul } ({ 0x0, 0x0, 0x0, 0x1, 0x0 })

#### Function call: rcu_lock_remote_domain_by_id(0, &d!0@1) (depth 5) ####

#### Function return: rcu_lock_remote_domain_by_id (depth 4) ####

State 1033 file hvm.c line 4924 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
rcu_lock_remote_domain_by_id(op.domid, &d);
----------------------------------------------------
  d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 1034 file hvm.c line 4924 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
rc = NONDET(signed int);
----------------------------------------------------
  rc=0 (0x0)

State 1036 file hvm.c line 4928 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
rc = -22;
----------------------------------------------------
  rc=-22 (0xFFFFFFEA)

#### Function call: xsm_hvm_ioreq_server(/*enum*/XSM_DM_PRIV, ((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL), 20) (depth 5) ####

#### Function return: xsm_hvm_ioreq_server (depth 4) ####

State 1041 file hvm.c line 4932 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
xsm_hvm_ioreq_server((xsm_default_t)1, d, 20);
----------------------------------------------------
  d$object={ .domain_id=0, .$pad1=0, .max_vcpus=0u, .vcpu=((struct vcpu **)NULL),
    .shared_info=((shared_info_t *)NULL), .domain_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .page_alloc_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .page_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .xenpage_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .tot_pages=0u,
    .xenheap_pages=0u, .outstanding_pages=0u, .max_pages=0u,
    .shr_pages={ .counter=0 }, .paged_pages={ .counter=0 },
    .sched_priv=NULL, .cpupool=((struct cpupool *)NULL),
    .next_in_list=((struct domain *)NULL), .next_in_hashbucket=((struct domain *)NULL),
    .rangesets={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) },
    .rangesets_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .evtchn=((struct evtchn *)NULL),
    .evtchn_group={ ((struct evtchn **)NULL), ((struct evtchn **)NULL), ((struct evtchn **)NULL), ((struct evtchn **)NULL) }, .max_evtchns=0u,
    .max_evtchn_port=0u, .valid_evtchns=0u,
    .event_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .$pad27=0u,
    .evtchn_port_ops=((const struct evtchn_port_ops *)NULL), .evtchn_fifo=((struct evtchn_fifo_domain *)NULL),
    .grant_table=((struct grant_table *)NULL),
    .pirq_tree={ .height=0u, .$pad1=0u, .rnode=((struct radix_tree_node *)NULL), .node_alloc=((radix_tree_alloc_fn_t (*))NULL),
    .node_free=((radix_tree_free_fn_t (*))NULL),
    .node_alloc_free_arg=NULL },
    .nr_pirqs=0u,
    .guest_type=/*enum*/guest_type_pv, .is_dying=/*enum*/DOMDYING_alive,
    .controller_pause_count=0, .time_offset_seconds=0l,
    .iommu={ .arch={ .pgd_maddr=0ul, .mapping_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .agaw=0,
    .$pad3=0u, .g2m_ioport_list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .iommu_bitmap=0ul,
    .mapped_rmrrs={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .paging_mode=0,
    .$pad8=0u, .root_table=((struct page_info *)NULL), .g_iommu=((struct guest_iommu *)NULL) }, .platform_ops=((const struct iommu_ops *)NULL),
    .features={ 0ul } }, .need_iommu=0,
    .auto_node_affinity=FALSE, .is_privileged=FALSE,
    .is_xenstore=FALSE, .is_pinned=FALSE,
    .disable_migrate=FALSE, .debugger_attached=FALSE,
    .creation_finished=FALSE, .target=((struct domain *)NULL),
    .poll_mask=((unsigned long int *)NULL), .iomem_caps=((struct rangeset *)NULL),
    .irq_caps=((struct rangeset *)NULL),
    .shutdown_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .is_shutting_down=FALSE,
    .is_shut_down=FALSE, .$pad53=0,
    .shutdown_code=0u, .suspend_evtchn=0u, .pause_count={ .counter=0 },
    .refcnt={ .counter=0 }, .$pad58=0u,
    .vm_assist=0ul, .domain_dirty_cpumask=((const cpumask_t *)NULL), .$pad61=0,
    .arch={ .perdomain_l3_pg=((struct page_info *)NULL), .hv_compat_vstart=0u,
    .physaddr_bitsize=0u, .ioport_caps=((struct rangeset *)NULL),
    .pci_cf8=0u,
    .cmos_idx=0, .s3_integrity=FALSE, .$pad7=0,
    .pdev_list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .$anon0={ .pv_domain={ .gdt_ldt_l1tab=((l1_pgentry_t **)NULL), .nr_l4_pages={ .counter=0 },
    .$pad2=0u, .mapcache={ .entries=0u, .cursor=0u, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .epoch=0u,
    .tlbflush_timestamp=0u, .inuse=((unsigned long int *)NULL), .garbage=((unsigned long int *)NULL) },
    .cpuidmasks=((struct cpuidmasks *)NULL) } },
    .paging={ .lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) }, .mode=0u,
    .p2m_alloc_failed=FALSE, .$pad3=0, .shadow={ .opt_flags=0u, .$pad1=0u, .pinned_shadows={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .freelist={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .total_pages=0u,
    .free_pages=0u, .p2m_pages=0u, .$pad7=0u,
    .unpaged_pagetable={ .pfn=0ul }, .gtable_dirty_version={ .counter=0 },
    .$pad10=0u,
    .hash_table=((struct page_info **)NULL), .hash_walking=FALSE,
    .has_fast_mmio_entries=FALSE, .oos_active=FALSE,
    .oos_off=FALSE, .pagetable_dying_op=FALSE, .$pad17=0 },
    .hap={ .freelist={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .total_pages=0u,
    .free_pages=0u, .p2m_pages=0u, .$pad4=0u },
    .log_dirty={ .top=0ul, .allocs=0u, .failed_allocs=0u, .fault_count=0u,
    .dirty_count=0u, .enable_log_dirty=((signed int (*)(struct domain *, bool_t))NULL), .disable_log_dirty=((signed int (*)(struct domain *))NULL),
    .clean_dirty_bitmap=((const void (*)(struct domain *))NULL) },
    .gfn_bits=0u,
    .$pad8=0u, .preempt={ .dom=((struct domain *)NULL), .op=0u, .$pad2=0u, .$anon0={ .log_dirty={ .done=0ul, .i4=0ul, .i3=0ul, .$bit_field_pad3=0 } } }, .alloc_page=((struct page_info * (*)(struct domain *))NULL),
    .free_page=((const void (*)(struct domain *, struct page_info *))NULL) },
    .p2m=((struct p2m_domain *)NULL),
    .page_alloc_unlock_level=0, .relmem=/*enum*/RELMEM_not_started,
    .relmem_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .nested_p2m={ ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL) },
    .nested_p2m_lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) },
    .altp2m_active=FALSE,
    .$pad18=0, .altp2m_p2m={ ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL) }, .altp2m_list_lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) },
    .altp2m_eptp=((unsigned long int *)NULL),
    .irq_pirq={ .height=0u, .$pad1=0u, .rnode=((struct radix_tree_node *)NULL), .node_alloc=((radix_tree_alloc_fn_t (*))NULL),
    .node_free=((radix_tree_free_fn_t (*))NULL),
    .node_alloc_free_arg=NULL },
    .is_32bit_pv=FALSE,
    .has_32bit_shinfo=FALSE, .suppress_spurious_page_faults=FALSE,
    .auto_unmask=FALSE,
    .x86=0, .x86_vendor=0, .x86_model=0,
    .x87_fip_width=0, .cpuids=((cpuid_input_t *)NULL), .vpit={ .hw={ .channels={ , ,  }, .speaker_data_on=0u, .pad0=0u }, .count_load_time={ 0l, 0l, 0l },
    .pt0={ .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .on_list=FALSE,
    .one_shot=FALSE, .do_not_freeze=FALSE, .irq_issued=FALSE,
    .warned_timeout_too_short=FALSE, .source=0,
    .irq=0, .$pad8=0, .vcpu=((struct vcpu *)NULL), .pending_intr_nr=0u,
    .$pad11=0u, .period=0ul, .scheduled=0l,
    .last_plt_gtime=0ul, .timer={ .expires=0l, .$anon0={ .heap_offset=0u }, .function=((const void (*)(const void *))NULL),
    .data=NULL,
    .cpu=0, .status=0, .$pad6=0 }, .cb=((time_cb (*))NULL),
    .priv=NULL }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } },
    .tsc_mode=0,
    .vtsc=FALSE, .$pad35=0, .vtsc_last=0l,
    .vtsc_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .vtsc_offset=0ul,
    .tsc_khz=0u, .vtsc_to_ns={ .shift=0, .mul_frac=0u }, .ns_to_vtsc={ .shift=0, .mul_frac=0u },
    .incarnation=0u,
    .e820_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .e820=((struct e820entry *)NULL),
    .nr_e820=0u, .psr_rmid=0u,
    .psr_cos_ids=((u32 *)NULL), .pirq_eoi_map=((unsigned long int *)NULL),
    .pirq_eoi_map_mfn=0ul,
    .monitor={ .write_ctrlreg_enabled=0u, .write_ctrlreg_sync=0u, .write_ctrlreg_onchangeonly=0u,
    .singlestep_enabled=0u, .software_breakpoint_enabled=0u,
    .debug_exception_enabled=0u, .debug_exception_sync=0u,
    .cpuid_enabled=0u, .$bit_field_pad8=0,
    .$pad9=0, .msr_bitmap=((struct monitor_msr_bitmap *)NULL) }, .mem_access_emulate_each_rep=FALSE,
    .$pad52=0, .emulation_flags=0u,
    .$pad54=0 }, .ssid=NULL,
    .handle={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .pbuf=((const char *)NULL),
    .pbuf_idx=0u, .pbuf_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .$pad68=0u,
    .xenoprof=((struct xenoprof *)NULL), .watchdog_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .watchdog_inuse_map=0u,
    .$pad72=0u, .watchdog_timer={ ,  }, .rcu={ .next=((struct rcu_head *)NULL), .func=((const void (*)(struct rcu_head *))NULL) },
    .hypercall_deadlock_mutex={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .tmem_client=((struct client *)NULL),
    .profile_head=irep("(\"nil\")"),
    .vm_event=((struct vm_event_per_domain *)NULL), .node_affinity={ .bits={ 0ul } },
    .last_alloc_node=0u, .node_affinity_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .vnuma_rwlock={ .cnts={ .counter=0 }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } },
    .vnuma=((struct vnuma_info *)NULL),
    .monitor={ .guest_request_enabled=0u, .guest_request_sync=0u, .$bit_field_pad2=0,
    .$pad3=0 }, .$pad85=0u } ({ 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, { { 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0 }, 0x0, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0, { 0x0 } }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, { 0x0 }, 0x0, { 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0 }, { { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0 } }, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { { { ?, ?, ? }, 0x0, 0x0 }, { 0x0, 0x0, 0x0 }, { { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { ?, ? }, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, ?, 0x0, { { 0x0 } }, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, { { 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, { 0x0, 0x0, 0x0, 0x0 }, 0x0 })

State 1042 file hvm.c line 4932 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
rc = NONDET(signed int);
----------------------------------------------------
  rc=0 (0x0)

#### Function call: hvm_unmap_io_range_from_ioreq_server(((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL), 0, 0u, 1ul, 0ul) (depth 5) ####

State 1046 file hvm.c line 4936 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
hvm_unmap_io_range_from_ioreq_server(d, op.id, op.type, op.start, op.end);
----------------------------------------------------
  d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 1047 file hvm.c line 4936 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
hvm_unmap_io_range_from_ioreq_server(d, op.id, op.type, op.start, op.end);
----------------------------------------------------
  id=0 (0x0)

State 1048 file hvm.c line 4936 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
hvm_unmap_io_range_from_ioreq_server(d, op.id, op.type, op.start, op.end);
----------------------------------------------------
  type=0u (0x0)

State 1049 file hvm.c line 4936 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
hvm_unmap_io_range_from_ioreq_server(d, op.id, op.type, op.start, op.end);
----------------------------------------------------
  start=1ul (0x1)

State 1050 file hvm.c line 4936 function hvmop_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
hvm_unmap_io_range_from_ioreq_server(d, op.id, op.type, op.start, op.end);
----------------------------------------------------
  end=0ul (0x0)

State 1051 file ioreq.c line 871 function hvm_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
struct hvm_ioreq_server *s;
----------------------------------------------------
  s=((struct hvm_ioreq_server { struct list_head { struct list_head *next; struct list_head *prev; } list_entry; struct domain *domain; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int domid; unsigned short int id; u32 $pad5; struct hvm_ioreq_page { unsigned long int gmfn; struct page_info *page; const void *va; } ioreq; struct list_head { struct list_head *next; struct list_head *prev; } ioreq_vcpu_list; struct hvm_ioreq_page { unsigned long int gmfn; struct page_info *page; const void *va; } bufioreq; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } bufioreq_lock; u32 bufioreq_evtchn; u32 $pad11; struct rangeset *range[3l]; bool_t enabled; bool_t bufioreq_atomic; unsigned __CPROVER_bitvector[48] $pad15; } *)NULL) (0x0)

State 1052 file ioreq.c line 872 function hvm_unmap_io_range_from_ioreq_server thread 0
----------------------------------------------------
signed int rc;
----------------------------------------------------
  rc=0 (0x0)

Violated property:
  file ioreq.c line 874 function hvm_unmap_io_range_from_ioreq_server
  make sure the specified range is actually a range
  start <= end


509.865891 VERIFICATION FAILED

real	0m12.804s
user	0m12.580s
sys	0m0.220s
goto-instrument options: --aggressive-slice --aggressive-slice-call-depth 0 
cbmc options:  --stop-on-fail --object-bits 16 --trace --trace-show-function-calls --trace-show-code --trace-hex --no-sat-preprocessor --unwind 0 --havoc-undefined-functions 
End time 1537520316
