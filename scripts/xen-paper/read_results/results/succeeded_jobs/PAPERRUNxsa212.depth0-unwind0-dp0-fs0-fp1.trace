Start analysis: 1537519868
Done slicing 1537520240
Reading GOTO program from `xsa212.sliced.binary'
Effective lines of code: 1272
Reading GOTO program from `xsa212.binary'
Effective lines of code: 101800
458.304314 CBMC version 5.10 (cbmc-5.10-163-g755b00c) 64-bit x86_64 linux
458.304935 Reading GOTO program from file
458.304944 Reading: xsa212.sliced.binary
459.220448 Generating GOTO Program
459.239085 Adding CPROVER library (x86_64)
459.248143 Removal of function pointers and virtual functions
459.389624 Generic Property Instrumentation
459.480013 Running with 16 object bits, 48 offset bits (user-specified)
459.486807 Starting Bounded Model Checking
460.679180 **** WARNING: no body for function get_cpu_info$link13; assigning non-deterministic values to any pointer arguments
460.718901 **** WARNING: no body for function copy_from_user_hvm; assigning non-deterministic values to any pointer arguments
460.727996 **** WARNING: no body for function copy_from_user; assigning non-deterministic values to any pointer arguments
460.789263 **** WARNING: no body for function rcu_lock_domain_by_any_id; assigning non-deterministic values to any pointer arguments
460.820995 **** WARNING: no body for function construct_memop_from_reservation; assigning non-deterministic values to any pointer arguments
460.823560 **** WARNING: no body for function rcu_unlock_domain$link6; assigning non-deterministic values to any pointer arguments
460.874202 **** WARNING: no body for function xsm_memory_adjust_reservation; assigning non-deterministic values to any pointer arguments
460.964534 **** WARNING: no body for function increase_reservation; assigning non-deterministic values to any pointer arguments
460.974523 **** WARNING: no body for function decrease_reservation; assigning non-deterministic values to any pointer arguments
460.983839 **** WARNING: no body for function populate_physmap; assigning non-deterministic values to any pointer arguments
461.019290 **** WARNING: no body for function hypercall_create_continuation; assigning non-deterministic values to any pointer arguments
461.157982 **** WARNING: no body for function max_order; assigning non-deterministic values to any pointer arguments
461.399019 **** WARNING: no body for function xsm_memory_exchange; assigning non-deterministic values to any pointer arguments
461.761734 **** WARNING: no body for function domain_clamp_alloc_bitsize; assigning non-deterministic values to any pointer arguments
461.785043 **** WARNING: no body for function local_events_need_delivery$link2; assigning non-deterministic values to any pointer arguments
461.821878 **** WARNING: no body for function copy_to_user_hvm; assigning non-deterministic values to any pointer arguments
461.833165 **** WARNING: no body for function __copy_to_user$link7; assigning non-deterministic values to any pointer arguments
461.944630 **** WARNING: no body for function __copy_from_user$link1; assigning non-deterministic values to any pointer arguments
461.969674 **** WARNING: no body for function get_gfn_type$link1; assigning non-deterministic values to any pointer arguments
461.987371 **** WARNING: no body for function mfn_x$link3; assigning non-deterministic values to any pointer arguments
461.993771 **** WARNING: no body for function __put_gfn; assigning non-deterministic values to any pointer arguments
462.009544 **** WARNING: no body for function __mfn_valid; assigning non-deterministic values to any pointer arguments
462.030246 **** WARNING: no body for function pfn_to_pdx$link4; assigning non-deterministic values to any pointer arguments
462.031995 **** WARNING: no body for function steal_page; assigning non-deterministic values to any pointer arguments
462.072700 **** WARNING: no body for function page_list_add$link1; assigning non-deterministic values to any pointer arguments
462.080513 Not unwinding loop memory_exchange.0 iteration 1 file memory.c line 515 function memory_exchange thread 0
462.101326 Not unwinding loop memory_exchange.1 iteration 1 file memory.c line 506 function memory_exchange thread 0
462.125172 **** WARNING: no body for function alloc_domheap_pages; assigning non-deterministic values to any pointer arguments
462.157906 Not unwinding loop memory_exchange.2 iteration 1 file memory.c line 553 function memory_exchange thread 0
462.175547 **** WARNING: no body for function page_list_remove_head; assigning non-deterministic values to any pointer arguments
462.177770 **** WARNING: no body for function test_and_clear_bit$link4; assigning non-deterministic values to any pointer arguments
462.189652 **** WARNING: no body for function pdx_to_pfn$link4; assigning non-deterministic values to any pointer arguments
462.233789 **** WARNING: no body for function _gfn$link3; assigning non-deterministic values to any pointer arguments
462.233925 **** WARNING: no body for function _mfn$link6; assigning non-deterministic values to any pointer arguments
462.235296 **** WARNING: no body for function guest_physmap_remove_page; assigning non-deterministic values to any pointer arguments
462.255122 **** WARNING: no body for function put_page; assigning non-deterministic values to any pointer arguments
462.255684 Not unwinding loop memory_exchange.8 iteration 1 file memory.c line 571 function memory_exchange thread 0
462.276679 **** WARNING: no body for function assign_pages; assigning non-deterministic values to any pointer arguments
462.302809 **** WARNING: no body for function _spin_lock; assigning non-deterministic values to any pointer arguments
462.307971 **** WARNING: no body for function domain_adjust_tot_pages; assigning non-deterministic values to any pointer arguments
462.361283 **** WARNING: no body for function _spin_unlock; assigning non-deterministic values to any pointer arguments
462.367018 **** WARNING: no body for function atomic_dec_and_test$link5; assigning non-deterministic values to any pointer arguments
462.370578 **** WARNING: no body for function domain_destroy; assigning non-deterministic values to any pointer arguments
462.420163 **** WARNING: no body for function free_domheap_pages; assigning non-deterministic values to any pointer arguments
462.486697 **** WARNING: no body for function guest_physmap_add_page$link1; assigning non-deterministic values to any pointer arguments
462.584316 Not unwinding loop memory_exchange.10 iteration 1 file memory.c line 630 function memory_exchange thread 0
462.681717 Not unwinding loop memory_exchange.11 iteration 1 file memory.c line 586 function memory_exchange thread 0
462.722783 Not unwinding loop memory_exchange.15 iteration 1 file memory.c line 490 function memory_exchange thread 0
463.102819 Not unwinding loop memory_exchange.19 iteration 1 file memory.c line 653 function memory_exchange thread 0
463.191112 Not unwinding loop memory_exchange.20 iteration 1 file memory.c line 664 function memory_exchange thread 0
463.849882 **** WARNING: no body for function xsm_memory_stat_reservation; assigning non-deterministic values to any pointer arguments
463.974384 **** WARNING: no body for function domain_get_maximum_gpfn; assigning non-deterministic values to any pointer arguments
464.204284 **** WARNING: no body for function xatp_permission_check; assigning non-deterministic values to any pointer arguments
464.266819 **** WARNING: no body for function xenmem_add_to_physmap; assigning non-deterministic values to any pointer arguments
464.798661 **** WARNING: no body for function xenmem_add_to_physmap_batch; assigning non-deterministic values to any pointer arguments
465.002013 **** WARNING: no body for function xsm_remove_from_physmap; assigning non-deterministic values to any pointer arguments
465.082326 **** WARNING: no body for function get_page_from_gfn$link3; assigning non-deterministic values to any pointer arguments
465.221249 **** WARNING: no body for function mem_access_memop; assigning non-deterministic values to any pointer arguments
465.400605 **** WARNING: no body for function rcu_lock_domain_by_id; assigning non-deterministic values to any pointer arguments
465.431706 **** WARNING: no body for function xsm_claim_pages; assigning non-deterministic values to any pointer arguments
465.451618 **** WARNING: no body for function domain_set_outstanding_pages; assigning non-deterministic values to any pointer arguments
465.679838 **** WARNING: no body for function xsm_get_vnumainfo; assigning non-deterministic values to any pointer arguments
465.746641 **** WARNING: no body for function _read_lock$link1; assigning non-deterministic values to any pointer arguments
465.758051 **** WARNING: no body for function _read_unlock$link1; assigning non-deterministic values to any pointer arguments
465.900869 **** WARNING: no body for function _xmalloc_array$link3; assigning non-deterministic values to any pointer arguments
466.004939 **** WARNING: no body for function __builtin_memcpy; assigning non-deterministic values to any pointer arguments
466.040567 **** WARNING: no body for function copy_to_user; assigning non-deterministic values to any pointer arguments
466.227921 **** WARNING: no body for function xfree; assigning non-deterministic values to any pointer arguments
466.464939 **** WARNING: no body for function iommu_get_reserved_device_memory; assigning non-deterministic values to any pointer arguments
466.574536 **** WARNING: no body for function arch_memory_op; assigning non-deterministic values to any pointer arguments
470.496263 size of program expression: 21008 steps
470.499119 simple slicing removed 18360 assignments
470.499643 Generated 1 VCC(s), 1 remaining after simplification
470.499653 Passing problem to propositional reduction
470.499671 converting SSA
470.708486 Running propositional reduction
470.708504 Post-processing
470.708539 Solving with MiniSAT 2.2.1 without simplifier
470.708544 603929 variables, 82608 clauses
470.775722 SAT checker: instance is SATISFIABLE
470.775750 Runtime decision procedure: 0.276067s
470.775758 Building error trace
471.238108 Counterexample:
471.273932 
#### Function call: __CPROVER_initialize() (depth 1) ####

#### Function return: __CPROVER_initialize (depth 0) ####

State 928 file memory.c line 909 thread 0
----------------------------------------------------
INPUT("cmd", cmd);
----------------------------------------------------
  INPUT cmd: 11ul (0xB)

State 931 file memory.c line 909 thread 0
----------------------------------------------------
INPUT("arg", arg);
----------------------------------------------------
  INPUT arg: { .p=NULL } ({ 0x0 })

#### Function call: do_memory_op(11ul, { .p=NULL }) (depth 1) ####

State 934 file memory.c line 909 thread 0
----------------------------------------------------
do_memory_op(cmd, arg);
----------------------------------------------------
  cmd=11ul (0xB)

State 935 file memory.c line 909 thread 0
----------------------------------------------------
do_memory_op(cmd, arg);
----------------------------------------------------
  arg={ .p=NULL } ({ 0x0 })

State 936 file memory.c line 911 function do_memory_op thread 0
----------------------------------------------------
struct domain *d;
----------------------------------------------------
  d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 937 file memory.c line 911 function do_memory_op thread 0
----------------------------------------------------
struct domain *curr_d;
----------------------------------------------------
  curr_d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

#### Function call: get_cpu_info$link13() (depth 2) ####

#### Function return: get_cpu_info$link13 (depth 1) ####

State 943 file memory.c line 911 function do_memory_op thread 0
----------------------------------------------------
curr_d = return_value_get_cpu_info->current_vcpu->domain;
----------------------------------------------------
  curr_d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 944 file memory.c line 912 function do_memory_op thread 0
----------------------------------------------------
signed long int rc;
----------------------------------------------------
  rc=0l (0x0)

State 945 file memory.c line 913 function do_memory_op thread 0
----------------------------------------------------
struct xen_memory_reservation reservation;
----------------------------------------------------
  reservation={ .extent_start={ .p=((unsigned long int *)NULL) }, .nr_extents=0ul,
    .extent_order=0u, .mem_flags=0u, .domid=0,
    .$pad5=0 } ({ { 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0 })

State 946 file memory.c line 914 function do_memory_op thread 0
----------------------------------------------------
struct memop_args args;
----------------------------------------------------
  args={ .domain=((struct domain *)NULL), .extent_list={ .p=((unsigned long int *)NULL) }, .nr_extents=0u,
    .extent_order=0u, .memflags=0u, .nr_done=0u,
    .preempted=0, .$pad7=0u } ({ 0x0, { 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 })

State 947 file memory.c line 915 function do_memory_op thread 0
----------------------------------------------------
domid_t domid;
----------------------------------------------------
  domid=0 (0x0)

State 948 file memory.c line 916 function do_memory_op thread 0
----------------------------------------------------
unsigned long int start_extent;
----------------------------------------------------
  start_extent=0ul (0x0)

State 949 file memory.c line 916 function do_memory_op thread 0
----------------------------------------------------
start_extent = cmd >> 6;
----------------------------------------------------
  start_extent=0ul (0x0)

State 950 file memory.c line 917 function do_memory_op thread 0
----------------------------------------------------
signed int op;
----------------------------------------------------
  op=0 (0x0)

State 951 file memory.c line 917 function do_memory_op thread 0
----------------------------------------------------
op = (signed int)(cmd & (unsigned long int)((1 << 6) - 1));
----------------------------------------------------
  op=11 (0xB)

State 957 file memory.c line 987 function do_memory_op thread 0
----------------------------------------------------
xen_memory_exchange_t *_x;
----------------------------------------------------
  _x=((struct xen_memory_exchange { struct xen_memory_reservation { struct { unsigned long int *p; } extent_start; unsigned long int nr_extents; u32 extent_order; u32 mem_flags; unsigned short int domid; unsigned __CPROVER_bitvector[48] $pad5; } in; struct xen_memory_reservation { struct { unsigned long int *p; } extent_start; unsigned long int nr_extents; u32 extent_order; u32 mem_flags; unsigned short int domid; unsigned __CPROVER_bitvector[48] $pad5; } out; unsigned long int nr_exchanged; } *)NULL) (0x0)

State 958 file memory.c line 987 function do_memory_op thread 0
----------------------------------------------------
_x = (xen_memory_exchange_t *)arg.p;
----------------------------------------------------
  _x=((struct xen_memory_exchange { struct xen_memory_reservation { struct { unsigned long int *p; } extent_start; unsigned long int nr_extents; u32 extent_order; u32 mem_flags; unsigned short int domid; unsigned __CPROVER_bitvector[48] $pad5; } in; struct xen_memory_reservation { struct { unsigned long int *p; } extent_start; unsigned long int nr_extents; u32 extent_order; u32 mem_flags; unsigned short int domid; unsigned __CPROVER_bitvector[48] $pad5; } out; unsigned long int nr_exchanged; } *)NULL) (0x0)

#### Function call: memory_exchange({ .p=((xen_memory_exchange_t *)NULL) }) (depth 2) ####

State 962 file memory.c line 987 function do_memory_op thread 0
----------------------------------------------------
memory_exchange(tmp_statement_expression$0);
----------------------------------------------------
  arg={ .p=((xen_memory_exchange_t *)NULL) } ({ 0x0 })

State 963 file memory.c line 414 function memory_exchange thread 0
----------------------------------------------------
struct xen_memory_exchange exch;
----------------------------------------------------
  exch={ .in={ .extent_start={ .p=((unsigned long int *)NULL) }, .nr_extents=0ul,
    .extent_order=0u, .mem_flags=0u, .domid=0,
    .$pad5=0 }, .out={ .extent_start={ .p=((unsigned long int *)NULL) }, .nr_extents=0ul,
    .extent_order=0u, .mem_flags=0u, .domid=0,
    .$pad5=0 },
    .nr_exchanged=0ul } ({ { { 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0 })

State 964 file memory.c line 415 function memory_exchange thread 0
----------------------------------------------------
struct page_list_head in_chunk_list;
----------------------------------------------------
  in_chunk_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) } ({ 0x0, 0x0 })

State 965 file memory.c line 415 function memory_exchange thread 0
----------------------------------------------------
in_chunk_list = { .next=(struct page_info *)(void *)0, .tail=(struct page_info *)(void *)0 };
----------------------------------------------------
  in_chunk_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) } ({ 0x0, 0x0 })

State 966 file memory.c line 416 function memory_exchange thread 0
----------------------------------------------------
struct page_list_head out_chunk_list;
----------------------------------------------------
  out_chunk_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) } ({ 0x0, 0x0 })

State 967 file memory.c line 416 function memory_exchange thread 0
----------------------------------------------------
out_chunk_list = { .next=(struct page_info *)(void *)0, .tail=(struct page_info *)(void *)0 };
----------------------------------------------------
  out_chunk_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) } ({ 0x0, 0x0 })

State 968 file memory.c line 417 function memory_exchange thread 0
----------------------------------------------------
unsigned long int in_chunk_order;
----------------------------------------------------
  in_chunk_order=0ul (0x0)

State 969 file memory.c line 417 function memory_exchange thread 0
----------------------------------------------------
unsigned long int out_chunk_order;
----------------------------------------------------
  out_chunk_order=0ul (0x0)

State 970 file memory.c line 418 function memory_exchange thread 0
----------------------------------------------------
xen_pfn_t gpfn;
----------------------------------------------------
  gpfn=0ul (0x0)

State 971 file memory.c line 418 function memory_exchange thread 0
----------------------------------------------------
xen_pfn_t gmfn;
----------------------------------------------------
  gmfn=0ul (0x0)

State 972 file memory.c line 418 function memory_exchange thread 0
----------------------------------------------------
xen_pfn_t mfn;
----------------------------------------------------
  mfn=0ul (0x0)

State 973 file memory.c line 419 function memory_exchange thread 0
----------------------------------------------------
unsigned long int i;
----------------------------------------------------
  i=0ul (0x0)

State 974 file memory.c line 419 function memory_exchange thread 0
----------------------------------------------------
unsigned long int j;
----------------------------------------------------
  j=0ul (0x0)

State 975 file memory.c line 419 function memory_exchange thread 0
----------------------------------------------------
unsigned long int k;
----------------------------------------------------
  k=0ul (0x0)

State 976 file memory.c line 420 function memory_exchange thread 0
----------------------------------------------------
unsigned int memflags;
----------------------------------------------------
  memflags=0u (0x0)

State 977 file memory.c line 420 function memory_exchange thread 0
----------------------------------------------------
memflags = (unsigned int)0;
----------------------------------------------------
  memflags=0u (0x0)

State 978 file memory.c line 421 function memory_exchange thread 0
----------------------------------------------------
signed long int rc;
----------------------------------------------------
  rc=0l (0x0)

State 979 file memory.c line 421 function memory_exchange thread 0
----------------------------------------------------
rc = (signed long int)0;
----------------------------------------------------
  rc=0l (0x0)

State 980 file memory.c line 422 function memory_exchange thread 0
----------------------------------------------------
struct domain *d;
----------------------------------------------------
  d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 981 file memory.c line 423 function memory_exchange thread 0
----------------------------------------------------
struct page_info *page;
----------------------------------------------------
  page=((struct page_info { union { struct page_list_entry { u32 next; u32 prev; } list; unsigned long int up; struct page_sharing_info *sharing; } $anon0; unsigned long int count_info; union { struct { unsigned long int type_info; } inuse; struct { unsigned long int type : 5; unsigned long int pinned : 1; unsigned long int head : 1; unsigned long int count : 25; u32 $pad4; } sh; struct { bool_t need_tlbflush; } free; } u; union { struct { u32 _domain; } inuse; struct { u32 back; } sh; struct { u32 order; } free; } v; union { u32 tlbflush_timestamp; struct { unsigned short int nr_validated_ptes; const char partial_pte; u8 $pad2; } $anon0; u32 shadow_flags; u32 next_shadow; } $anon1; } *)NULL) (0x0)

State 983 file memory.c line 425 function memory_exchange thread 0
----------------------------------------------------
const struct xen_memory_exchange *_s;
----------------------------------------------------
  _s=((struct xen_memory_exchange { struct xen_memory_reservation { struct { unsigned long int *p; } extent_start; unsigned long int nr_extents; u32 extent_order; u32 mem_flags; unsigned short int domid; unsigned __CPROVER_bitvector[48] $pad5; } in; struct xen_memory_reservation { struct { unsigned long int *p; } extent_start; unsigned long int nr_extents; u32 extent_order; u32 mem_flags; unsigned short int domid; unsigned __CPROVER_bitvector[48] $pad5; } out; unsigned long int nr_exchanged; } *)NULL) (0x0)

State 984 file memory.c line 425 function memory_exchange thread 0
----------------------------------------------------
_s = arg.p;
----------------------------------------------------
  _s=((struct xen_memory_exchange { struct xen_memory_reservation { struct { unsigned long int *p; } extent_start; unsigned long int nr_extents; u32 extent_order; u32 mem_flags; unsigned short int domid; unsigned __CPROVER_bitvector[48] $pad5; } in; struct xen_memory_reservation { struct { unsigned long int *p; } extent_start; unsigned long int nr_extents; u32 extent_order; u32 mem_flags; unsigned short int domid; unsigned __CPROVER_bitvector[48] $pad5; } out; unsigned long int nr_exchanged; } *)NULL) (0x0)

State 985 file memory.c line 425 function memory_exchange thread 0
----------------------------------------------------
struct xen_memory_exchange *_d;
----------------------------------------------------
  _d=((struct xen_memory_exchange { struct xen_memory_reservation { struct { unsigned long int *p; } extent_start; unsigned long int nr_extents; u32 extent_order; u32 mem_flags; unsigned short int domid; unsigned __CPROVER_bitvector[48] $pad5; } in; struct xen_memory_reservation { struct { unsigned long int *p; } extent_start; unsigned long int nr_extents; u32 extent_order; u32 mem_flags; unsigned short int domid; unsigned __CPROVER_bitvector[48] $pad5; } out; unsigned long int nr_exchanged; } *)NULL) (0x0)

State 986 file memory.c line 425 function memory_exchange thread 0
----------------------------------------------------
_d = &exch;
----------------------------------------------------
  _d=&exch!0@1.in.extent_start.p (0x24400000 0000000)

#### Function call: get_cpu_info$link13() (depth 3) ####

#### Function return: get_cpu_info$link13 (depth 2) ####

#### Function call: copy_from_user_hvm(&exch!0@1.in.extent_start.p, NULL, 72u) (depth 3) ####

#### Function return: copy_from_user_hvm (depth 2) ####

State 998 file memory.c line 425 function memory_exchange thread 0
----------------------------------------------------
copy_from_user_hvm((void *)_d, (const void *)(_s + (signed long int)0), (unsigned int)(sizeof(struct xen_memory_exchange) /*72ul*/  * (unsigned long int)1));
----------------------------------------------------
  exch={ .in={ .extent_start={ .p=INVALID-64250 }, .nr_extents=46724778489282564ul, .extent_order=8u,
    .mem_flags=0u, .domid=0, .$pad5=0 }, .out={ .extent_start={ .p=INVALID-64248 }, .nr_extents=11961543293256336384ul, .extent_order=0u,
    .mem_flags=0u, .domid=0, .$pad5=0 },
    .nr_exchanged=45212950001090560ul } ({ { { 0xFAFA7A7E 7F801FE2 }, 0xA5FFF040 100004, 0x8, 0x0, 0x0, 0x0 }, { { 0xFAF80000 00000005 }, 0xA5FFF040 10000400, 0x0, 0x0, 0x0, 0x0 }, 0xA0A0F040 100000 })

State 1005 file memory.c line 428 function memory_exchange thread 0
----------------------------------------------------
const unsigned int _x;
----------------------------------------------------
  _x=0u (0x0)

State 1006 file memory.c line 428 function memory_exchange thread 0
----------------------------------------------------
_x = exch.in.extent_order;
----------------------------------------------------
  _x=8u (0x8)

State 1007 file memory.c line 428 function memory_exchange thread 0
----------------------------------------------------
const unsigned int _y;
----------------------------------------------------
  _y=0u (0x0)

State 1008 file memory.c line 428 function memory_exchange thread 0
----------------------------------------------------
_y = exch.out.extent_order;
----------------------------------------------------
  _y=0u (0x0)

#### Function call: get_cpu_info$link13() (depth 3) ####

#### Function return: get_cpu_info$link13 (depth 2) ####

#### Function call: max_order(((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL)) (depth 3) ####

#### Function return: max_order (depth 2) ####

#### Function call: get_cpu_info$link13() (depth 3) ####

#### Function return: get_cpu_info$link13 (depth 2) ####

#### Function call: get_cpu_info$link13() (depth 3) ####

#### Function return: get_cpu_info$link13 (depth 2) ####

State 1046 file memory.c line 464 function memory_exchange thread 0
----------------------------------------------------
in_chunk_order = (unsigned long int)0;
----------------------------------------------------
  in_chunk_order=0ul (0x0)

State 1047 file memory.c line 465 function memory_exchange thread 0
----------------------------------------------------
out_chunk_order = (unsigned long int)(exch.in.extent_order - exch.out.extent_order);
----------------------------------------------------
  out_chunk_order=8ul (0x8)

#### Function call: rcu_lock_domain_by_any_id(0) (depth 3) ####

#### Function return: rcu_lock_domain_by_any_id (depth 2) ####

State 1051 file memory.c line 468 function memory_exchange thread 0
----------------------------------------------------
d = NONDET(struct domain *);
----------------------------------------------------
  d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) + 1l (0x1)

#### Function call: xsm_memory_exchange(/*enum*/XSM_TARGET, ((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) + 1l) (depth 3) ####

#### Function return: xsm_memory_exchange (depth 2) ####

State 1057 file memory.c line 475 function memory_exchange thread 0
----------------------------------------------------
xsm_memory_exchange((xsm_default_t)2, d);
----------------------------------------------------
  d$object={ .domain_id=0, .$pad1=0, .max_vcpus=0u, .vcpu=((struct vcpu **)NULL),
    .shared_info=((shared_info_t *)NULL), .domain_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .page_alloc_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .page_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .xenpage_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .tot_pages=0u,
    .xenheap_pages=0u, .outstanding_pages=0u, .max_pages=0u,
    .shr_pages={ .counter=0 }, .paged_pages={ .counter=0 },
    .sched_priv=NULL, .cpupool=((struct cpupool *)NULL),
    .next_in_list=((struct domain *)NULL), .next_in_hashbucket=((struct domain *)NULL),
    .rangesets={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) },
    .rangesets_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .evtchn=((struct evtchn *)NULL),
    .evtchn_group={ ((struct evtchn **)NULL), ((struct evtchn **)NULL), ((struct evtchn **)NULL), ((struct evtchn **)NULL) }, .max_evtchns=0u,
    .max_evtchn_port=0u, .valid_evtchns=0u,
    .event_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .$pad27=0u,
    .evtchn_port_ops=((const struct evtchn_port_ops *)NULL), .evtchn_fifo=((struct evtchn_fifo_domain *)NULL),
    .grant_table=((struct grant_table *)NULL),
    .pirq_tree={ .height=0u, .$pad1=0u, .rnode=((struct radix_tree_node *)NULL), .node_alloc=((radix_tree_alloc_fn_t (*))NULL),
    .node_free=((radix_tree_free_fn_t (*))NULL),
    .node_alloc_free_arg=NULL },
    .nr_pirqs=0u,
    .guest_type=/*enum*/guest_type_pv, .is_dying=/*enum*/DOMDYING_alive,
    .controller_pause_count=0, .time_offset_seconds=0l,
    .iommu={ .arch={ .pgd_maddr=0ul, .mapping_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .agaw=0,
    .$pad3=0u, .g2m_ioport_list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .iommu_bitmap=0ul,
    .mapped_rmrrs={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .paging_mode=0,
    .$pad8=0u, .root_table=((struct page_info *)NULL), .g_iommu=((struct guest_iommu *)NULL) }, .platform_ops=((const struct iommu_ops *)NULL),
    .features={ 0ul } }, .need_iommu=0,
    .auto_node_affinity=FALSE, .is_privileged=FALSE,
    .is_xenstore=FALSE, .is_pinned=FALSE,
    .disable_migrate=FALSE, .debugger_attached=FALSE,
    .creation_finished=FALSE, .target=((struct domain *)NULL),
    .poll_mask=((unsigned long int *)NULL), .iomem_caps=((struct rangeset *)NULL),
    .irq_caps=((struct rangeset *)NULL),
    .shutdown_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .is_shutting_down=FALSE,
    .is_shut_down=FALSE, .$pad53=0,
    .shutdown_code=0u, .suspend_evtchn=0u, .pause_count={ .counter=0 },
    .refcnt={ .counter=0 }, .$pad58=0u,
    .vm_assist=0ul, .domain_dirty_cpumask=((const cpumask_t *)NULL), .$pad61=0,
    .arch={ .perdomain_l3_pg=((struct page_info *)NULL), .hv_compat_vstart=0u,
    .physaddr_bitsize=0u, .ioport_caps=((struct rangeset *)NULL),
    .pci_cf8=0u,
    .cmos_idx=0, .s3_integrity=FALSE, .$pad7=0,
    .pdev_list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .$anon0={ .pv_domain={ .gdt_ldt_l1tab=((l1_pgentry_t **)NULL), .nr_l4_pages={ .counter=0 },
    .$pad2=0u, .mapcache={ .entries=0u, .cursor=0u, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .epoch=0u,
    .tlbflush_timestamp=0u, .inuse=((unsigned long int *)NULL), .garbage=((unsigned long int *)NULL) },
    .cpuidmasks=((struct cpuidmasks *)NULL) } },
    .paging={ .lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) }, .mode=0u,
    .p2m_alloc_failed=FALSE, .$pad3=0, .shadow={ .opt_flags=0u, .$pad1=0u, .pinned_shadows={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .freelist={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .total_pages=0u,
    .free_pages=0u, .p2m_pages=0u, .$pad7=0u,
    .unpaged_pagetable={ .pfn=0ul }, .gtable_dirty_version={ .counter=0 },
    .$pad10=0u,
    .hash_table=((struct page_info **)NULL), .hash_walking=FALSE,
    .has_fast_mmio_entries=FALSE, .oos_active=FALSE,
    .oos_off=FALSE, .pagetable_dying_op=FALSE, .$pad17=0 },
    .hap={ .freelist={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .total_pages=0u,
    .free_pages=0u, .p2m_pages=0u, .$pad4=0u },
    .log_dirty={ .top=0ul, .allocs=0u, .failed_allocs=0u, .fault_count=0u,
    .dirty_count=0u, .enable_log_dirty=((signed int (*)(struct domain *, bool_t))NULL), .disable_log_dirty=((signed int (*)(struct domain *))NULL),
    .clean_dirty_bitmap=((const void (*)(struct domain *))NULL) },
    .gfn_bits=0u,
    .$pad8=0u, .preempt={ .dom=((struct domain *)NULL), .op=0u, .$pad2=0u, .$anon0={ .log_dirty={ .done=0ul, .i4=0ul, .i3=0ul, .$bit_field_pad3=0 } } }, .alloc_page=((struct page_info * (*)(struct domain *))NULL),
    .free_page=((const void (*)(struct domain *, struct page_info *))NULL) },
    .p2m=((struct p2m_domain *)NULL),
    .page_alloc_unlock_level=0, .relmem=/*enum*/RELMEM_not_started,
    .relmem_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .nested_p2m={ ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL) },
    .nested_p2m_lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) },
    .altp2m_active=FALSE,
    .$pad18=0, .altp2m_p2m={ ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL) }, .altp2m_list_lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) },
    .altp2m_eptp=((unsigned long int *)NULL),
    .irq_pirq={ .height=0u, .$pad1=0u, .rnode=((struct radix_tree_node *)NULL), .node_alloc=((radix_tree_alloc_fn_t (*))NULL),
    .node_free=((radix_tree_free_fn_t (*))NULL),
    .node_alloc_free_arg=NULL },
    .is_32bit_pv=FALSE,
    .has_32bit_shinfo=FALSE, .suppress_spurious_page_faults=FALSE,
    .auto_unmask=FALSE,
    .x86=0, .x86_vendor=0, .x86_model=0,
    .x87_fip_width=0, .cpuids=((cpuid_input_t *)NULL), .vpit={ .hw={ .channels={ , ,  }, .speaker_data_on=0u, .pad0=0u }, .count_load_time={ 0l, 0l, 0l },
    .pt0={ .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .on_list=FALSE,
    .one_shot=FALSE, .do_not_freeze=FALSE, .irq_issued=FALSE,
    .warned_timeout_too_short=FALSE, .source=0,
    .irq=0, .$pad8=0, .vcpu=((struct vcpu *)NULL), .pending_intr_nr=0u,
    .$pad11=0u, .period=0ul, .scheduled=0l,
    .last_plt_gtime=0ul, .timer={ .expires=0l, .$anon0={ .heap_offset=0u }, .function=((const void (*)(const void *))NULL),
    .data=NULL,
    .cpu=0, .status=0, .$pad6=0 }, .cb=((time_cb (*))NULL),
    .priv=NULL }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } },
    .tsc_mode=0,
    .vtsc=FALSE, .$pad35=0, .vtsc_last=0l,
    .vtsc_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .vtsc_offset=0ul,
    .tsc_khz=0u, .vtsc_to_ns={ .shift=0, .mul_frac=0u }, .ns_to_vtsc={ .shift=0, .mul_frac=0u },
    .incarnation=0u,
    .e820_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .e820=((struct e820entry *)NULL),
    .nr_e820=0u, .psr_rmid=0u,
    .psr_cos_ids=((u32 *)NULL), .pirq_eoi_map=((unsigned long int *)NULL),
    .pirq_eoi_map_mfn=0ul,
    .monitor={ .write_ctrlreg_enabled=0u, .write_ctrlreg_sync=0u, .write_ctrlreg_onchangeonly=0u,
    .singlestep_enabled=0u, .software_breakpoint_enabled=0u,
    .debug_exception_enabled=0u, .debug_exception_sync=0u,
    .cpuid_enabled=0u, .$bit_field_pad8=0,
    .$pad9=0, .msr_bitmap=((struct monitor_msr_bitmap *)NULL) }, .mem_access_emulate_each_rep=FALSE,
    .$pad52=0, .emulation_flags=0u,
    .$pad54=0 }, .ssid=NULL,
    .handle={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .pbuf=((const char *)NULL),
    .pbuf_idx=0u, .pbuf_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .$pad68=0u,
    .xenoprof=((struct xenoprof *)NULL), .watchdog_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .watchdog_inuse_map=0u,
    .$pad72=0u, .watchdog_timer={ ,  }, .rcu={ .next=((struct rcu_head *)NULL), .func=((const void (*)(struct rcu_head *))NULL) },
    .hypercall_deadlock_mutex={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .tmem_client=((struct client *)NULL),
    .profile_head=irep("(\"nil\")"),
    .vm_event=((struct vm_event_per_domain *)NULL), .node_affinity={ .bits={ 0ul } },
    .last_alloc_node=0u, .node_affinity_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .vnuma_rwlock={ .cnts={ .counter=0 }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } },
    .vnuma=((struct vnuma_info *)NULL),
    .monitor={ .guest_request_enabled=0u, .guest_request_sync=0u, .$bit_field_pad2=0,
    .$pad3=0 }, .$pad85=0u } ({ 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, { { 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0 }, 0x0, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0, { 0x0 } }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, { 0x0 }, 0x0, { 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0 }, { { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0 } }, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { { { ?, ?, ? }, 0x0, 0x0 }, { 0x0, 0x0, 0x0 }, { { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { ?, ? }, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, ?, 0x0, { { 0x0 } }, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, { { 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, { 0x0, 0x0, 0x0, 0x0 }, 0x0 })

State 1059 file memory.c line 475 function memory_exchange thread 0
----------------------------------------------------
rc = (signed long int)return_value_xsm_memory_exchange;
----------------------------------------------------
  rc=0l (0x0)

#### Function call: get_cpu_info$link13() (depth 3) ####

#### Function return: get_cpu_info$link13 (depth 2) ####

State 1073 file memory.c line 482 function memory_exchange thread 0
----------------------------------------------------
unsigned long int __off;
----------------------------------------------------
  __off=0ul (0x0)

#### Function call: get_cpu_info$link13() (depth 3) ####

#### Function return: get_cpu_info$link13 (depth 2) ####

State 1079 file memory.c line 482 function memory_exchange thread 0
----------------------------------------------------
__off = (unsigned long int)(exch.in.extent_start.p + (signed long int)exch.nr_exchanged) - (unsigned long int)(void *)(((260ul >> 8) * 0xFFFF000000000000ul | 260ul << 39) + (unsigned long int)2 * (((1ul << 39) >> 20 + 9) << 20) + (unsigned long int)(return_value_get_cpu_info$6->current_vcpu->vcpu_id << 2 + 12));
----------------------------------------------------
  __off=8162ul (0x1FE2)

Violated property:
  file memory.c line 482 function memory_exchange
  memory_exchange exploited overflow and has access outside of allocated memory
  tmp_if_expr$15


471.274230 VERIFICATION FAILED

real	0m13.488s
user	0m13.220s
sys	0m0.264s
goto-instrument options: --aggressive-slice --aggressive-slice-call-depth 0 
cbmc options:  --stop-on-fail --object-bits 16 --trace --trace-show-function-calls --trace-show-code --trace-hex --no-sat-preprocessor --unwind 0 --havoc-undefined-functions 
End time 1537520261
