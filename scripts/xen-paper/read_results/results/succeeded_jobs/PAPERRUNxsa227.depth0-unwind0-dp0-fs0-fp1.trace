Start analysis: 1537519877
Done slicing 1537520321
Reading GOTO program from `xsa227.sliced.binary'
Effective lines of code: 1235
Reading GOTO program from `xsa227.binary'
Effective lines of code: 101800
511.133779 CBMC version 5.10 (cbmc-5.10-163-g755b00c) 64-bit x86_64 linux
511.134437 Reading GOTO program from file
511.134445 Reading: xsa227.sliced.binary
512.029032 Generating GOTO Program
512.047786 Adding CPROVER library (x86_64)
512.056214 Removal of function pointers and virtual functions
512.191968 Generic Property Instrumentation
512.270332 Running with 16 object bits, 48 offset bits (user-specified)
512.276814 Starting Bounded Model Checking
513.492118 **** WARNING: no body for function get_cpu_info$link6; assigning non-deterministic values to any pointer arguments
513.561643 **** WARNING: no body for function copy_from_user_hvm; assigning non-deterministic values to any pointer arguments
513.569926 **** WARNING: no body for function __copy_from_user; assigning non-deterministic values to any pointer arguments
513.635282 **** WARNING: no body for function gdprintk$link2; assigning non-deterministic values to any pointer arguments
513.718453 **** WARNING: no body for function rcu_lock_domain_by_id; assigning non-deterministic values to any pointer arguments
513.758314 **** WARNING: no body for function xsm_grant_mapref; assigning non-deterministic values to any pointer arguments
513.797206 **** WARNING: no body for function rcu_unlock_domain$link4; assigning non-deterministic values to any pointer arguments
513.851446 **** WARNING: no body for function get_maptrack_handle; assigning non-deterministic values to any pointer arguments
513.908674 **** WARNING: no body for function grant_read_lock; assigning non-deterministic values to any pointer arguments
513.909425 **** WARNING: no body for function nr_grant_entries; assigning non-deterministic values to any pointer arguments
513.922081 **** WARNING: no body for function active_entry_acquire; assigning non-deterministic values to any pointer arguments
513.922967 **** WARNING: no body for function shared_entry_header; assigning non-deterministic values to any pointer arguments
514.061043 **** WARNING: no body for function _set_status; assigning non-deterministic values to any pointer arguments
514.088564 **** WARNING: no body for function __get_paged_frame; assigning non-deterministic values to any pointer arguments
514.172572 **** WARNING: no body for function active_entry_release; assigning non-deterministic values to any pointer arguments
514.173002 **** WARNING: no body for function grant_read_unlock; assigning non-deterministic values to any pointer arguments
514.175054 **** WARNING: no body for function __mfn_valid; assigning non-deterministic values to any pointer arguments
514.176618 **** WARNING: no body for function pfn_to_pdx$link2; assigning non-deterministic values to any pointer arguments
514.198454 **** WARNING: no body for function page_get_owner_and_reference; assigning non-deterministic values to any pointer arguments
514.279270 **** WARNING: no body for function put_page; assigning non-deterministic values to any pointer arguments
514.312259 **** WARNING: no body for function rangeset_contains_range; assigning non-deterministic values to any pointer arguments
514.331296 **** WARNING: no body for function get_cpu_info$link17$link2; assigning non-deterministic values to any pointer arguments
514.345046 **** WARNING: no body for function create_grant_p2m_mapping; assigning non-deterministic values to any pointer arguments
514.356128 **** WARNING: no body for function constant_test_bit$link11$link1; assigning non-deterministic values to any pointer arguments
514.397807 **** WARNING: no body for function cacheattr_to_pte_flags; assigning non-deterministic values to any pointer arguments
514.436448 **** WARNING: no body for function gdprintk$link22; assigning non-deterministic values to any pointer arguments
514.488948 **** WARNING: no body for function get_page_from_gfn$link2$link2; assigning non-deterministic values to any pointer arguments
514.526906 **** WARNING: no body for function pdx_to_pfn$link3$link4; assigning non-deterministic values to any pointer arguments
514.527111 **** WARNING: no body for function _mfn$link4$link3; assigning non-deterministic values to any pointer arguments
514.527209 **** WARNING: no body for function map_domain_page; assigning non-deterministic values to any pointer arguments
514.527528 **** WARNING: no body for function page_lock; assigning non-deterministic values to any pointer arguments
514.542483 **** WARNING: no body for function page_unlock; assigning non-deterministic values to any pointer arguments
514.556985 **** WARNING: no body for function update_intpte; assigning non-deterministic values to any pointer arguments
514.601241 **** WARNING: no body for function put_page_from_l1e; assigning non-deterministic values to any pointer arguments
514.704729 **** WARNING: no body for function unmap_domain_page; assigning non-deterministic values to any pointer arguments
514.765253 **** WARNING: no body for function create_grant_va_mapping; assigning non-deterministic values to any pointer arguments
514.942113 **** WARNING: no body for function get_page_type; assigning non-deterministic values to any pointer arguments
515.523349 **** WARNING: no body for function get_page; assigning non-deterministic values to any pointer arguments
515.850897 **** WARNING: no body for function double_gt_lock; assigning non-deterministic values to any pointer arguments
515.853562 **** WARNING: no body for function mapkind; assigning non-deterministic values to any pointer arguments
515.877528 **** WARNING: no body for function iommu_map_page; assigning non-deterministic values to any pointer arguments
516.013373 **** WARNING: no body for function double_gt_unlock; assigning non-deterministic values to any pointer arguments
516.055744 **** WARNING: no body for function __trace_var; assigning non-deterministic values to any pointer arguments
516.080676 **** WARNING: no body for function write_u16_atomic$link4; assigning non-deterministic values to any pointer arguments
516.568390 **** WARNING: no body for function put_page_type; assigning non-deterministic values to any pointer arguments
516.789032 **** WARNING: no body for function gnttab_clear_flag; assigning non-deterministic values to any pointer arguments
517.044069 **** WARNING: no body for function put_maptrack_handle; assigning non-deterministic values to any pointer arguments
517.546305 **** WARNING: no body for function copy_to_user_hvm; assigning non-deterministic values to any pointer arguments
517.560203 **** WARNING: no body for function __copy_to_user$link3; assigning non-deterministic values to any pointer arguments
517.586071 Not unwinding loop gnttab_map_grant_ref.0 iteration 1 file grant_table.c line 1059 function gnttab_map_grant_ref thread 0
517.906396 **** WARNING: no body for function gnttab_unmap_grant_ref; assigning non-deterministic values to any pointer arguments
518.039838 **** WARNING: no body for function replace_grant_supported; assigning non-deterministic values to any pointer arguments
518.051281 **** WARNING: no body for function gnttab_unmap_and_replace; assigning non-deterministic values to any pointer arguments
518.111922 **** WARNING: no body for function gnttab_setup_table; assigning non-deterministic values to any pointer arguments
518.233301 **** WARNING: no body for function gnttab_transfer; assigning non-deterministic values to any pointer arguments
518.365908 **** WARNING: no body for function gnttab_copy; assigning non-deterministic values to any pointer arguments
518.427596 **** WARNING: no body for function gnttab_query_size; assigning non-deterministic values to any pointer arguments
518.479176 **** WARNING: no body for function gnttab_set_version; assigning non-deterministic values to any pointer arguments
518.531067 **** WARNING: no body for function gnttab_get_status_frames; assigning non-deterministic values to any pointer arguments
518.582710 **** WARNING: no body for function gnttab_get_version; assigning non-deterministic values to any pointer arguments
518.706987 **** WARNING: no body for function gnttab_swap_grant_ref; assigning non-deterministic values to any pointer arguments
518.842724 **** WARNING: no body for function gnttab_cache_flush; assigning non-deterministic values to any pointer arguments
520.294763 **** WARNING: no body for function hypercall_create_continuation; assigning non-deterministic values to any pointer arguments
520.612128 size of program expression: 8689 steps
520.613198 simple slicing removed 5723 assignments
520.613202 Generated 2 VCC(s), 2 remaining after simplification
520.613210 Passing problem to propositional reduction
520.613222 converting SSA
521.016622 Running propositional reduction
521.016641 Post-processing
521.027157 Solving with MiniSAT 2.2.1 without simplifier
521.027164 709078 variables, 902890 clauses
521.164488 SAT checker: instance is SATISFIABLE
521.164534 Runtime decision procedure: 0.551282s
521.164541 Building error trace
521.558179 Counterexample:
521.627530 
#### Function call: __CPROVER_initialize() (depth 1) ####

#### Function return: __CPROVER_initialize (depth 0) ####

#### Function call: my_granttable_init() (depth 1) ####

State 928 file grant_table.c line 3595 function my_granttable_init thread 0
----------------------------------------------------
unsigned int cmd;
----------------------------------------------------
  cmd=0u (0x0)

State 929 file grant_table.c line 3596 function my_granttable_init thread 0
----------------------------------------------------
__guest_handle_void uop;
----------------------------------------------------
  uop={ .p=NULL } ({ 0x0 })

State 930 file grant_table.c line 3597 function my_granttable_init thread 0
----------------------------------------------------
unsigned int count;
----------------------------------------------------
  count=1u (0x1)

#### Function call: do_grant_table_op(0u, { .p=NULL }, 1u) (depth 2) ####

State 933 file grant_table.c line 3598 function my_granttable_init thread 0
----------------------------------------------------
do_grant_table_op(cmd, uop, count);
----------------------------------------------------
  cmd=0u (0x0)

State 934 file grant_table.c line 3598 function my_granttable_init thread 0
----------------------------------------------------
do_grant_table_op(cmd, uop, count);
----------------------------------------------------
  uop={ .p=NULL } ({ 0x0 })

State 935 file grant_table.c line 3598 function my_granttable_init thread 0
----------------------------------------------------
do_grant_table_op(cmd, uop, count);
----------------------------------------------------
  count=1u (0x1)

State 936 file grant_table.c line 3021 function do_grant_table_op thread 0
----------------------------------------------------
signed long int rc;
----------------------------------------------------
  rc=0l (0x0)

State 937 file grant_table.c line 3022 function do_grant_table_op thread 0
----------------------------------------------------
unsigned int opaque_in;
----------------------------------------------------
  opaque_in=0u (0x0)

State 938 file grant_table.c line 3022 function do_grant_table_op thread 0
----------------------------------------------------
opaque_in = cmd & (unsigned int)~((1 << 12) - 1);
----------------------------------------------------
  opaque_in=0u (0x0)

State 939 file grant_table.c line 3022 function do_grant_table_op thread 0
----------------------------------------------------
unsigned int opaque_out;
----------------------------------------------------
  opaque_out=0u (0x0)

State 940 file grant_table.c line 3022 function do_grant_table_op thread 0
----------------------------------------------------
opaque_out = (unsigned int)0;
----------------------------------------------------
  opaque_out=0u (0x0)

State 942 file grant_table.c line 3027 function do_grant_table_op thread 0
----------------------------------------------------
cmd = cmd & (unsigned int)((1 << 12) - 1);
----------------------------------------------------
  cmd=0u (0x0)

State 945 file grant_table.c line 3030 function do_grant_table_op thread 0
----------------------------------------------------
rc = (signed long int)-14;
----------------------------------------------------
  rc=-14l (0xFFFFFFFF FFFFFFF2)

State 948 file grant_table.c line 3036 function do_grant_table_op thread 0
----------------------------------------------------
__guest_handle_gnttab_map_grant_ref_t map;
----------------------------------------------------
  map={ .p=((gnttab_map_grant_ref_t *)NULL) } ({ 0x0 })

State 950 file grant_table.c line 3037 function do_grant_table_op thread 0
----------------------------------------------------
gnttab_map_grant_ref_t *_x;
----------------------------------------------------
  _x=((struct gnttab_map_grant_ref { unsigned long int host_addr; u32 flags; u32 ref; unsigned short int dom; s16 status; u32 handle; unsigned long int dev_bus_addr; } *)NULL) (0x0)

State 951 file grant_table.c line 3037 function do_grant_table_op thread 0
----------------------------------------------------
_x = (gnttab_map_grant_ref_t *)uop.p;
----------------------------------------------------
  _x=((struct gnttab_map_grant_ref { unsigned long int host_addr; u32 flags; u32 ref; unsigned short int dom; s16 status; u32 handle; unsigned long int dev_bus_addr; } *)NULL) (0x0)

State 953 file grant_table.c line 3036 function do_grant_table_op thread 0
----------------------------------------------------
map = tmp_statement_expression;
----------------------------------------------------
  map={ .p=((gnttab_map_grant_ref_t *)NULL) } ({ 0x0 })

#### Function call: get_cpu_info$link6() (depth 3) ####

#### Function return: get_cpu_info$link6 (depth 2) ####

#### Function call: gnttab_map_grant_ref({ .p=((gnttab_map_grant_ref_t *)NULL) }, 1u) (depth 3) ####

State 969 file grant_table.c line 3040 function do_grant_table_op thread 0
----------------------------------------------------
gnttab_map_grant_ref(map, count);
----------------------------------------------------
  uop={ .p=((gnttab_map_grant_ref_t *)NULL) } ({ 0x0 })

State 970 file grant_table.c line 3040 function do_grant_table_op thread 0
----------------------------------------------------
gnttab_map_grant_ref(map, count);
----------------------------------------------------
  count=1u (0x1)

State 971 file grant_table.c line 1056 function gnttab_map_grant_ref thread 0
----------------------------------------------------
signed int i;
----------------------------------------------------
  i=0 (0x0)

State 972 file grant_table.c line 1057 function gnttab_map_grant_ref thread 0
----------------------------------------------------
struct gnttab_map_grant_ref op;
----------------------------------------------------
  op={ .host_addr=0ul, .flags=0u, .ref=0u, .dom=0, .status=0,
    .handle=0u, .dev_bus_addr=0ul } ({ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 })

State 973 file grant_table.c line 1059 function gnttab_map_grant_ref thread 0
----------------------------------------------------
i = 0;
----------------------------------------------------
  i=0 (0x0)

State 977 file grant_table.c line 1063 function gnttab_map_grant_ref thread 0
----------------------------------------------------
const struct gnttab_map_grant_ref *_s;
----------------------------------------------------
  _s=((struct gnttab_map_grant_ref { unsigned long int host_addr; u32 flags; u32 ref; unsigned short int dom; s16 status; u32 handle; unsigned long int dev_bus_addr; } *)NULL) (0x0)

State 978 file grant_table.c line 1063 function gnttab_map_grant_ref thread 0
----------------------------------------------------
_s = uop.p;
----------------------------------------------------
  _s=((struct gnttab_map_grant_ref { unsigned long int host_addr; u32 flags; u32 ref; unsigned short int dom; s16 status; u32 handle; unsigned long int dev_bus_addr; } *)NULL) (0x0)

State 979 file grant_table.c line 1063 function gnttab_map_grant_ref thread 0
----------------------------------------------------
struct gnttab_map_grant_ref *_d;
----------------------------------------------------
  _d=((struct gnttab_map_grant_ref { unsigned long int host_addr; u32 flags; u32 ref; unsigned short int dom; s16 status; u32 handle; unsigned long int dev_bus_addr; } *)NULL) (0x0)

State 980 file grant_table.c line 1063 function gnttab_map_grant_ref thread 0
----------------------------------------------------
_d = &op;
----------------------------------------------------
  _d=&op!0@1.host_addr (0x24300000 0000000)

#### Function call: get_cpu_info$link6() (depth 4) ####

#### Function return: get_cpu_info$link6 (depth 3) ####

#### Function call: copy_from_user_hvm(&op!0@1.host_addr, NULL, 32u) (depth 4) ####

#### Function return: copy_from_user_hvm (depth 3) ####

State 992 file grant_table.c line 1063 function gnttab_map_grant_ref thread 0
----------------------------------------------------
copy_from_user_hvm((void *)_d, (const void *)(_s + (signed long int)i), (unsigned int)(sizeof(struct gnttab_map_grant_ref) /*32ul*/  * (unsigned long int)1));
----------------------------------------------------
  op={ .host_addr=1ul, .flags=22u, .ref=0u, .dom=0, .status=0,
    .handle=0u, .dev_bus_addr=0ul } ({ 0x1, 0x16, 0x0, 0x0, 0x0, 0x0, 0x0 })

#### Function call: __gnttab_map_grant_ref(&op!0@1.host_addr) (depth 4) ####

State 1000 file grant_table.c line 1065 function gnttab_map_grant_ref thread 0
----------------------------------------------------
__gnttab_map_grant_ref(&op);
----------------------------------------------------
  op=&op!0@1.host_addr (0x24300000 0000000)

State 1001 file grant_table.c line 753 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
struct domain *ld;
----------------------------------------------------
  ld=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 1002 file grant_table.c line 753 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
struct domain *rd;
----------------------------------------------------
  rd=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 1003 file grant_table.c line 753 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
struct domain *owner;
----------------------------------------------------
  owner=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 1004 file grant_table.c line 753 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
owner = (struct domain *)(void *)0;
----------------------------------------------------
  owner=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 1005 file grant_table.c line 754 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
struct grant_table *lgt;
----------------------------------------------------
  lgt=((struct grant_table { struct percpu_rwlock { struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } rwlock; bool_t writer_activating; unsigned __CPROVER_bitvector[24] $pad2; } lock; u32 nr_grant_frames; u32 $pad2; union { const void **shared_raw; struct grant_entry_v1 **shared_v1; union grant_entry_v2 **shared_v2; } $anon0; u32 nr_status_frames; u32 $pad5; unsigned short int **status; struct active_grant_entry **active; struct grant_mapping **maptrack; u32 maptrack_limit; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } maptrack_lock; u32 gt_version; } *)NULL) (0x0)

State 1006 file grant_table.c line 754 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
struct grant_table *rgt;
----------------------------------------------------
  rgt=((struct grant_table { struct percpu_rwlock { struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } rwlock; bool_t writer_activating; unsigned __CPROVER_bitvector[24] $pad2; } lock; u32 nr_grant_frames; u32 $pad2; union { const void **shared_raw; struct grant_entry_v1 **shared_v1; union grant_entry_v2 **shared_v2; } $anon0; u32 nr_status_frames; u32 $pad5; unsigned short int **status; struct active_grant_entry **active; struct grant_mapping **maptrack; u32 maptrack_limit; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } maptrack_lock; u32 gt_version; } *)NULL) (0x0)

State 1007 file grant_table.c line 755 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
struct vcpu *led;
----------------------------------------------------
  led=((struct vcpu { signed int vcpu_id; signed int processor; vcpu_info_t *vcpu_info; struct domain *domain; struct vcpu *next_in_list; signed long int periodic_period; signed long int periodic_last_event; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } periodic_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } singleshot_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } poll_timer; const void *sched_priv; struct vcpu_runstate_info { signed int state; u32 $pad1; unsigned long int state_entry_time; unsigned long int time[4l]; } runstate; union { struct { vcpu_runstate_info_t *p; } native; struct { vcpu_runstate_info_compat_t *p; } compat; } runstate_guest; unsigned long int last_run_time; bool_t fpu_initialised; bool_t fpu_dirtied; bool_t is_initialised; bool_t is_running; bool_t is_urgent; struct async_exception_state[2l]; u8 async_exception_mask; bool_t defer_shutdown; bool_t paused_for_shutdown; bool_t affinity_broken; unsigned __CPROVER_bitvector[24] $pad24; signed int poll_evtchn; signed int pirq_evtchn_head; unsigned long int pause_flags; struct { signed int counter; } pause_count; struct { signed int counter; } vm_event_pause_count; signed int controller_pause_count; u32 maptrack_head; u32 maptrack_tail; u32 virq_to_evtchn[24l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } virq_lock; u32 $pad35; const cpumask_t *cpu_hard_affinity; const cpumask_t *cpu_hard_affinity_tmp; const cpumask_t *cpu_hard_affinity_saved; const cpumask_t *cpu_soft_affinity; const cpumask_t *vcpu_dirty_cpumask; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } continue_hypercall_tasklet; struct mc_state { unsigned long int flags; union { struct multicall_entry { unsigned long int op; unsigned long int result; unsigned long int args[6l]; } call; struct compat_multicall_entry { u32 op; u32 result; u32 args[6l]; } compat_call; } $anon0; } mc_state; struct waitqueue_vcpu *waitqueue_vcpu; unsigned long int vcpu_info_mfn; struct evtchn_fifo_vcpu *evtchn_fifo; unsigned __CPROVER_bitvector[320] $pad46; struct arch_vcpu { const void *fpu_ctxt; unsigned long int vgc_flags; struct cpu_user_regs { unsigned long int r15; unsigned long int r14; unsigned long int r13; unsigned long int r12; union { unsigned long int rbp; unsigned long int ebp; u32 _ebp; } $anon0; union { unsigned long int rbx; unsigned long int ebx; u32 _ebx; } $anon1; unsigned long int r11; unsigned long int r10; unsigned long int r9; unsigned long int r8; union { unsigned long int rax; unsigned long int eax; u32 _eax; } $anon2; union { unsigned long int rcx; unsigned long int ecx; u32 _ecx; } $anon3; union { unsigned long int rdx; unsigned long int edx; u32 _edx; } $anon4; union { unsigned long int rsi; unsigned long int esi; u32 _esi; } $anon5; union { unsigned long int rdi; unsigned long int edi; u32 _edi; } $anon6; u32 error_code; u32 entry_vector; union { unsigned long int rip; unsigned long int eip; u32 _eip; } $anon7; unsigned short int cs; unsigned short int _pad0[1l]; u8 saved_upcall_mask; u8 _pad1[3l]; union { unsigned long int rflags; unsigned long int eflags; u32 _eflags; } $anon8; union { unsigned long int rsp; unsigned long int esp; u32 _esp; } $anon9; unsigned short int ss; unsigned short int _pad2[3l]; unsigned short int es; unsigned short int _pad3[3l]; unsigned short int ds; unsigned short int _pad4[3l]; unsigned short int fs; unsigned short int _pad5[3l]; unsigned short int gs; unsigned short int _pad6[3l]; } user_regs; unsigned long int debugreg[8l]; unsigned long int flags; const void (*schedule_tail)(struct vcpu *); const void (*ctxt_switch_from)(struct vcpu *); const void (*ctxt_switch_to)(struct vcpu *); struct vpmu_struct { u32 flags; u32 last_pcpu; u32 hw_lapic_lvtpc; u32 $pad3; const void *context; const void *priv_context; struct arch_vpmu_ops *arch_vpmu_ops; struct xen_pmu_data *xenpmu_data; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vpmu_lock; } vpmu; unsigned __int128; union { struct pv_vcpu { struct mapcache_vcpu { u32 shadow_epoch; u32 $pad1; struct vcpu_maphash_entry hash[8l]; } mapcache; struct trap_info *trap_ctxt; unsigned long int gdt_frames[14l]; unsigned long int ldt_base; u32 gdt_ents; u32 ldt_ents; unsigned long int kernel_ss; unsigned long int kernel_sp; unsigned long int ctrlreg[8l]; unsigned long int event_callback_eip; unsigned long int failsafe_callback_eip; union { unsigned long int syscall_callback_eip; struct { u32 event_callback_cs; u32 failsafe_callback_cs; } $anon0; } $anon0; unsigned long int syscall32_callback_eip; unsigned long int sysenter_callback_eip; unsigned short int syscall32_callback_cs; unsigned short int sysenter_callback_cs; bool_t syscall32_disables_events; bool_t sysenter_disables_events; unsigned short int $pad18; unsigned long int fs_base; unsigned long int gs_base_kernel; unsigned long int gs_base_user; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } trap_bounce; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } int80_bounce; struct { u8 *p; } iobmp; u32 iobmp_limit; u32 iopl; unsigned long int shadow_ldt_mapcnt; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shadow_ldt_lock; u32 dr_mask[4l]; bool_t need_update_runstate_area; unsigned __CPROVER_bitvector[56] $pad31; struct vcpu_time_info { u32 version; u32 pad0; unsigned long int tsc_timestamp; unsigned long int system_time; u32 tsc_to_system_mul; const char tsc_shift; u8 flags; u8 pad1[2l]; } pending_system_time; } pv_vcpu; struct hvm_vcpu { unsigned long int guest_cr[5l]; unsigned long int guest_efer; unsigned long int hw_cr[5l]; struct vlapic { struct hvm_hw_lapic { unsigned long int apic_base_msr; u32 disabled; u32 timer_divisor; unsigned long int tdt_msr; } hw; struct hvm_hw_lapic_regs *regs; struct { bool_t hw; bool_t regs; unsigned short int $pad2; u32 id; u32 ldr; } loaded; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } esr_lock; u32 $pad4; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt; signed long int timer_last_update; struct page_info *regs_page; struct { u32 icr; u32 dest; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } tasklet; } init_sipi; } vlapic; signed long int cache_tsc_offset; unsigned long int guest_time; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } tm_lock; struct list_head { struct list_head *next; struct list_head *prev; } tm_list; u8 flag_dr_dirty; bool_t debug_state_latch; bool_t single_step; bool_t hcall_preempted; bool_t hcall_64bit; unsigned __CPROVER_bitvector[24] $pad13; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } n1asid; u32 msr_tsc_aux; u32 $pad16; unsigned long int msr_tsc_adjust; unsigned long int msr_xss; unsigned __CPROVER_bitvector[192] $pad19; union { struct arch_vmx_struct { unsigned long int vmcs_pa; unsigned long int vmcs_shadow_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vmcs_lock; struct list_head { struct list_head *next; struct list_head *prev; } active_list; signed int active_cpu; signed int launched; u32 exec_control; u32 secondary_exec_control; u32 exception_bitmap; u32 $pad9; struct vmx_msr_state { unsigned long int flags; unsigned long int msrs[3l]; } msr_state; unsigned long int shadow_gs; unsigned long int cstar; unsigned long int *msr_bitmap; u32 msr_count; u32 $pad15; struct vmx_msr_entry *msr_area; u32 host_msr_count; u32 $pad18; struct vmx_msr_entry *host_msr_area; unsigned long int eoi_exitmap_changed; unsigned long int eoi_exit_bitmap[4l]; struct pi_desc { unsigned long int pir[4l]; union { struct { unsigned short int on : 1; unsigned short int sn : 1; unsigned short int rsvd_1 : 14; u8 nv; u8 rsvd_2; u32 ndst; } $anon0; unsigned long int control; } $anon0; u32 rsvd[6l]; } pi_desc; unsigned long int host_cr0; bool_t ept_spurious_misconfig; u8 vmx_realmode; u8 vmx_emulate; u8 $pad27; unsigned short int vm86_segment_mask; struct segment_register vm86_saved_seg[7l]; unsigned short int $pad30; u32 vm86_saved_eflags; signed int hostenv_migrated; struct page_info *vmread_bitmap; struct page_info *vmwrite_bitmap; struct page_info *pml_pg; struct pi_blocking_vcpu { struct list_head { struct list_head *next; struct list_head *prev; } list; spinlock_t *lock; } pi_blocking; unsigned long int $pad37; } vmx; struct arch_svm_struct { struct vmcb_struct *vmcb; unsigned long int vmcb_pa; unsigned long int *msrpm; signed int launch_core; bool_t vmcb_in_sync; u8 cached_insn_len; unsigned short int $pad6; unsigned long int guest_sysenter_cs; unsigned long int guest_sysenter_esp; unsigned long int guest_sysenter_eip; unsigned long int guest_lwp_cfg; unsigned long int cpu_lwp_cfg; u32 dr_mask[4l]; struct { unsigned long int length; unsigned long int status; } osvw; } svm; } u; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } assert_evtchn_irq_tasklet; struct nestedvcpu { bool_t nv_guestmode; unsigned __CPROVER_bitvector[56] $pad1; const void *nv_vvmcx; const void *nv_n1vmcx; const void *nv_n2vmcx; unsigned long int nv_vvmcxaddr; unsigned long int nv_n1vmcx_pa; unsigned long int nv_n2vmcx_pa; union { struct nestedsvm { bool_t ns_gif; unsigned __CPROVER_bitvector[56] $pad1; unsigned long int ns_msr_hsavepa; unsigned long int ns_ovvmcb_pa; unsigned long int ns_tscratio; u32 ns_cr_intercepts; u32 ns_dr_intercepts; u32 ns_exception_intercepts; u32 ns_general1_intercepts; u32 ns_general2_intercepts; union { unsigned long int bytes; struct { unsigned long int enable : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad1 : 7; unsigned __CPROVER_bitvector[56] $pad2; } fields; } ns_lbr_control; u32 $pad11; unsigned long int *ns_cached_msrpm; unsigned long int *ns_merged_msrpm; unsigned long int ns_iomap_pa; unsigned long int ns_oiomap_pa; unsigned long int *ns_iomap; unsigned long int ns_cr0; unsigned long int ns_vmcb_guestcr3; unsigned long int ns_vmcb_hostcr3; u32 ns_guest_asid; bool_t ns_hap_enabled; unsigned __CPROVER_bitvector[24] $pad22; struct { unsigned long int exitcode; unsigned long int exitinfo1; unsigned long int exitinfo2; } ns_vmexit; union { u32 bytes; struct { u32 rflagsif : 1; u32 vintrmask : 1; u32 reserved : 30; } fields; } ns_hostflags; u32 $pad25; } nsvm; struct nestedvmx { unsigned long int vmxon_region_pa; const void *iobitmap[2l]; const void *msrbitmap; struct { unsigned long int intr_info; u32 error_code; u8 source; unsigned __CPROVER_bitvector[24] $pad3; } intr; struct { bool_t enabled; unsigned __CPROVER_bitvector[24] $pad1; u32 exit_reason; u32 exit_qual; } ept; u32 guest_vpid; struct list_head { struct list_head *next; struct list_head *prev; } launched_list; } nvmx; } u; bool_t nv_flushp2m; unsigned __CPROVER_bitvector[56] $pad10; struct p2m_domain *nv_p2m; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } nv_n2asid; bool_t nv_vmentry_pending; bool_t nv_vmexit_pending; bool_t nv_vmswitch_in_progress; bool_t nv_ioport80; bool_t nv_ioportED; unsigned __CPROVER_bitvector[24] $pad18; unsigned long int guest_cr[5l]; } nvcpu; struct altp2mvcpu { unsigned short int p2midx; unsigned __CPROVER_bitvector[48] $pad1; unsigned long int veinfo_gfn; } avcpu; struct mtrr_state { struct mtrr_var_range *var_ranges; u8 fixed_ranges[88l]; u8 enabled; u8 have_fixed; u8 def_type; unsigned __CPROVER_bitvector[40] $pad5; unsigned long int mtrr_cap; bool_t overlapped; unsigned __CPROVER_bitvector[56] $pad8; } mtrr; unsigned long int pat_cr; signed long int stime_offset; u8 evtchn_upcall_vector; u8 cache_mode; unsigned __CPROVER_bitvector[48] $pad29; struct hvm_vcpu_io { enum hvm_io_completion io_completion; u32 $pad1; struct ioreq { unsigned long int addr; unsigned long int data; u32 count; u32 size; u32 vp_eport; unsigned short int _pad0; u8 state : 4; u8 data_is_ptr : 1; u8 dir : 1; u8 df : 1; u8 _pad1 : 1; u8 type; } io_req; struct npfec { u32 read_access : 1; u32 write_access : 1; u32 insn_fetch : 1; u32 present : 1; u32 gla_valid : 1; u32 kind : 2; unsigned __CPROVER_bitvector[1] $bit_field_pad6 : 1; unsigned __CPROVER_bitvector[24] $pad7; } mmio_access; u32 $pad4; unsigned long int mmio_gla; unsigned long int mmio_gpfn; struct hvm_mmio_cache mmio_cache[3l]; u32 mmio_cache_count; u32 mmio_insn_bytes; xen_domain_handle_t mmio_insn; bool_t mmio_retry; unsigned __CPROVER_bitvector[56] $pad12; unsigned long int msix_unmask_address; unsigned long int msix_snoop_address; unsigned long int msix_snoop_gpa; const struct g2m_ioport *g2m_ioport; } hvm_io; const void (*fpu_exception_callback)(const void *, struct cpu_user_regs *); const void *fpu_exception_callback_arg; struct hvm_trap { s16 vector; u8 type; u8 insn_len; u32 error_code; unsigned long int cr2; } inject_trap; struct viridian_vcpu { struct { union viridian_apic_assist { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } msr; const void *va; signed int vector; u32 $pad3; } apic_assist; } viridian; } hvm_vcpu; } $anon0; struct { unsigned long int pfn; } guest_table_user; struct { unsigned long int pfn; } guest_table; struct page_info *old_guest_table; pagetable_t shadow_table[4l]; struct { unsigned long int pfn; } monitor_table; unsigned long int cr3; struct xsave_struct *xsave_area; unsigned long int xcr0; unsigned long int xcr0_accum; bool_t nonlazy_xstate_used; bool_t cpuid_faulting; smap_check_policy_t smap_check_policy; unsigned __CPROVER_bitvector[40] $pad23; struct vmce { unsigned long int mcg_cap; unsigned long int mcg_status; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct vmce_bank bank[2l]; } vmce; struct paging_vcpu { const struct paging_mode *mode; const struct paging_mode *nestedmode; u32 last_write_was_pt : 1; u32 last_write_emul_ok : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad4 : 6; unsigned __CPROVER_bitvector[56] $pad5; struct shadow_vtlb *vtlb; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtlb_lock; unsigned __CPROVER_bitvector[192] $pad8; struct shadow_vcpu { l3_pgentry_t l3table[4l]; l3_pgentry_t gl3e[4l]; const void *guest_vtable; unsigned long int last_emulated_mfn_for_unshadow; unsigned long int last_writeable_pte_smfn; unsigned long int last_emulated_frame; unsigned long int last_emulated_mfn; unsigned long int oos[3l]; unsigned long int oos_snapshot[3l]; struct oos_fixup oos_fixup[3l]; bool_t pagetable_dying; unsigned __CPROVER_bitvector[120] $pad11; } shadow; } paging; u32 gdbsx_vcpu_event; u32 $pad27; struct { vcpu_time_info_t *p; } time_info_guest; struct arch_vm_event *vm_event; unsigned long int $pad30; } arch; } *)NULL) (0x0)

State 1008 file grant_table.c line 756 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
signed int handle;
----------------------------------------------------
  handle=0 (0x0)

State 1009 file grant_table.c line 757 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
unsigned long int frame;
----------------------------------------------------
  frame=0ul (0x0)

State 1010 file grant_table.c line 757 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
frame = (unsigned long int)0;
----------------------------------------------------
  frame=0ul (0x0)

State 1011 file grant_table.c line 757 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
unsigned long int nr_gets;
----------------------------------------------------
  nr_gets=0ul (0x0)

State 1012 file grant_table.c line 757 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
nr_gets = (unsigned long int)0;
----------------------------------------------------
  nr_gets=0ul (0x0)

State 1013 file grant_table.c line 758 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
struct page_info *pg;
----------------------------------------------------
  pg=((struct page_info { union { struct page_list_entry { u32 next; u32 prev; } list; unsigned long int up; struct page_sharing_info *sharing; } $anon0; unsigned long int count_info; union { struct { unsigned long int type_info; } inuse; struct { unsigned long int type : 5; unsigned long int pinned : 1; unsigned long int head : 1; unsigned long int count : 25; u32 $pad4; } sh; struct { bool_t need_tlbflush; } free; } u; union { struct { u32 _domain; } inuse; struct { u32 back; } sh; struct { u32 order; } free; } v; union { u32 tlbflush_timestamp; struct { unsigned short int nr_validated_ptes; const char partial_pte; u8 $pad2; } $anon0; u32 shadow_flags; u32 next_shadow; } $anon1; } *)NULL) (0x0)

State 1014 file grant_table.c line 758 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
pg = (struct page_info *)(void *)0;
----------------------------------------------------
  pg=((struct page_info { union { struct page_list_entry { u32 next; u32 prev; } list; unsigned long int up; struct page_sharing_info *sharing; } $anon0; unsigned long int count_info; union { struct { unsigned long int type_info; } inuse; struct { unsigned long int type : 5; unsigned long int pinned : 1; unsigned long int head : 1; unsigned long int count : 25; u32 $pad4; } sh; struct { bool_t need_tlbflush; } free; } u; union { struct { u32 _domain; } inuse; struct { u32 back; } sh; struct { u32 order; } free; } v; union { u32 tlbflush_timestamp; struct { unsigned short int nr_validated_ptes; const char partial_pte; u8 $pad2; } $anon0; u32 shadow_flags; u32 next_shadow; } $anon1; } *)NULL) (0x0)

State 1015 file grant_table.c line 759 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
signed int rc;
----------------------------------------------------
  rc=0 (0x0)

State 1016 file grant_table.c line 759 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
rc = 0;
----------------------------------------------------
  rc=0 (0x0)

State 1017 file grant_table.c line 760 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
u32 old_pin;
----------------------------------------------------
  old_pin=0u (0x0)

State 1018 file grant_table.c line 761 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
u32 act_pin;
----------------------------------------------------
  act_pin=0u (0x0)

State 1019 file grant_table.c line 762 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
unsigned int cache_flags;
----------------------------------------------------
  cache_flags=0u (0x0)

State 1020 file grant_table.c line 763 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
struct active_grant_entry *act;
----------------------------------------------------
  act=((struct active_grant_entry { u32 pin; unsigned short int domid; unsigned short int $pad2; struct domain *trans_domain; u32 trans_gref; u32 $pad5; unsigned long int frame; unsigned long int gfn; u32 is_sub_page : 1; u32 start : 15; u32 length : 16; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 $pad12; } *)NULL) (0x0)

State 1021 file grant_table.c line 763 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
act = (struct active_grant_entry *)(void *)0;
----------------------------------------------------
  act=((struct active_grant_entry { u32 pin; unsigned short int domid; unsigned short int $pad2; struct domain *trans_domain; u32 trans_gref; u32 $pad5; unsigned long int frame; unsigned long int gfn; u32 is_sub_page : 1; u32 start : 15; u32 length : 16; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 $pad12; } *)NULL) (0x0)

State 1022 file grant_table.c line 764 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
struct grant_mapping *mt;
----------------------------------------------------
  mt=((struct grant_mapping { u32 ref; unsigned short int flags; unsigned short int domid; u32 vcpu; u32 pad; } *)NULL) (0x0)

State 1023 file grant_table.c line 765 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
grant_entry_header_t *shah;
----------------------------------------------------
  shah=((struct grant_entry_header { unsigned short int flags; unsigned short int domid; } *)NULL) (0x0)

State 1024 file grant_table.c line 766 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
uint16_t *status;
----------------------------------------------------
  status=((unsigned short int *)NULL) (0x0)

State 1025 file grant_table.c line 767 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
bool_t need_iommu;
----------------------------------------------------
  need_iommu=FALSE (0x0)

#### Function call: get_cpu_info$link6() (depth 5) ####

#### Function return: get_cpu_info$link6 (depth 4) ####

State 1031 file grant_table.c line 769 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
led = return_value_get_cpu_info->current_vcpu;
----------------------------------------------------
  led=((struct vcpu { signed int vcpu_id; signed int processor; vcpu_info_t *vcpu_info; struct domain *domain; struct vcpu *next_in_list; signed long int periodic_period; signed long int periodic_last_event; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } periodic_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } singleshot_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } poll_timer; const void *sched_priv; struct vcpu_runstate_info { signed int state; u32 $pad1; unsigned long int state_entry_time; unsigned long int time[4l]; } runstate; union { struct { vcpu_runstate_info_t *p; } native; struct { vcpu_runstate_info_compat_t *p; } compat; } runstate_guest; unsigned long int last_run_time; bool_t fpu_initialised; bool_t fpu_dirtied; bool_t is_initialised; bool_t is_running; bool_t is_urgent; struct async_exception_state[2l]; u8 async_exception_mask; bool_t defer_shutdown; bool_t paused_for_shutdown; bool_t affinity_broken; unsigned __CPROVER_bitvector[24] $pad24; signed int poll_evtchn; signed int pirq_evtchn_head; unsigned long int pause_flags; struct { signed int counter; } pause_count; struct { signed int counter; } vm_event_pause_count; signed int controller_pause_count; u32 maptrack_head; u32 maptrack_tail; u32 virq_to_evtchn[24l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } virq_lock; u32 $pad35; const cpumask_t *cpu_hard_affinity; const cpumask_t *cpu_hard_affinity_tmp; const cpumask_t *cpu_hard_affinity_saved; const cpumask_t *cpu_soft_affinity; const cpumask_t *vcpu_dirty_cpumask; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } continue_hypercall_tasklet; struct mc_state { unsigned long int flags; union { struct multicall_entry { unsigned long int op; unsigned long int result; unsigned long int args[6l]; } call; struct compat_multicall_entry { u32 op; u32 result; u32 args[6l]; } compat_call; } $anon0; } mc_state; struct waitqueue_vcpu *waitqueue_vcpu; unsigned long int vcpu_info_mfn; struct evtchn_fifo_vcpu *evtchn_fifo; unsigned __CPROVER_bitvector[320] $pad46; struct arch_vcpu { const void *fpu_ctxt; unsigned long int vgc_flags; struct cpu_user_regs { unsigned long int r15; unsigned long int r14; unsigned long int r13; unsigned long int r12; union { unsigned long int rbp; unsigned long int ebp; u32 _ebp; } $anon0; union { unsigned long int rbx; unsigned long int ebx; u32 _ebx; } $anon1; unsigned long int r11; unsigned long int r10; unsigned long int r9; unsigned long int r8; union { unsigned long int rax; unsigned long int eax; u32 _eax; } $anon2; union { unsigned long int rcx; unsigned long int ecx; u32 _ecx; } $anon3; union { unsigned long int rdx; unsigned long int edx; u32 _edx; } $anon4; union { unsigned long int rsi; unsigned long int esi; u32 _esi; } $anon5; union { unsigned long int rdi; unsigned long int edi; u32 _edi; } $anon6; u32 error_code; u32 entry_vector; union { unsigned long int rip; unsigned long int eip; u32 _eip; } $anon7; unsigned short int cs; unsigned short int _pad0[1l]; u8 saved_upcall_mask; u8 _pad1[3l]; union { unsigned long int rflags; unsigned long int eflags; u32 _eflags; } $anon8; union { unsigned long int rsp; unsigned long int esp; u32 _esp; } $anon9; unsigned short int ss; unsigned short int _pad2[3l]; unsigned short int es; unsigned short int _pad3[3l]; unsigned short int ds; unsigned short int _pad4[3l]; unsigned short int fs; unsigned short int _pad5[3l]; unsigned short int gs; unsigned short int _pad6[3l]; } user_regs; unsigned long int debugreg[8l]; unsigned long int flags; const void (*schedule_tail)(struct vcpu *); const void (*ctxt_switch_from)(struct vcpu *); const void (*ctxt_switch_to)(struct vcpu *); struct vpmu_struct { u32 flags; u32 last_pcpu; u32 hw_lapic_lvtpc; u32 $pad3; const void *context; const void *priv_context; struct arch_vpmu_ops *arch_vpmu_ops; struct xen_pmu_data *xenpmu_data; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vpmu_lock; } vpmu; unsigned __int128; union { struct pv_vcpu { struct mapcache_vcpu { u32 shadow_epoch; u32 $pad1; struct vcpu_maphash_entry hash[8l]; } mapcache; struct trap_info *trap_ctxt; unsigned long int gdt_frames[14l]; unsigned long int ldt_base; u32 gdt_ents; u32 ldt_ents; unsigned long int kernel_ss; unsigned long int kernel_sp; unsigned long int ctrlreg[8l]; unsigned long int event_callback_eip; unsigned long int failsafe_callback_eip; union { unsigned long int syscall_callback_eip; struct { u32 event_callback_cs; u32 failsafe_callback_cs; } $anon0; } $anon0; unsigned long int syscall32_callback_eip; unsigned long int sysenter_callback_eip; unsigned short int syscall32_callback_cs; unsigned short int sysenter_callback_cs; bool_t syscall32_disables_events; bool_t sysenter_disables_events; unsigned short int $pad18; unsigned long int fs_base; unsigned long int gs_base_kernel; unsigned long int gs_base_user; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } trap_bounce; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } int80_bounce; struct { u8 *p; } iobmp; u32 iobmp_limit; u32 iopl; unsigned long int shadow_ldt_mapcnt; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shadow_ldt_lock; u32 dr_mask[4l]; bool_t need_update_runstate_area; unsigned __CPROVER_bitvector[56] $pad31; struct vcpu_time_info { u32 version; u32 pad0; unsigned long int tsc_timestamp; unsigned long int system_time; u32 tsc_to_system_mul; const char tsc_shift; u8 flags; u8 pad1[2l]; } pending_system_time; } pv_vcpu; struct hvm_vcpu { unsigned long int guest_cr[5l]; unsigned long int guest_efer; unsigned long int hw_cr[5l]; struct vlapic { struct hvm_hw_lapic { unsigned long int apic_base_msr; u32 disabled; u32 timer_divisor; unsigned long int tdt_msr; } hw; struct hvm_hw_lapic_regs *regs; struct { bool_t hw; bool_t regs; unsigned short int $pad2; u32 id; u32 ldr; } loaded; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } esr_lock; u32 $pad4; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt; signed long int timer_last_update; struct page_info *regs_page; struct { u32 icr; u32 dest; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } tasklet; } init_sipi; } vlapic; signed long int cache_tsc_offset; unsigned long int guest_time; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } tm_lock; struct list_head { struct list_head *next; struct list_head *prev; } tm_list; u8 flag_dr_dirty; bool_t debug_state_latch; bool_t single_step; bool_t hcall_preempted; bool_t hcall_64bit; unsigned __CPROVER_bitvector[24] $pad13; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } n1asid; u32 msr_tsc_aux; u32 $pad16; unsigned long int msr_tsc_adjust; unsigned long int msr_xss; unsigned __CPROVER_bitvector[192] $pad19; union { struct arch_vmx_struct { unsigned long int vmcs_pa; unsigned long int vmcs_shadow_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vmcs_lock; struct list_head { struct list_head *next; struct list_head *prev; } active_list; signed int active_cpu; signed int launched; u32 exec_control; u32 secondary_exec_control; u32 exception_bitmap; u32 $pad9; struct vmx_msr_state { unsigned long int flags; unsigned long int msrs[3l]; } msr_state; unsigned long int shadow_gs; unsigned long int cstar; unsigned long int *msr_bitmap; u32 msr_count; u32 $pad15; struct vmx_msr_entry *msr_area; u32 host_msr_count; u32 $pad18; struct vmx_msr_entry *host_msr_area; unsigned long int eoi_exitmap_changed; unsigned long int eoi_exit_bitmap[4l]; struct pi_desc { unsigned long int pir[4l]; union { struct { unsigned short int on : 1; unsigned short int sn : 1; unsigned short int rsvd_1 : 14; u8 nv; u8 rsvd_2; u32 ndst; } $anon0; unsigned long int control; } $anon0; u32 rsvd[6l]; } pi_desc; unsigned long int host_cr0; bool_t ept_spurious_misconfig; u8 vmx_realmode; u8 vmx_emulate; u8 $pad27; unsigned short int vm86_segment_mask; struct segment_register vm86_saved_seg[7l]; unsigned short int $pad30; u32 vm86_saved_eflags; signed int hostenv_migrated; struct page_info *vmread_bitmap; struct page_info *vmwrite_bitmap; struct page_info *pml_pg; struct pi_blocking_vcpu { struct list_head { struct list_head *next; struct list_head *prev; } list; spinlock_t *lock; } pi_blocking; unsigned long int $pad37; } vmx; struct arch_svm_struct { struct vmcb_struct *vmcb; unsigned long int vmcb_pa; unsigned long int *msrpm; signed int launch_core; bool_t vmcb_in_sync; u8 cached_insn_len; unsigned short int $pad6; unsigned long int guest_sysenter_cs; unsigned long int guest_sysenter_esp; unsigned long int guest_sysenter_eip; unsigned long int guest_lwp_cfg; unsigned long int cpu_lwp_cfg; u32 dr_mask[4l]; struct { unsigned long int length; unsigned long int status; } osvw; } svm; } u; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } assert_evtchn_irq_tasklet; struct nestedvcpu { bool_t nv_guestmode; unsigned __CPROVER_bitvector[56] $pad1; const void *nv_vvmcx; const void *nv_n1vmcx; const void *nv_n2vmcx; unsigned long int nv_vvmcxaddr; unsigned long int nv_n1vmcx_pa; unsigned long int nv_n2vmcx_pa; union { struct nestedsvm { bool_t ns_gif; unsigned __CPROVER_bitvector[56] $pad1; unsigned long int ns_msr_hsavepa; unsigned long int ns_ovvmcb_pa; unsigned long int ns_tscratio; u32 ns_cr_intercepts; u32 ns_dr_intercepts; u32 ns_exception_intercepts; u32 ns_general1_intercepts; u32 ns_general2_intercepts; union { unsigned long int bytes; struct { unsigned long int enable : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad1 : 7; unsigned __CPROVER_bitvector[56] $pad2; } fields; } ns_lbr_control; u32 $pad11; unsigned long int *ns_cached_msrpm; unsigned long int *ns_merged_msrpm; unsigned long int ns_iomap_pa; unsigned long int ns_oiomap_pa; unsigned long int *ns_iomap; unsigned long int ns_cr0; unsigned long int ns_vmcb_guestcr3; unsigned long int ns_vmcb_hostcr3; u32 ns_guest_asid; bool_t ns_hap_enabled; unsigned __CPROVER_bitvector[24] $pad22; struct { unsigned long int exitcode; unsigned long int exitinfo1; unsigned long int exitinfo2; } ns_vmexit; union { u32 bytes; struct { u32 rflagsif : 1; u32 vintrmask : 1; u32 reserved : 30; } fields; } ns_hostflags; u32 $pad25; } nsvm; struct nestedvmx { unsigned long int vmxon_region_pa; const void *iobitmap[2l]; const void *msrbitmap; struct { unsigned long int intr_info; u32 error_code; u8 source; unsigned __CPROVER_bitvector[24] $pad3; } intr; struct { bool_t enabled; unsigned __CPROVER_bitvector[24] $pad1; u32 exit_reason; u32 exit_qual; } ept; u32 guest_vpid; struct list_head { struct list_head *next; struct list_head *prev; } launched_list; } nvmx; } u; bool_t nv_flushp2m; unsigned __CPROVER_bitvector[56] $pad10; struct p2m_domain *nv_p2m; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } nv_n2asid; bool_t nv_vmentry_pending; bool_t nv_vmexit_pending; bool_t nv_vmswitch_in_progress; bool_t nv_ioport80; bool_t nv_ioportED; unsigned __CPROVER_bitvector[24] $pad18; unsigned long int guest_cr[5l]; } nvcpu; struct altp2mvcpu { unsigned short int p2midx; unsigned __CPROVER_bitvector[48] $pad1; unsigned long int veinfo_gfn; } avcpu; struct mtrr_state { struct mtrr_var_range *var_ranges; u8 fixed_ranges[88l]; u8 enabled; u8 have_fixed; u8 def_type; unsigned __CPROVER_bitvector[40] $pad5; unsigned long int mtrr_cap; bool_t overlapped; unsigned __CPROVER_bitvector[56] $pad8; } mtrr; unsigned long int pat_cr; signed long int stime_offset; u8 evtchn_upcall_vector; u8 cache_mode; unsigned __CPROVER_bitvector[48] $pad29; struct hvm_vcpu_io { enum hvm_io_completion io_completion; u32 $pad1; struct ioreq { unsigned long int addr; unsigned long int data; u32 count; u32 size; u32 vp_eport; unsigned short int _pad0; u8 state : 4; u8 data_is_ptr : 1; u8 dir : 1; u8 df : 1; u8 _pad1 : 1; u8 type; } io_req; struct npfec { u32 read_access : 1; u32 write_access : 1; u32 insn_fetch : 1; u32 present : 1; u32 gla_valid : 1; u32 kind : 2; unsigned __CPROVER_bitvector[1] $bit_field_pad6 : 1; unsigned __CPROVER_bitvector[24] $pad7; } mmio_access; u32 $pad4; unsigned long int mmio_gla; unsigned long int mmio_gpfn; struct hvm_mmio_cache mmio_cache[3l]; u32 mmio_cache_count; u32 mmio_insn_bytes; xen_domain_handle_t mmio_insn; bool_t mmio_retry; unsigned __CPROVER_bitvector[56] $pad12; unsigned long int msix_unmask_address; unsigned long int msix_snoop_address; unsigned long int msix_snoop_gpa; const struct g2m_ioport *g2m_ioport; } hvm_io; const void (*fpu_exception_callback)(const void *, struct cpu_user_regs *); const void *fpu_exception_callback_arg; struct hvm_trap { s16 vector; u8 type; u8 insn_len; u32 error_code; unsigned long int cr2; } inject_trap; struct viridian_vcpu { struct { union viridian_apic_assist { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } msr; const void *va; signed int vector; u32 $pad3; } apic_assist; } viridian; } hvm_vcpu; } $anon0; struct { unsigned long int pfn; } guest_table_user; struct { unsigned long int pfn; } guest_table; struct page_info *old_guest_table; pagetable_t shadow_table[4l]; struct { unsigned long int pfn; } monitor_table; unsigned long int cr3; struct xsave_struct *xsave_area; unsigned long int xcr0; unsigned long int xcr0_accum; bool_t nonlazy_xstate_used; bool_t cpuid_faulting; smap_check_policy_t smap_check_policy; unsigned __CPROVER_bitvector[40] $pad23; struct vmce { unsigned long int mcg_cap; unsigned long int mcg_status; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct vmce_bank bank[2l]; } vmce; struct paging_vcpu { const struct paging_mode *mode; const struct paging_mode *nestedmode; u32 last_write_was_pt : 1; u32 last_write_emul_ok : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad4 : 6; unsigned __CPROVER_bitvector[56] $pad5; struct shadow_vtlb *vtlb; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtlb_lock; unsigned __CPROVER_bitvector[192] $pad8; struct shadow_vcpu { l3_pgentry_t l3table[4l]; l3_pgentry_t gl3e[4l]; const void *guest_vtable; unsigned long int last_emulated_mfn_for_unshadow; unsigned long int last_writeable_pte_smfn; unsigned long int last_emulated_frame; unsigned long int last_emulated_mfn; unsigned long int oos[3l]; unsigned long int oos_snapshot[3l]; struct oos_fixup oos_fixup[3l]; bool_t pagetable_dying; unsigned __CPROVER_bitvector[120] $pad11; } shadow; } paging; u32 gdbsx_vcpu_event; u32 $pad27; struct { vcpu_time_info_t *p; } time_info_guest; struct arch_vm_event *vm_event; unsigned long int $pad30; } arch; } *)NULL) (0x0)

State 1032 file grant_table.c line 770 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
ld = led->domain;
----------------------------------------------------
  ld=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

#### Function call: rcu_lock_domain_by_id(0) (depth 5) ####

#### Function return: rcu_lock_domain_by_id (depth 4) ####

State 1041 file grant_table.c line 788 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
rd = NONDET(struct domain *);
----------------------------------------------------
  rd=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) + 1l (0x1)

#### Function call: xsm_grant_mapref(/*enum*/XSM_HOOK, ((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL), ((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) + 1l, 22u) (depth 5) ####

#### Function return: xsm_grant_mapref (depth 4) ####

State 1046 file grant_table.c line 795 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
xsm_grant_mapref((xsm_default_t)0, ld, rd, op->flags);
----------------------------------------------------
  ld$object={ .domain_id=0, .$pad1=0, .max_vcpus=0u, .vcpu=((struct vcpu **)NULL),
    .shared_info=((shared_info_t *)NULL), .domain_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .page_alloc_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .page_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .xenpage_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .tot_pages=0u,
    .xenheap_pages=0u, .outstanding_pages=0u, .max_pages=0u,
    .shr_pages={ .counter=0 }, .paged_pages={ .counter=0 },
    .sched_priv=NULL, .cpupool=((struct cpupool *)NULL),
    .next_in_list=((struct domain *)NULL), .next_in_hashbucket=((struct domain *)NULL),
    .rangesets={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) },
    .rangesets_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .evtchn=((struct evtchn *)NULL),
    .evtchn_group={ ((struct evtchn **)NULL), ((struct evtchn **)NULL), ((struct evtchn **)NULL), ((struct evtchn **)NULL) }, .max_evtchns=0u,
    .max_evtchn_port=0u, .valid_evtchns=0u,
    .event_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .$pad27=0u,
    .evtchn_port_ops=((const struct evtchn_port_ops *)NULL), .evtchn_fifo=((struct evtchn_fifo_domain *)NULL),
    .grant_table=((struct grant_table *)NULL),
    .pirq_tree={ .height=0u, .$pad1=0u, .rnode=((struct radix_tree_node *)NULL), .node_alloc=((radix_tree_alloc_fn_t (*))NULL),
    .node_free=((radix_tree_free_fn_t (*))NULL),
    .node_alloc_free_arg=NULL },
    .nr_pirqs=0u,
    .guest_type=/*enum*/guest_type_pv, .is_dying=/*enum*/DOMDYING_alive,
    .controller_pause_count=0, .time_offset_seconds=0l,
    .iommu={ .arch={ .pgd_maddr=0ul, .mapping_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .agaw=0,
    .$pad3=0u, .g2m_ioport_list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .iommu_bitmap=0ul,
    .mapped_rmrrs={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .paging_mode=0,
    .$pad8=0u, .root_table=((struct page_info *)NULL), .g_iommu=((struct guest_iommu *)NULL) }, .platform_ops=((const struct iommu_ops *)NULL),
    .features={ 0ul } }, .need_iommu=0,
    .auto_node_affinity=FALSE, .is_privileged=FALSE,
    .is_xenstore=FALSE, .is_pinned=FALSE,
    .disable_migrate=FALSE, .debugger_attached=FALSE,
    .creation_finished=FALSE, .target=((struct domain *)NULL),
    .poll_mask=((unsigned long int *)NULL), .iomem_caps=((struct rangeset *)NULL),
    .irq_caps=((struct rangeset *)NULL),
    .shutdown_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .is_shutting_down=FALSE,
    .is_shut_down=FALSE, .$pad53=0,
    .shutdown_code=0u, .suspend_evtchn=0u, .pause_count={ .counter=0 },
    .refcnt={ .counter=0 }, .$pad58=0u,
    .vm_assist=0ul, .domain_dirty_cpumask=((const cpumask_t *)NULL), .$pad61=0,
    .arch={ .perdomain_l3_pg=((struct page_info *)NULL), .hv_compat_vstart=0u,
    .physaddr_bitsize=0u, .ioport_caps=((struct rangeset *)NULL),
    .pci_cf8=0u,
    .cmos_idx=0, .s3_integrity=FALSE, .$pad7=0,
    .pdev_list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .$anon0={ .pv_domain={ .gdt_ldt_l1tab=((l1_pgentry_t **)NULL), .nr_l4_pages={ .counter=0 },
    .$pad2=0u, .mapcache={ .entries=0u, .cursor=0u, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .epoch=0u,
    .tlbflush_timestamp=0u, .inuse=((unsigned long int *)NULL), .garbage=((unsigned long int *)NULL) },
    .cpuidmasks=((struct cpuidmasks *)NULL) } },
    .paging={ .lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) }, .mode=16384u,
    .p2m_alloc_failed=FALSE, .$pad3=0,
    .shadow={ .opt_flags=0u, .$pad1=0u, .pinned_shadows={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .freelist={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .total_pages=0u,
    .free_pages=0u, .p2m_pages=0u, .$pad7=0u,
    .unpaged_pagetable={ .pfn=0ul }, .gtable_dirty_version={ .counter=0 },
    .$pad10=0u,
    .hash_table=((struct page_info **)NULL), .hash_walking=FALSE,
    .has_fast_mmio_entries=FALSE, .oos_active=FALSE,
    .oos_off=FALSE, .pagetable_dying_op=FALSE, .$pad17=0 }, .hap={ .freelist={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .total_pages=0u,
    .free_pages=0u, .p2m_pages=0u, .$pad4=0u },
    .log_dirty={ .top=0ul, .allocs=0u, .failed_allocs=0u, .fault_count=0u,
    .dirty_count=0u, .enable_log_dirty=((signed int (*)(struct domain *, bool_t))NULL), .disable_log_dirty=((signed int (*)(struct domain *))NULL),
    .clean_dirty_bitmap=((const void (*)(struct domain *))NULL) },
    .gfn_bits=0u,
    .$pad8=0u, .preempt={ .dom=((struct domain *)NULL), .op=0u, .$pad2=0u, .$anon0={ .log_dirty={ .done=0ul, .i4=0ul, .i3=0ul, .$bit_field_pad3=0 } } }, .alloc_page=((struct page_info * (*)(struct domain *))NULL),
    .free_page=((const void (*)(struct domain *, struct page_info *))NULL) },
    .p2m=((struct p2m_domain *)NULL),
    .page_alloc_unlock_level=0, .relmem=/*enum*/RELMEM_not_started,
    .relmem_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .nested_p2m={ ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL) },
    .nested_p2m_lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) },
    .altp2m_active=FALSE,
    .$pad18=0, .altp2m_p2m={ ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL) }, .altp2m_list_lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) },
    .altp2m_eptp=((unsigned long int *)NULL),
    .irq_pirq={ .height=0u, .$pad1=0u, .rnode=((struct radix_tree_node *)NULL), .node_alloc=((radix_tree_alloc_fn_t (*))NULL),
    .node_free=((radix_tree_free_fn_t (*))NULL),
    .node_alloc_free_arg=NULL },
    .is_32bit_pv=FALSE,
    .has_32bit_shinfo=FALSE, .suppress_spurious_page_faults=FALSE,
    .auto_unmask=FALSE,
    .x86=0, .x86_vendor=0, .x86_model=0,
    .x87_fip_width=0, .cpuids=((cpuid_input_t *)NULL), .vpit={ .hw={ .channels={ , ,  }, .speaker_data_on=0u, .pad0=0u }, .count_load_time={ 0l, 0l, 0l },
    .pt0={ .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .on_list=FALSE,
    .one_shot=FALSE, .do_not_freeze=FALSE, .irq_issued=FALSE,
    .warned_timeout_too_short=FALSE, .source=0,
    .irq=0, .$pad8=0, .vcpu=((struct vcpu *)NULL), .pending_intr_nr=0u,
    .$pad11=0u, .period=0ul, .scheduled=0l,
    .last_plt_gtime=0ul, .timer={ .expires=0l, .$anon0={ .heap_offset=0u }, .function=((const void (*)(const void *))NULL),
    .data=NULL,
    .cpu=0, .status=0, .$pad6=0 }, .cb=((time_cb (*))NULL),
    .priv=NULL }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } },
    .tsc_mode=0,
    .vtsc=FALSE, .$pad35=0, .vtsc_last=0l,
    .vtsc_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .vtsc_offset=0ul,
    .tsc_khz=0u, .vtsc_to_ns={ .shift=0, .mul_frac=0u }, .ns_to_vtsc={ .shift=0, .mul_frac=0u },
    .incarnation=0u,
    .e820_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .e820=((struct e820entry *)NULL),
    .nr_e820=0u, .psr_rmid=0u,
    .psr_cos_ids=((u32 *)NULL), .pirq_eoi_map=((unsigned long int *)NULL),
    .pirq_eoi_map_mfn=0ul,
    .monitor={ .write_ctrlreg_enabled=0u, .write_ctrlreg_sync=0u, .write_ctrlreg_onchangeonly=0u,
    .singlestep_enabled=0u, .software_breakpoint_enabled=0u,
    .debug_exception_enabled=0u, .debug_exception_sync=0u,
    .cpuid_enabled=0u, .$bit_field_pad8=0,
    .$pad9=0, .msr_bitmap=((struct monitor_msr_bitmap *)NULL) }, .mem_access_emulate_each_rep=FALSE,
    .$pad52=0, .emulation_flags=0u,
    .$pad54=0 }, .ssid=NULL,
    .handle={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .pbuf=((const char *)NULL),
    .pbuf_idx=0u, .pbuf_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .$pad68=0u,
    .xenoprof=((struct xenoprof *)NULL), .watchdog_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .watchdog_inuse_map=0u,
    .$pad72=0u, .watchdog_timer={ ,  }, .rcu={ .next=((struct rcu_head *)NULL), .func=((const void (*)(struct rcu_head *))NULL) },
    .hypercall_deadlock_mutex={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .tmem_client=((struct client *)NULL),
    .profile_head=irep("(\"nil\")"),
    .vm_event=((struct vm_event_per_domain *)NULL), .node_affinity={ .bits={ 0ul } },
    .last_alloc_node=0u, .node_affinity_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .vnuma_rwlock={ .cnts={ .counter=0 }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } },
    .vnuma=((struct vnuma_info *)NULL),
    .monitor={ .guest_request_enabled=0u, .guest_request_sync=0u, .$bit_field_pad2=0,
    .$pad3=0 }, .$pad85=0u } ({ 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, { { 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0 }, 0x0, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0, { 0x0 } }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, { 0x0 }, 0x0, { 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0 }, { { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x4000, 0x0, 0x0, { 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0 } }, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { { { ?, ?, ? }, 0x0, 0x0 }, { 0x0, 0x0, 0x0 }, { { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { ?, ? }, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, ?, 0x0, { { 0x0 } }, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, { { 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, { 0x0, 0x0, 0x0, 0x0 }, 0x0 })

State 1047 file grant_table.c line 795 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
xsm_grant_mapref((xsm_default_t)0, ld, rd, op->flags);
----------------------------------------------------
  rd$object={ .domain_id=0, .$pad1=0, .max_vcpus=0u, .vcpu=((struct vcpu **)NULL),
    .shared_info=((shared_info_t *)NULL), .domain_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .page_alloc_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .page_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .xenpage_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .tot_pages=0u,
    .xenheap_pages=0u, .outstanding_pages=0u, .max_pages=0u,
    .shr_pages={ .counter=0 }, .paged_pages={ .counter=0 },
    .sched_priv=NULL, .cpupool=((struct cpupool *)NULL),
    .next_in_list=((struct domain *)NULL), .next_in_hashbucket=((struct domain *)NULL),
    .rangesets={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) },
    .rangesets_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .evtchn=((struct evtchn *)NULL),
    .evtchn_group={ ((struct evtchn **)NULL), ((struct evtchn **)NULL), ((struct evtchn **)NULL), ((struct evtchn **)NULL) }, .max_evtchns=0u,
    .max_evtchn_port=0u, .valid_evtchns=0u,
    .event_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .$pad27=0u,
    .evtchn_port_ops=((const struct evtchn_port_ops *)NULL), .evtchn_fifo=((struct evtchn_fifo_domain *)NULL),
    .grant_table=((struct grant_table *)NULL),
    .pirq_tree={ .height=0u, .$pad1=0u, .rnode=((struct radix_tree_node *)NULL), .node_alloc=((radix_tree_alloc_fn_t (*))NULL),
    .node_free=((radix_tree_free_fn_t (*))NULL),
    .node_alloc_free_arg=NULL },
    .nr_pirqs=0u,
    .guest_type=/*enum*/guest_type_pv, .is_dying=/*enum*/DOMDYING_alive,
    .controller_pause_count=0, .time_offset_seconds=0l,
    .iommu={ .arch={ .pgd_maddr=0ul, .mapping_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .agaw=0,
    .$pad3=0u, .g2m_ioport_list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .iommu_bitmap=0ul,
    .mapped_rmrrs={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .paging_mode=0,
    .$pad8=0u, .root_table=((struct page_info *)NULL), .g_iommu=((struct guest_iommu *)NULL) }, .platform_ops=((const struct iommu_ops *)NULL),
    .features={ 0ul } }, .need_iommu=0,
    .auto_node_affinity=FALSE, .is_privileged=FALSE,
    .is_xenstore=FALSE, .is_pinned=FALSE,
    .disable_migrate=FALSE, .debugger_attached=FALSE,
    .creation_finished=FALSE, .target=((struct domain *)NULL),
    .poll_mask=((unsigned long int *)NULL), .iomem_caps=((struct rangeset *)NULL),
    .irq_caps=((struct rangeset *)NULL),
    .shutdown_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .is_shutting_down=FALSE,
    .is_shut_down=FALSE, .$pad53=0,
    .shutdown_code=0u, .suspend_evtchn=0u, .pause_count={ .counter=0 },
    .refcnt={ .counter=0 }, .$pad58=0u,
    .vm_assist=0ul, .domain_dirty_cpumask=((const cpumask_t *)NULL), .$pad61=0,
    .arch={ .perdomain_l3_pg=((struct page_info *)NULL), .hv_compat_vstart=0u,
    .physaddr_bitsize=0u, .ioport_caps=((struct rangeset *)NULL),
    .pci_cf8=0u,
    .cmos_idx=0, .s3_integrity=FALSE, .$pad7=0,
    .pdev_list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .$anon0={ .pv_domain={ .gdt_ldt_l1tab=((l1_pgentry_t **)NULL), .nr_l4_pages={ .counter=0 },
    .$pad2=0u, .mapcache={ .entries=0u, .cursor=0u, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .epoch=0u,
    .tlbflush_timestamp=0u, .inuse=((unsigned long int *)NULL), .garbage=((unsigned long int *)NULL) },
    .cpuidmasks=((struct cpuidmasks *)NULL) } },
    .paging={ .lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) }, .mode=16384u,
    .p2m_alloc_failed=FALSE, .$pad3=0,
    .shadow={ .opt_flags=0u, .$pad1=0u, .pinned_shadows={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .freelist={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .total_pages=0u,
    .free_pages=0u, .p2m_pages=0u, .$pad7=0u,
    .unpaged_pagetable={ .pfn=0ul }, .gtable_dirty_version={ .counter=0 },
    .$pad10=0u,
    .hash_table=((struct page_info **)NULL), .hash_walking=FALSE,
    .has_fast_mmio_entries=FALSE, .oos_active=FALSE,
    .oos_off=FALSE, .pagetable_dying_op=FALSE, .$pad17=0 }, .hap={ .freelist={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .total_pages=0u,
    .free_pages=0u, .p2m_pages=0u, .$pad4=0u },
    .log_dirty={ .top=0ul, .allocs=0u, .failed_allocs=0u, .fault_count=0u,
    .dirty_count=0u, .enable_log_dirty=((signed int (*)(struct domain *, bool_t))NULL), .disable_log_dirty=((signed int (*)(struct domain *))NULL),
    .clean_dirty_bitmap=((const void (*)(struct domain *))NULL) },
    .gfn_bits=0u,
    .$pad8=0u, .preempt={ .dom=((struct domain *)NULL), .op=0u, .$pad2=0u, .$anon0={ .log_dirty={ .done=0ul, .i4=0ul, .i3=0ul, .$bit_field_pad3=0 } } }, .alloc_page=((struct page_info * (*)(struct domain *))NULL),
    .free_page=((const void (*)(struct domain *, struct page_info *))NULL) },
    .p2m=((struct p2m_domain *)NULL),
    .page_alloc_unlock_level=0, .relmem=/*enum*/RELMEM_not_started,
    .relmem_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .nested_p2m={ ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL) },
    .nested_p2m_lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) },
    .altp2m_active=FALSE,
    .$pad18=0, .altp2m_p2m={ ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL) }, .altp2m_list_lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) },
    .altp2m_eptp=((unsigned long int *)NULL),
    .irq_pirq={ .height=0u, .$pad1=0u, .rnode=((struct radix_tree_node *)NULL), .node_alloc=((radix_tree_alloc_fn_t (*))NULL),
    .node_free=((radix_tree_free_fn_t (*))NULL),
    .node_alloc_free_arg=NULL },
    .is_32bit_pv=FALSE,
    .has_32bit_shinfo=FALSE, .suppress_spurious_page_faults=FALSE,
    .auto_unmask=FALSE,
    .x86=0, .x86_vendor=0, .x86_model=0,
    .x87_fip_width=0, .cpuids=((cpuid_input_t *)NULL), .vpit={ .hw={ .channels={ , ,  }, .speaker_data_on=0u, .pad0=0u }, .count_load_time={ 0l, 0l, 0l },
    .pt0={ .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .on_list=FALSE,
    .one_shot=FALSE, .do_not_freeze=FALSE, .irq_issued=FALSE,
    .warned_timeout_too_short=FALSE, .source=0,
    .irq=0, .$pad8=0, .vcpu=((struct vcpu *)NULL), .pending_intr_nr=0u,
    .$pad11=0u, .period=0ul, .scheduled=0l,
    .last_plt_gtime=0ul, .timer={ .expires=0l, .$anon0={ .heap_offset=0u }, .function=((const void (*)(const void *))NULL),
    .data=NULL,
    .cpu=0, .status=0, .$pad6=0 }, .cb=((time_cb (*))NULL),
    .priv=NULL }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } },
    .tsc_mode=0,
    .vtsc=FALSE, .$pad35=0, .vtsc_last=0l,
    .vtsc_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .vtsc_offset=0ul,
    .tsc_khz=0u, .vtsc_to_ns={ .shift=0, .mul_frac=0u }, .ns_to_vtsc={ .shift=0, .mul_frac=0u },
    .incarnation=0u,
    .e820_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .e820=((struct e820entry *)NULL),
    .nr_e820=0u, .psr_rmid=0u,
    .psr_cos_ids=((u32 *)NULL), .pirq_eoi_map=((unsigned long int *)NULL),
    .pirq_eoi_map_mfn=0ul,
    .monitor={ .write_ctrlreg_enabled=0u, .write_ctrlreg_sync=0u, .write_ctrlreg_onchangeonly=0u,
    .singlestep_enabled=0u, .software_breakpoint_enabled=0u,
    .debug_exception_enabled=0u, .debug_exception_sync=0u,
    .cpuid_enabled=0u, .$bit_field_pad8=0,
    .$pad9=0, .msr_bitmap=((struct monitor_msr_bitmap *)NULL) }, .mem_access_emulate_each_rep=FALSE,
    .$pad52=0, .emulation_flags=0u,
    .$pad54=0 }, .ssid=NULL,
    .handle={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .pbuf=((const char *)NULL),
    .pbuf_idx=0u, .pbuf_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .$pad68=0u,
    .xenoprof=((struct xenoprof *)NULL), .watchdog_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .watchdog_inuse_map=0u,
    .$pad72=0u, .watchdog_timer={ ,  }, .rcu={ .next=((struct rcu_head *)NULL), .func=((const void (*)(struct rcu_head *))NULL) },
    .hypercall_deadlock_mutex={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .tmem_client=((struct client *)NULL),
    .profile_head=irep("(\"nil\")"),
    .vm_event=((struct vm_event_per_domain *)NULL), .node_affinity={ .bits={ 0ul } },
    .last_alloc_node=0u, .node_affinity_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .vnuma_rwlock={ .cnts={ .counter=0 }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } },
    .vnuma=((struct vnuma_info *)NULL),
    .monitor={ .guest_request_enabled=0u, .guest_request_sync=0u, .$bit_field_pad2=0,
    .$pad3=0 }, .$pad85=0u } ({ 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, { { 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0 }, 0x0, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0, { 0x0 } }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, { 0x0 }, 0x0, { 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0 }, { { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x4000, 0x0, 0x0, { 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0 } }, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { { { ?, ?, ? }, 0x0, 0x0 }, { 0x0, 0x0, 0x0 }, { { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { ?, ? }, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, ?, 0x0, { { 0x0 } }, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, { { 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, { 0x0, 0x0, 0x0, 0x0 }, 0x0 })

State 1048 file grant_table.c line 795 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
rc = NONDET(signed int);
----------------------------------------------------
  rc=0 (0x0)

State 1050 file grant_table.c line 803 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
lgt = ld->grant_table;
----------------------------------------------------
  lgt=((struct grant_table { struct percpu_rwlock { struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } rwlock; bool_t writer_activating; unsigned __CPROVER_bitvector[24] $pad2; } lock; u32 nr_grant_frames; u32 $pad2; union { const void **shared_raw; struct grant_entry_v1 **shared_v1; union grant_entry_v2 **shared_v2; } $anon0; u32 nr_status_frames; u32 $pad5; unsigned short int **status; struct active_grant_entry **active; struct grant_mapping **maptrack; u32 maptrack_limit; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } maptrack_lock; u32 gt_version; } *)NULL) (0x0)

#### Function call: get_maptrack_handle(((struct grant_table { struct percpu_rwlock { struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } rwlock; bool_t writer_activating; unsigned __CPROVER_bitvector[24] $pad2; } lock; u32 nr_grant_frames; u32 $pad2; union { const void **shared_raw; struct grant_entry_v1 **shared_v1; union grant_entry_v2 **shared_v2; } $anon0; u32 nr_status_frames; u32 $pad5; unsigned short int **status; struct active_grant_entry **active; struct grant_mapping **maptrack; u32 maptrack_limit; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } maptrack_lock; u32 gt_version; } *)NULL)) (depth 5) ####

#### Function return: get_maptrack_handle (depth 4) ####

State 1054 file grant_table.c line 804 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
get_maptrack_handle(lgt);
----------------------------------------------------
  lgt$object={ .lock={ .rwlock={ .cnts={ .counter=0 }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } }, .writer_activating=FALSE,
    .$pad2=0 }, .nr_grant_frames=0u,
    .$pad2=0u, .$anon0={ .shared_raw=((const void **)NULL) }, .nr_status_frames=0u,
    .$pad5=0u, .status=((unsigned short int **)NULL), .active=((struct active_grant_entry **)NULL),
    .maptrack=((struct grant_mapping **)NULL),
    .maptrack_limit=0u,
    .maptrack_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .gt_version=0u } ({ { { { 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0 })

State 1055 file grant_table.c line 804 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
handle = NONDET(signed int);
----------------------------------------------------
  handle=0 (0x0)

State 1057 file grant_table.c line 812 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
rgt = rd->grant_table;
----------------------------------------------------
  rgt=((struct grant_table { struct percpu_rwlock { struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } rwlock; bool_t writer_activating; unsigned __CPROVER_bitvector[24] $pad2; } lock; u32 nr_grant_frames; u32 $pad2; union { const void **shared_raw; struct grant_entry_v1 **shared_v1; union grant_entry_v2 **shared_v2; } $anon0; u32 nr_status_frames; u32 $pad5; unsigned short int **status; struct active_grant_entry **active; struct grant_mapping **maptrack; u32 maptrack_limit; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } maptrack_lock; u32 gt_version; } *)NULL) (0x0)

#### Function call: grant_read_lock(((struct grant_table { struct percpu_rwlock { struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } rwlock; bool_t writer_activating; unsigned __CPROVER_bitvector[24] $pad2; } lock; u32 nr_grant_frames; u32 $pad2; union { const void **shared_raw; struct grant_entry_v1 **shared_v1; union grant_entry_v2 **shared_v2; } $anon0; u32 nr_status_frames; u32 $pad5; unsigned short int **status; struct active_grant_entry **active; struct grant_mapping **maptrack; u32 maptrack_limit; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } maptrack_lock; u32 gt_version; } *)NULL)) (depth 5) ####

#### Function return: grant_read_lock (depth 4) ####

State 1061 file grant_table.c line 813 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
grant_read_lock(rgt);
----------------------------------------------------
  rgt$object={ .lock={ .rwlock={ .cnts={ .counter=0 }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } }, .writer_activating=FALSE,
    .$pad2=0 }, .nr_grant_frames=0u,
    .$pad2=0u, .$anon0={ .shared_raw=((const void **)NULL) }, .nr_status_frames=0u,
    .$pad5=0u, .status=((unsigned short int **)NULL), .active=((struct active_grant_entry **)NULL),
    .maptrack=((struct grant_mapping **)NULL),
    .maptrack_limit=0u,
    .maptrack_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .gt_version=0u } ({ { { { 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0 })

#### Function call: nr_grant_entries(((struct grant_table { struct percpu_rwlock { struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } rwlock; bool_t writer_activating; unsigned __CPROVER_bitvector[24] $pad2; } lock; u32 nr_grant_frames; u32 $pad2; union { const void **shared_raw; struct grant_entry_v1 **shared_v1; union grant_entry_v2 **shared_v2; } $anon0; u32 nr_status_frames; u32 $pad5; unsigned short int **status; struct active_grant_entry **active; struct grant_mapping **maptrack; u32 maptrack_limit; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } maptrack_lock; u32 gt_version; } *)NULL)) (depth 5) ####

#### Function return: nr_grant_entries (depth 4) ####

State 1066 file grant_table.c line 816 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
nr_grant_entries(rgt);
----------------------------------------------------
  rgt$object={ .lock={ .rwlock={ .cnts={ .counter=0 }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } }, .writer_activating=FALSE,
    .$pad2=0 }, .nr_grant_frames=0u,
    .$pad2=0u, .$anon0={ .shared_raw=((const void **)NULL) }, .nr_status_frames=0u,
    .$pad5=0u, .status=((unsigned short int **)NULL), .active=((struct active_grant_entry **)NULL),
    .maptrack=((struct grant_mapping **)NULL),
    .maptrack_limit=0u,
    .maptrack_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .gt_version=0u } ({ { { { 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0 })

#### Function call: active_entry_acquire(((struct grant_table { struct percpu_rwlock { struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } rwlock; bool_t writer_activating; unsigned __CPROVER_bitvector[24] $pad2; } lock; u32 nr_grant_frames; u32 $pad2; union { const void **shared_raw; struct grant_entry_v1 **shared_v1; union grant_entry_v2 **shared_v2; } $anon0; u32 nr_status_frames; u32 $pad5; unsigned short int **status; struct active_grant_entry **active; struct grant_mapping **maptrack; u32 maptrack_limit; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } maptrack_lock; u32 gt_version; } *)NULL), 0u) (depth 5) ####

#### Function return: active_entry_acquire (depth 4) ####

State 1072 file grant_table.c line 819 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
active_entry_acquire(rgt, op->ref);
----------------------------------------------------
  rgt$object={ .lock={ .rwlock={ .cnts={ .counter=0 }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } }, .writer_activating=FALSE,
    .$pad2=0 }, .nr_grant_frames=0u,
    .$pad2=0u, .$anon0={ .shared_raw=((const void **)NULL) }, .nr_status_frames=0u,
    .$pad5=0u, .status=((unsigned short int **)NULL), .active=((struct active_grant_entry **)NULL),
    .maptrack=((struct grant_mapping **)NULL),
    .maptrack_limit=0u,
    .maptrack_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .gt_version=0u } ({ { { { 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0 })

State 1073 file grant_table.c line 819 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
act = NONDET(struct active_grant_entry *);
----------------------------------------------------
  act=((struct active_grant_entry { u32 pin; unsigned short int domid; unsigned short int $pad2; struct domain *trans_domain; u32 trans_gref; u32 $pad5; unsigned long int frame; unsigned long int gfn; u32 is_sub_page : 1; u32 start : 15; u32 length : 16; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 $pad12; } *)NULL) (0x0)

#### Function call: shared_entry_header(((struct grant_table { struct percpu_rwlock { struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } rwlock; bool_t writer_activating; unsigned __CPROVER_bitvector[24] $pad2; } lock; u32 nr_grant_frames; u32 $pad2; union { const void **shared_raw; struct grant_entry_v1 **shared_v1; union grant_entry_v2 **shared_v2; } $anon0; u32 nr_status_frames; u32 $pad5; unsigned short int **status; struct active_grant_entry **active; struct grant_mapping **maptrack; u32 maptrack_limit; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } maptrack_lock; u32 gt_version; } *)NULL), 0u) (depth 5) ####

#### Function return: shared_entry_header (depth 4) ####

State 1077 file grant_table.c line 820 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
shared_entry_header(rgt, op->ref);
----------------------------------------------------
  rgt$object={ .lock={ .rwlock={ .cnts={ .counter=0 }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } }, .writer_activating=FALSE,
    .$pad2=0 }, .nr_grant_frames=0u,
    .$pad2=0u, .$anon0={ .shared_raw=((const void **)NULL) }, .nr_status_frames=0u,
    .$pad5=0u, .status=((unsigned short int **)NULL), .active=((struct active_grant_entry **)NULL),
    .maptrack=((struct grant_mapping **)NULL),
    .maptrack_limit=0u,
    .maptrack_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .gt_version=0u } ({ { { { 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0 })

State 1078 file grant_table.c line 820 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
shah = NONDET(grant_entry_header_t *);
----------------------------------------------------
  shah=((struct grant_entry_header { unsigned short int flags; unsigned short int domid; } *)NULL) (0x0)

State 1082 file grant_table.c line 821 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
status = tmp_if_expr$0;
----------------------------------------------------
  status=((unsigned short int *)NULL) (0x0)

#### Function call: _set_status(0u, 0, 4, 1, ((struct grant_entry_header { unsigned short int flags; unsigned short int domid; } *)NULL), ((struct active_grant_entry { u32 pin; unsigned short int domid; unsigned short int $pad2; struct domain *trans_domain; u32 trans_gref; u32 $pad5; unsigned long int frame; unsigned long int gfn; u32 is_sub_page : 1; u32 start : 15; u32 length : 16; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 $pad12; } *)NULL), ((unsigned short int *)NULL)) (depth 5) ####

#### Function return: _set_status (depth 4) ####

State 1092 file grant_table.c line 836 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
_set_status(rgt->gt_version, ld->domain_id, (signed int)(op->flags & (unsigned int)(1 << 2)), 1, shah, act, status);
----------------------------------------------------
  shah$object={ .flags=0, .domid=0 } ({ 0x0, 0x0 })

State 1093 file grant_table.c line 836 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
_set_status(rgt->gt_version, ld->domain_id, (signed int)(op->flags & (unsigned int)(1 << 2)), 1, shah, act, status);
----------------------------------------------------
  act$object={ .pin=4294967040u, .domid=0, .$pad2=0, .trans_domain=((struct domain *)NULL), .trans_gref=0u,
    .$pad5=0u, .frame=0ul, .gfn=0ul,
    .is_sub_page=0u, .start=0u, .length=0u,
    .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .$pad12=0u } ({ 0xFFFFFF00, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0 })

State 1094 file grant_table.c line 836 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
_set_status(rgt->gt_version, ld->domain_id, (signed int)(op->flags & (unsigned int)(1 << 2)), 1, shah, act, status);
----------------------------------------------------
  status$object=0 (0x0)

State 1095 file grant_table.c line 836 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
rc = NONDET(signed int);
----------------------------------------------------
  rc=0 (0x0)

State 1098 file grant_table.c line 862 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
old_pin = act->pin;
----------------------------------------------------
  old_pin=4294967040u (0xFFFFFF00)

State 1101 file grant_table.c line 867 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
act->pin = act->pin + (u32)((op->flags & (unsigned int)(1 << 2)) != 0u ? 1 << 8 : 1 << 0);
----------------------------------------------------
  act$object.pin=0u (0x0)

State 1102 file grant_table.c line 870 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
frame = act->frame;
----------------------------------------------------
  frame=0ul (0x0)

State 1103 file grant_table.c line 871 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
act_pin = act->pin;
----------------------------------------------------
  act_pin=0u (0x0)

State 1104 file grant_table.c line 873 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
cache_flags = (unsigned int)shah->flags & (1u << 7 | 1u << 5 | 1u << 6);
----------------------------------------------------
  cache_flags=0u (0x0)

#### Function call: active_entry_release(((struct active_grant_entry { u32 pin; unsigned short int domid; unsigned short int $pad2; struct domain *trans_domain; u32 trans_gref; u32 $pad5; unsigned long int frame; unsigned long int gfn; u32 is_sub_page : 1; u32 start : 15; u32 length : 16; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 $pad12; } *)NULL)) (depth 5) ####

#### Function return: active_entry_release (depth 4) ####

State 1108 file grant_table.c line 875 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
active_entry_release(act);
----------------------------------------------------
  act$object={ .pin=0u, .domid=0, .$pad2=0, .trans_domain=((struct domain *)NULL), .trans_gref=0u,
    .$pad5=0u, .frame=0ul, .gfn=0ul,
    .is_sub_page=0u, .start=0u, .length=0u,
    .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .$pad12=0u } ({ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0 })

#### Function call: grant_read_unlock(((struct grant_table { struct percpu_rwlock { struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } rwlock; bool_t writer_activating; unsigned __CPROVER_bitvector[24] $pad2; } lock; u32 nr_grant_frames; u32 $pad2; union { const void **shared_raw; struct grant_entry_v1 **shared_v1; union grant_entry_v2 **shared_v2; } $anon0; u32 nr_status_frames; u32 $pad5; unsigned short int **status; struct active_grant_entry **active; struct grant_mapping **maptrack; u32 maptrack_limit; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } maptrack_lock; u32 gt_version; } *)NULL)) (depth 5) ####

#### Function return: grant_read_unlock (depth 4) ####

State 1112 file grant_table.c line 876 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
grant_read_unlock(rgt);
----------------------------------------------------
  rgt$object={ .lock={ .rwlock={ .cnts={ .counter=0 }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } }, .writer_activating=FALSE,
    .$pad2=0 }, .nr_grant_frames=0u,
    .$pad2=0u, .$anon0={ .shared_raw=((const void **)NULL) }, .nr_status_frames=0u,
    .$pad5=0u, .status=((unsigned short int **)NULL), .active=((struct active_grant_entry **)NULL),
    .maptrack=((struct grant_mapping **)NULL),
    .maptrack_limit=0u,
    .maptrack_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .gt_version=0u } ({ { { { 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0 })

#### Function call: __mfn_valid(0ul) (depth 5) ####

#### Function return: __mfn_valid (depth 4) ####

#### Function call: pfn_to_pdx$link2(0ul) (depth 5) ####

#### Function return: pfn_to_pdx$link2 (depth 4) ####

State 1128 file grant_table.c line 881 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
pg = tmp_if_expr$6;
----------------------------------------------------
  pg=INVALID-65535 (0xFFFF0000 00000000)

#### Function call: page_get_owner_and_reference(INVALID-65535) (depth 5) ####

#### Function return: page_get_owner_and_reference (depth 4) ####

State 1133 file grant_table.c line 883 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
page_get_owner_and_reference(pg);
----------------------------------------------------
  __CPROVER_memory={ [0l]=0, [1l]=248, [2l]=1, [3l]=251, [4l]=0, [5l]=251, [6l]=0, [7l]=250 } (?)

State 1134 file grant_table.c line 883 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
owner = NONDET(struct domain *);
----------------------------------------------------
  owner=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) + 1l (0x1)

State 1139 file grant_table.c line 924 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
nr_gets = nr_gets + 1ul;
----------------------------------------------------
  nr_gets=1ul (0x1)

#### Function call: create_grant_host_mapping(1ul, 0ul, 22u, 0u) (depth 5) ####

State 1143 file grant_table.c line 927 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
create_grant_host_mapping(op->host_addr, frame, op->flags, (unsigned int)0);
----------------------------------------------------
  addr=1ul (0x1)

State 1144 file grant_table.c line 927 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
create_grant_host_mapping(op->host_addr, frame, op->flags, (unsigned int)0);
----------------------------------------------------
  frame=0ul (0x0)

State 1145 file grant_table.c line 927 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
create_grant_host_mapping(op->host_addr, frame, op->flags, (unsigned int)0);
----------------------------------------------------
  flags=22u (0x16)

State 1146 file grant_table.c line 927 function __gnttab_map_grant_ref thread 0
----------------------------------------------------
create_grant_host_mapping(op->host_addr, frame, op->flags, (unsigned int)0);
----------------------------------------------------
  cache_flags=0u (0x0)

State 1147 file mm.c line 4235 function create_grant_host_mapping thread 0
----------------------------------------------------
l1_pgentry_t pte;
----------------------------------------------------
  pte={ .l1=0ul } ({ 0x0 })

State 1148 file mm.c line 4236 function create_grant_host_mapping thread 0
----------------------------------------------------
uint32_t grant_pte_flags;
----------------------------------------------------
  grant_pte_flags=0u (0x0)

#### Function call: get_cpu_info$link17$link2() (depth 6) ####

#### Function return: get_cpu_info$link17$link2 (depth 5) ####

State 1155 file mm.c line 4241 function create_grant_host_mapping thread 0
----------------------------------------------------
grant_pte_flags = 0x1u | 0x20u | 0x40u | (unsigned int)0;
----------------------------------------------------
  grant_pte_flags=97u (0x61)

#### Function call: constant_test_bit$link11$link1(84, boot_cpu_data.x86_capability) (depth 6) ####

#### Function return: constant_test_bit$link11$link1 (depth 5) ####

State 1169 file mm.c line 4246 function create_grant_host_mapping thread 0
----------------------------------------------------
pte = { .l1=(intpte_t)frame << 12 | (intpte_t)(grant_pte_flags & (unsigned int)~0xFFF) << 40 | (unsigned long int)(grant_pte_flags & (unsigned int)0xFFF) };
----------------------------------------------------
  pte={ .l1=97ul } ({ 0x61 })

State 1172 file mm.c line 4252 function create_grant_host_mapping thread 0
----------------------------------------------------
pte.l1 = pte.l1 | (intpte_t)((flags >> 16) * 0x200u & 0xE00u & (unsigned int)~0xFFF) << 40 | (unsigned long int)((flags >> 16) * 0x200u & 0xE00u & (unsigned int)0xFFF);
----------------------------------------------------
  pte.l1=97ul (0x61)

#### Function call: cacheattr_to_pte_flags(0u) (depth 6) ####

#### Function return: cacheattr_to_pte_flags (depth 5) ####

#### Function call: cacheattr_to_pte_flags(0u) (depth 6) ####

#### Function return: cacheattr_to_pte_flags (depth 5) ####

State 1183 file mm.c line 4256 function create_grant_host_mapping thread 0
----------------------------------------------------
pte.l1 = pte.l1 | (intpte_t)(return_value_cacheattr_to_pte_flags & (unsigned int)~0xFFF) << 40 | (unsigned long int)(return_value_cacheattr_to_pte_flags$0 & (unsigned int)0xFFF);
----------------------------------------------------
  pte.l1=97ul (0x61)

#### Function call: get_cpu_info$link17$link2() (depth 6) ####

#### Function return: get_cpu_info$link17$link2 (depth 5) ####

#### Function call: create_grant_pte_mapping(1ul, { .l1=97ul }, ((struct vcpu { signed int vcpu_id; signed int processor; vcpu_info_t *vcpu_info; struct domain *domain; struct vcpu *next_in_list; signed long int periodic_period; signed long int periodic_last_event; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } periodic_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } singleshot_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } poll_timer; const void *sched_priv; struct vcpu_runstate_info { signed int state; u32 $pad1; unsigned long int state_entry_time; unsigned long int time[4l]; } runstate; union { struct { vcpu_runstate_info_t *p; } native; struct { vcpu_runstate_info_compat_t *p; } compat; } runstate_guest; unsigned long int last_run_time; bool_t fpu_initialised; bool_t fpu_dirtied; bool_t is_initialised; bool_t is_running; bool_t is_urgent; struct async_exception_state[2l]; u8 async_exception_mask; bool_t defer_shutdown; bool_t paused_for_shutdown; bool_t affinity_broken; unsigned __CPROVER_bitvector[24] $pad24; signed int poll_evtchn; signed int pirq_evtchn_head; unsigned long int pause_flags; struct { signed int counter; } pause_count; struct { signed int counter; } vm_event_pause_count; signed int controller_pause_count; u32 maptrack_head; u32 maptrack_tail; u32 virq_to_evtchn[24l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } virq_lock; u32 $pad35; const cpumask_t *cpu_hard_affinity; const cpumask_t *cpu_hard_affinity_tmp; const cpumask_t *cpu_hard_affinity_saved; const cpumask_t *cpu_soft_affinity; const cpumask_t *vcpu_dirty_cpumask; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } continue_hypercall_tasklet; struct mc_state { unsigned long int flags; union { struct multicall_entry { unsigned long int op; unsigned long int result; unsigned long int args[6l]; } call; struct compat_multicall_entry { u32 op; u32 result; u32 args[6l]; } compat_call; } $anon0; } mc_state; struct waitqueue_vcpu *waitqueue_vcpu; unsigned long int vcpu_info_mfn; struct evtchn_fifo_vcpu *evtchn_fifo; unsigned __CPROVER_bitvector[320] $pad46; struct arch_vcpu { const void *fpu_ctxt; unsigned long int vgc_flags; struct cpu_user_regs { unsigned long int r15; unsigned long int r14; unsigned long int r13; unsigned long int r12; union { unsigned long int rbp; unsigned long int ebp; u32 _ebp; } $anon0; union { unsigned long int rbx; unsigned long int ebx; u32 _ebx; } $anon1; unsigned long int r11; unsigned long int r10; unsigned long int r9; unsigned long int r8; union { unsigned long int rax; unsigned long int eax; u32 _eax; } $anon2; union { unsigned long int rcx; unsigned long int ecx; u32 _ecx; } $anon3; union { unsigned long int rdx; unsigned long int edx; u32 _edx; } $anon4; union { unsigned long int rsi; unsigned long int esi; u32 _esi; } $anon5; union { unsigned long int rdi; unsigned long int edi; u32 _edi; } $anon6; u32 error_code; u32 entry_vector; union { unsigned long int rip; unsigned long int eip; u32 _eip; } $anon7; unsigned short int cs; unsigned short int _pad0[1l]; u8 saved_upcall_mask; u8 _pad1[3l]; union { unsigned long int rflags; unsigned long int eflags; u32 _eflags; } $anon8; union { unsigned long int rsp; unsigned long int esp; u32 _esp; } $anon9; unsigned short int ss; unsigned short int _pad2[3l]; unsigned short int es; unsigned short int _pad3[3l]; unsigned short int ds; unsigned short int _pad4[3l]; unsigned short int fs; unsigned short int _pad5[3l]; unsigned short int gs; unsigned short int _pad6[3l]; } user_regs; unsigned long int debugreg[8l]; unsigned long int flags; const void (*schedule_tail)(struct vcpu *); const void (*ctxt_switch_from)(struct vcpu *); const void (*ctxt_switch_to)(struct vcpu *); struct vpmu_struct { u32 flags; u32 last_pcpu; u32 hw_lapic_lvtpc; u32 $pad3; const void *context; const void *priv_context; struct arch_vpmu_ops *arch_vpmu_ops; struct xen_pmu_data *xenpmu_data; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vpmu_lock; } vpmu; unsigned __int128; union { struct pv_vcpu { struct mapcache_vcpu { u32 shadow_epoch; u32 $pad1; struct vcpu_maphash_entry hash[8l]; } mapcache; struct trap_info *trap_ctxt; unsigned long int gdt_frames[14l]; unsigned long int ldt_base; u32 gdt_ents; u32 ldt_ents; unsigned long int kernel_ss; unsigned long int kernel_sp; unsigned long int ctrlreg[8l]; unsigned long int event_callback_eip; unsigned long int failsafe_callback_eip; union { unsigned long int syscall_callback_eip; struct { u32 event_callback_cs; u32 failsafe_callback_cs; } $anon0; } $anon0; unsigned long int syscall32_callback_eip; unsigned long int sysenter_callback_eip; unsigned short int syscall32_callback_cs; unsigned short int sysenter_callback_cs; bool_t syscall32_disables_events; bool_t sysenter_disables_events; unsigned short int $pad18; unsigned long int fs_base; unsigned long int gs_base_kernel; unsigned long int gs_base_user; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } trap_bounce; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } int80_bounce; struct { u8 *p; } iobmp; u32 iobmp_limit; u32 iopl; unsigned long int shadow_ldt_mapcnt; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shadow_ldt_lock; u32 dr_mask[4l]; bool_t need_update_runstate_area; unsigned __CPROVER_bitvector[56] $pad31; struct vcpu_time_info { u32 version; u32 pad0; unsigned long int tsc_timestamp; unsigned long int system_time; u32 tsc_to_system_mul; const char tsc_shift; u8 flags; u8 pad1[2l]; } pending_system_time; } pv_vcpu; struct hvm_vcpu { unsigned long int guest_cr[5l]; unsigned long int guest_efer; unsigned long int hw_cr[5l]; struct vlapic { struct hvm_hw_lapic { unsigned long int apic_base_msr; u32 disabled; u32 timer_divisor; unsigned long int tdt_msr; } hw; struct hvm_hw_lapic_regs *regs; struct { bool_t hw; bool_t regs; unsigned short int $pad2; u32 id; u32 ldr; } loaded; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } esr_lock; u32 $pad4; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt; signed long int timer_last_update; struct page_info *regs_page; struct { u32 icr; u32 dest; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } tasklet; } init_sipi; } vlapic; signed long int cache_tsc_offset; unsigned long int guest_time; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } tm_lock; struct list_head { struct list_head *next; struct list_head *prev; } tm_list; u8 flag_dr_dirty; bool_t debug_state_latch; bool_t single_step; bool_t hcall_preempted; bool_t hcall_64bit; unsigned __CPROVER_bitvector[24] $pad13; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } n1asid; u32 msr_tsc_aux; u32 $pad16; unsigned long int msr_tsc_adjust; unsigned long int msr_xss; unsigned __CPROVER_bitvector[192] $pad19; union { struct arch_vmx_struct { unsigned long int vmcs_pa; unsigned long int vmcs_shadow_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vmcs_lock; struct list_head { struct list_head *next; struct list_head *prev; } active_list; signed int active_cpu; signed int launched; u32 exec_control; u32 secondary_exec_control; u32 exception_bitmap; u32 $pad9; struct vmx_msr_state { unsigned long int flags; unsigned long int msrs[3l]; } msr_state; unsigned long int shadow_gs; unsigned long int cstar; unsigned long int *msr_bitmap; u32 msr_count; u32 $pad15; struct vmx_msr_entry *msr_area; u32 host_msr_count; u32 $pad18; struct vmx_msr_entry *host_msr_area; unsigned long int eoi_exitmap_changed; unsigned long int eoi_exit_bitmap[4l]; struct pi_desc { unsigned long int pir[4l]; union { struct { unsigned short int on : 1; unsigned short int sn : 1; unsigned short int rsvd_1 : 14; u8 nv; u8 rsvd_2; u32 ndst; } $anon0; unsigned long int control; } $anon0; u32 rsvd[6l]; } pi_desc; unsigned long int host_cr0; bool_t ept_spurious_misconfig; u8 vmx_realmode; u8 vmx_emulate; u8 $pad27; unsigned short int vm86_segment_mask; struct segment_register vm86_saved_seg[7l]; unsigned short int $pad30; u32 vm86_saved_eflags; signed int hostenv_migrated; struct page_info *vmread_bitmap; struct page_info *vmwrite_bitmap; struct page_info *pml_pg; struct pi_blocking_vcpu { struct list_head { struct list_head *next; struct list_head *prev; } list; spinlock_t *lock; } pi_blocking; unsigned long int $pad37; } vmx; struct arch_svm_struct { struct vmcb_struct *vmcb; unsigned long int vmcb_pa; unsigned long int *msrpm; signed int launch_core; bool_t vmcb_in_sync; u8 cached_insn_len; unsigned short int $pad6; unsigned long int guest_sysenter_cs; unsigned long int guest_sysenter_esp; unsigned long int guest_sysenter_eip; unsigned long int guest_lwp_cfg; unsigned long int cpu_lwp_cfg; u32 dr_mask[4l]; struct { unsigned long int length; unsigned long int status; } osvw; } svm; } u; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } assert_evtchn_irq_tasklet; struct nestedvcpu { bool_t nv_guestmode; unsigned __CPROVER_bitvector[56] $pad1; const void *nv_vvmcx; const void *nv_n1vmcx; const void *nv_n2vmcx; unsigned long int nv_vvmcxaddr; unsigned long int nv_n1vmcx_pa; unsigned long int nv_n2vmcx_pa; union { struct nestedsvm { bool_t ns_gif; unsigned __CPROVER_bitvector[56] $pad1; unsigned long int ns_msr_hsavepa; unsigned long int ns_ovvmcb_pa; unsigned long int ns_tscratio; u32 ns_cr_intercepts; u32 ns_dr_intercepts; u32 ns_exception_intercepts; u32 ns_general1_intercepts; u32 ns_general2_intercepts; union { unsigned long int bytes; struct { unsigned long int enable : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad1 : 7; unsigned __CPROVER_bitvector[56] $pad2; } fields; } ns_lbr_control; u32 $pad11; unsigned long int *ns_cached_msrpm; unsigned long int *ns_merged_msrpm; unsigned long int ns_iomap_pa; unsigned long int ns_oiomap_pa; unsigned long int *ns_iomap; unsigned long int ns_cr0; unsigned long int ns_vmcb_guestcr3; unsigned long int ns_vmcb_hostcr3; u32 ns_guest_asid; bool_t ns_hap_enabled; unsigned __CPROVER_bitvector[24] $pad22; struct { unsigned long int exitcode; unsigned long int exitinfo1; unsigned long int exitinfo2; } ns_vmexit; union { u32 bytes; struct { u32 rflagsif : 1; u32 vintrmask : 1; u32 reserved : 30; } fields; } ns_hostflags; u32 $pad25; } nsvm; struct nestedvmx { unsigned long int vmxon_region_pa; const void *iobitmap[2l]; const void *msrbitmap; struct { unsigned long int intr_info; u32 error_code; u8 source; unsigned __CPROVER_bitvector[24] $pad3; } intr; struct { bool_t enabled; unsigned __CPROVER_bitvector[24] $pad1; u32 exit_reason; u32 exit_qual; } ept; u32 guest_vpid; struct list_head { struct list_head *next; struct list_head *prev; } launched_list; } nvmx; } u; bool_t nv_flushp2m; unsigned __CPROVER_bitvector[56] $pad10; struct p2m_domain *nv_p2m; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } nv_n2asid; bool_t nv_vmentry_pending; bool_t nv_vmexit_pending; bool_t nv_vmswitch_in_progress; bool_t nv_ioport80; bool_t nv_ioportED; unsigned __CPROVER_bitvector[24] $pad18; unsigned long int guest_cr[5l]; } nvcpu; struct altp2mvcpu { unsigned short int p2midx; unsigned __CPROVER_bitvector[48] $pad1; unsigned long int veinfo_gfn; } avcpu; struct mtrr_state { struct mtrr_var_range *var_ranges; u8 fixed_ranges[88l]; u8 enabled; u8 have_fixed; u8 def_type; unsigned __CPROVER_bitvector[40] $pad5; unsigned long int mtrr_cap; bool_t overlapped; unsigned __CPROVER_bitvector[56] $pad8; } mtrr; unsigned long int pat_cr; signed long int stime_offset; u8 evtchn_upcall_vector; u8 cache_mode; unsigned __CPROVER_bitvector[48] $pad29; struct hvm_vcpu_io { enum hvm_io_completion io_completion; u32 $pad1; struct ioreq { unsigned long int addr; unsigned long int data; u32 count; u32 size; u32 vp_eport; unsigned short int _pad0; u8 state : 4; u8 data_is_ptr : 1; u8 dir : 1; u8 df : 1; u8 _pad1 : 1; u8 type; } io_req; struct npfec { u32 read_access : 1; u32 write_access : 1; u32 insn_fetch : 1; u32 present : 1; u32 gla_valid : 1; u32 kind : 2; unsigned __CPROVER_bitvector[1] $bit_field_pad6 : 1; unsigned __CPROVER_bitvector[24] $pad7; } mmio_access; u32 $pad4; unsigned long int mmio_gla; unsigned long int mmio_gpfn; struct hvm_mmio_cache mmio_cache[3l]; u32 mmio_cache_count; u32 mmio_insn_bytes; xen_domain_handle_t mmio_insn; bool_t mmio_retry; unsigned __CPROVER_bitvector[56] $pad12; unsigned long int msix_unmask_address; unsigned long int msix_snoop_address; unsigned long int msix_snoop_gpa; const struct g2m_ioport *g2m_ioport; } hvm_io; const void (*fpu_exception_callback)(const void *, struct cpu_user_regs *); const void *fpu_exception_callback_arg; struct hvm_trap { s16 vector; u8 type; u8 insn_len; u32 error_code; unsigned long int cr2; } inject_trap; struct viridian_vcpu { struct { union viridian_apic_assist { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } msr; const void *va; signed int vector; u32 $pad3; } apic_assist; } viridian; } hvm_vcpu; } $anon0; struct { unsigned long int pfn; } guest_table_user; struct { unsigned long int pfn; } guest_table; struct page_info *old_guest_table; pagetable_t shadow_table[4l]; struct { unsigned long int pfn; } monitor_table; unsigned long int cr3; struct xsave_struct *xsave_area; unsigned long int xcr0; unsigned long int xcr0_accum; bool_t nonlazy_xstate_used; bool_t cpuid_faulting; smap_check_policy_t smap_check_policy; unsigned __CPROVER_bitvector[40] $pad23; struct vmce { unsigned long int mcg_cap; unsigned long int mcg_status; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct vmce_bank bank[2l]; } vmce; struct paging_vcpu { const struct paging_mode *mode; const struct paging_mode *nestedmode; u32 last_write_was_pt : 1; u32 last_write_emul_ok : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad4 : 6; unsigned __CPROVER_bitvector[56] $pad5; struct shadow_vtlb *vtlb; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtlb_lock; unsigned __CPROVER_bitvector[192] $pad8; struct shadow_vcpu { l3_pgentry_t l3table[4l]; l3_pgentry_t gl3e[4l]; const void *guest_vtable; unsigned long int last_emulated_mfn_for_unshadow; unsigned long int last_writeable_pte_smfn; unsigned long int last_emulated_frame; unsigned long int last_emulated_mfn; unsigned long int oos[3l]; unsigned long int oos_snapshot[3l]; struct oos_fixup oos_fixup[3l]; bool_t pagetable_dying; unsigned __CPROVER_bitvector[120] $pad11; } shadow; } paging; u32 gdbsx_vcpu_event; u32 $pad27; struct { vcpu_time_info_t *p; } time_info_guest; struct arch_vm_event *vm_event; unsigned long int $pad30; } arch; } *)NULL)) (depth 6) ####

State 1193 file mm.c line 4259 function create_grant_host_mapping thread 0
----------------------------------------------------
create_grant_pte_mapping(addr, pte, return_value_get_cpu_info$0->current_vcpu);
----------------------------------------------------
  pte_addr=1ul (0x1)

State 1194 file mm.c line 4259 function create_grant_host_mapping thread 0
----------------------------------------------------
create_grant_pte_mapping(addr, pte, return_value_get_cpu_info$0->current_vcpu);
----------------------------------------------------
  nl1e={ .l1=97ul } ({ 0x61 })

State 1195 file mm.c line 4259 function create_grant_host_mapping thread 0
----------------------------------------------------
create_grant_pte_mapping(addr, pte, return_value_get_cpu_info$0->current_vcpu);
----------------------------------------------------
  v=((struct vcpu { signed int vcpu_id; signed int processor; vcpu_info_t *vcpu_info; struct domain *domain; struct vcpu *next_in_list; signed long int periodic_period; signed long int periodic_last_event; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } periodic_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } singleshot_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } poll_timer; const void *sched_priv; struct vcpu_runstate_info { signed int state; u32 $pad1; unsigned long int state_entry_time; unsigned long int time[4l]; } runstate; union { struct { vcpu_runstate_info_t *p; } native; struct { vcpu_runstate_info_compat_t *p; } compat; } runstate_guest; unsigned long int last_run_time; bool_t fpu_initialised; bool_t fpu_dirtied; bool_t is_initialised; bool_t is_running; bool_t is_urgent; struct async_exception_state[2l]; u8 async_exception_mask; bool_t defer_shutdown; bool_t paused_for_shutdown; bool_t affinity_broken; unsigned __CPROVER_bitvector[24] $pad24; signed int poll_evtchn; signed int pirq_evtchn_head; unsigned long int pause_flags; struct { signed int counter; } pause_count; struct { signed int counter; } vm_event_pause_count; signed int controller_pause_count; u32 maptrack_head; u32 maptrack_tail; u32 virq_to_evtchn[24l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } virq_lock; u32 $pad35; const cpumask_t *cpu_hard_affinity; const cpumask_t *cpu_hard_affinity_tmp; const cpumask_t *cpu_hard_affinity_saved; const cpumask_t *cpu_soft_affinity; const cpumask_t *vcpu_dirty_cpumask; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } continue_hypercall_tasklet; struct mc_state { unsigned long int flags; union { struct multicall_entry { unsigned long int op; unsigned long int result; unsigned long int args[6l]; } call; struct compat_multicall_entry { u32 op; u32 result; u32 args[6l]; } compat_call; } $anon0; } mc_state; struct waitqueue_vcpu *waitqueue_vcpu; unsigned long int vcpu_info_mfn; struct evtchn_fifo_vcpu *evtchn_fifo; unsigned __CPROVER_bitvector[320] $pad46; struct arch_vcpu { const void *fpu_ctxt; unsigned long int vgc_flags; struct cpu_user_regs { unsigned long int r15; unsigned long int r14; unsigned long int r13; unsigned long int r12; union { unsigned long int rbp; unsigned long int ebp; u32 _ebp; } $anon0; union { unsigned long int rbx; unsigned long int ebx; u32 _ebx; } $anon1; unsigned long int r11; unsigned long int r10; unsigned long int r9; unsigned long int r8; union { unsigned long int rax; unsigned long int eax; u32 _eax; } $anon2; union { unsigned long int rcx; unsigned long int ecx; u32 _ecx; } $anon3; union { unsigned long int rdx; unsigned long int edx; u32 _edx; } $anon4; union { unsigned long int rsi; unsigned long int esi; u32 _esi; } $anon5; union { unsigned long int rdi; unsigned long int edi; u32 _edi; } $anon6; u32 error_code; u32 entry_vector; union { unsigned long int rip; unsigned long int eip; u32 _eip; } $anon7; unsigned short int cs; unsigned short int _pad0[1l]; u8 saved_upcall_mask; u8 _pad1[3l]; union { unsigned long int rflags; unsigned long int eflags; u32 _eflags; } $anon8; union { unsigned long int rsp; unsigned long int esp; u32 _esp; } $anon9; unsigned short int ss; unsigned short int _pad2[3l]; unsigned short int es; unsigned short int _pad3[3l]; unsigned short int ds; unsigned short int _pad4[3l]; unsigned short int fs; unsigned short int _pad5[3l]; unsigned short int gs; unsigned short int _pad6[3l]; } user_regs; unsigned long int debugreg[8l]; unsigned long int flags; const void (*schedule_tail)(struct vcpu *); const void (*ctxt_switch_from)(struct vcpu *); const void (*ctxt_switch_to)(struct vcpu *); struct vpmu_struct { u32 flags; u32 last_pcpu; u32 hw_lapic_lvtpc; u32 $pad3; const void *context; const void *priv_context; struct arch_vpmu_ops *arch_vpmu_ops; struct xen_pmu_data *xenpmu_data; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vpmu_lock; } vpmu; unsigned __int128; union { struct pv_vcpu { struct mapcache_vcpu { u32 shadow_epoch; u32 $pad1; struct vcpu_maphash_entry hash[8l]; } mapcache; struct trap_info *trap_ctxt; unsigned long int gdt_frames[14l]; unsigned long int ldt_base; u32 gdt_ents; u32 ldt_ents; unsigned long int kernel_ss; unsigned long int kernel_sp; unsigned long int ctrlreg[8l]; unsigned long int event_callback_eip; unsigned long int failsafe_callback_eip; union { unsigned long int syscall_callback_eip; struct { u32 event_callback_cs; u32 failsafe_callback_cs; } $anon0; } $anon0; unsigned long int syscall32_callback_eip; unsigned long int sysenter_callback_eip; unsigned short int syscall32_callback_cs; unsigned short int sysenter_callback_cs; bool_t syscall32_disables_events; bool_t sysenter_disables_events; unsigned short int $pad18; unsigned long int fs_base; unsigned long int gs_base_kernel; unsigned long int gs_base_user; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } trap_bounce; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } int80_bounce; struct { u8 *p; } iobmp; u32 iobmp_limit; u32 iopl; unsigned long int shadow_ldt_mapcnt; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shadow_ldt_lock; u32 dr_mask[4l]; bool_t need_update_runstate_area; unsigned __CPROVER_bitvector[56] $pad31; struct vcpu_time_info { u32 version; u32 pad0; unsigned long int tsc_timestamp; unsigned long int system_time; u32 tsc_to_system_mul; const char tsc_shift; u8 flags; u8 pad1[2l]; } pending_system_time; } pv_vcpu; struct hvm_vcpu { unsigned long int guest_cr[5l]; unsigned long int guest_efer; unsigned long int hw_cr[5l]; struct vlapic { struct hvm_hw_lapic { unsigned long int apic_base_msr; u32 disabled; u32 timer_divisor; unsigned long int tdt_msr; } hw; struct hvm_hw_lapic_regs *regs; struct { bool_t hw; bool_t regs; unsigned short int $pad2; u32 id; u32 ldr; } loaded; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } esr_lock; u32 $pad4; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt; signed long int timer_last_update; struct page_info *regs_page; struct { u32 icr; u32 dest; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } tasklet; } init_sipi; } vlapic; signed long int cache_tsc_offset; unsigned long int guest_time; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } tm_lock; struct list_head { struct list_head *next; struct list_head *prev; } tm_list; u8 flag_dr_dirty; bool_t debug_state_latch; bool_t single_step; bool_t hcall_preempted; bool_t hcall_64bit; unsigned __CPROVER_bitvector[24] $pad13; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } n1asid; u32 msr_tsc_aux; u32 $pad16; unsigned long int msr_tsc_adjust; unsigned long int msr_xss; unsigned __CPROVER_bitvector[192] $pad19; union { struct arch_vmx_struct { unsigned long int vmcs_pa; unsigned long int vmcs_shadow_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vmcs_lock; struct list_head { struct list_head *next; struct list_head *prev; } active_list; signed int active_cpu; signed int launched; u32 exec_control; u32 secondary_exec_control; u32 exception_bitmap; u32 $pad9; struct vmx_msr_state { unsigned long int flags; unsigned long int msrs[3l]; } msr_state; unsigned long int shadow_gs; unsigned long int cstar; unsigned long int *msr_bitmap; u32 msr_count; u32 $pad15; struct vmx_msr_entry *msr_area; u32 host_msr_count; u32 $pad18; struct vmx_msr_entry *host_msr_area; unsigned long int eoi_exitmap_changed; unsigned long int eoi_exit_bitmap[4l]; struct pi_desc { unsigned long int pir[4l]; union { struct { unsigned short int on : 1; unsigned short int sn : 1; unsigned short int rsvd_1 : 14; u8 nv; u8 rsvd_2; u32 ndst; } $anon0; unsigned long int control; } $anon0; u32 rsvd[6l]; } pi_desc; unsigned long int host_cr0; bool_t ept_spurious_misconfig; u8 vmx_realmode; u8 vmx_emulate; u8 $pad27; unsigned short int vm86_segment_mask; struct segment_register vm86_saved_seg[7l]; unsigned short int $pad30; u32 vm86_saved_eflags; signed int hostenv_migrated; struct page_info *vmread_bitmap; struct page_info *vmwrite_bitmap; struct page_info *pml_pg; struct pi_blocking_vcpu { struct list_head { struct list_head *next; struct list_head *prev; } list; spinlock_t *lock; } pi_blocking; unsigned long int $pad37; } vmx; struct arch_svm_struct { struct vmcb_struct *vmcb; unsigned long int vmcb_pa; unsigned long int *msrpm; signed int launch_core; bool_t vmcb_in_sync; u8 cached_insn_len; unsigned short int $pad6; unsigned long int guest_sysenter_cs; unsigned long int guest_sysenter_esp; unsigned long int guest_sysenter_eip; unsigned long int guest_lwp_cfg; unsigned long int cpu_lwp_cfg; u32 dr_mask[4l]; struct { unsigned long int length; unsigned long int status; } osvw; } svm; } u; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } assert_evtchn_irq_tasklet; struct nestedvcpu { bool_t nv_guestmode; unsigned __CPROVER_bitvector[56] $pad1; const void *nv_vvmcx; const void *nv_n1vmcx; const void *nv_n2vmcx; unsigned long int nv_vvmcxaddr; unsigned long int nv_n1vmcx_pa; unsigned long int nv_n2vmcx_pa; union { struct nestedsvm { bool_t ns_gif; unsigned __CPROVER_bitvector[56] $pad1; unsigned long int ns_msr_hsavepa; unsigned long int ns_ovvmcb_pa; unsigned long int ns_tscratio; u32 ns_cr_intercepts; u32 ns_dr_intercepts; u32 ns_exception_intercepts; u32 ns_general1_intercepts; u32 ns_general2_intercepts; union { unsigned long int bytes; struct { unsigned long int enable : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad1 : 7; unsigned __CPROVER_bitvector[56] $pad2; } fields; } ns_lbr_control; u32 $pad11; unsigned long int *ns_cached_msrpm; unsigned long int *ns_merged_msrpm; unsigned long int ns_iomap_pa; unsigned long int ns_oiomap_pa; unsigned long int *ns_iomap; unsigned long int ns_cr0; unsigned long int ns_vmcb_guestcr3; unsigned long int ns_vmcb_hostcr3; u32 ns_guest_asid; bool_t ns_hap_enabled; unsigned __CPROVER_bitvector[24] $pad22; struct { unsigned long int exitcode; unsigned long int exitinfo1; unsigned long int exitinfo2; } ns_vmexit; union { u32 bytes; struct { u32 rflagsif : 1; u32 vintrmask : 1; u32 reserved : 30; } fields; } ns_hostflags; u32 $pad25; } nsvm; struct nestedvmx { unsigned long int vmxon_region_pa; const void *iobitmap[2l]; const void *msrbitmap; struct { unsigned long int intr_info; u32 error_code; u8 source; unsigned __CPROVER_bitvector[24] $pad3; } intr; struct { bool_t enabled; unsigned __CPROVER_bitvector[24] $pad1; u32 exit_reason; u32 exit_qual; } ept; u32 guest_vpid; struct list_head { struct list_head *next; struct list_head *prev; } launched_list; } nvmx; } u; bool_t nv_flushp2m; unsigned __CPROVER_bitvector[56] $pad10; struct p2m_domain *nv_p2m; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } nv_n2asid; bool_t nv_vmentry_pending; bool_t nv_vmexit_pending; bool_t nv_vmswitch_in_progress; bool_t nv_ioport80; bool_t nv_ioportED; unsigned __CPROVER_bitvector[24] $pad18; unsigned long int guest_cr[5l]; } nvcpu; struct altp2mvcpu { unsigned short int p2midx; unsigned __CPROVER_bitvector[48] $pad1; unsigned long int veinfo_gfn; } avcpu; struct mtrr_state { struct mtrr_var_range *var_ranges; u8 fixed_ranges[88l]; u8 enabled; u8 have_fixed; u8 def_type; unsigned __CPROVER_bitvector[40] $pad5; unsigned long int mtrr_cap; bool_t overlapped; unsigned __CPROVER_bitvector[56] $pad8; } mtrr; unsigned long int pat_cr; signed long int stime_offset; u8 evtchn_upcall_vector; u8 cache_mode; unsigned __CPROVER_bitvector[48] $pad29; struct hvm_vcpu_io { enum hvm_io_completion io_completion; u32 $pad1; struct ioreq { unsigned long int addr; unsigned long int data; u32 count; u32 size; u32 vp_eport; unsigned short int _pad0; u8 state : 4; u8 data_is_ptr : 1; u8 dir : 1; u8 df : 1; u8 _pad1 : 1; u8 type; } io_req; struct npfec { u32 read_access : 1; u32 write_access : 1; u32 insn_fetch : 1; u32 present : 1; u32 gla_valid : 1; u32 kind : 2; unsigned __CPROVER_bitvector[1] $bit_field_pad6 : 1; unsigned __CPROVER_bitvector[24] $pad7; } mmio_access; u32 $pad4; unsigned long int mmio_gla; unsigned long int mmio_gpfn; struct hvm_mmio_cache mmio_cache[3l]; u32 mmio_cache_count; u32 mmio_insn_bytes; xen_domain_handle_t mmio_insn; bool_t mmio_retry; unsigned __CPROVER_bitvector[56] $pad12; unsigned long int msix_unmask_address; unsigned long int msix_snoop_address; unsigned long int msix_snoop_gpa; const struct g2m_ioport *g2m_ioport; } hvm_io; const void (*fpu_exception_callback)(const void *, struct cpu_user_regs *); const void *fpu_exception_callback_arg; struct hvm_trap { s16 vector; u8 type; u8 insn_len; u32 error_code; unsigned long int cr2; } inject_trap; struct viridian_vcpu { struct { union viridian_apic_assist { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } msr; const void *va; signed int vector; u32 $pad3; } apic_assist; } viridian; } hvm_vcpu; } $anon0; struct { unsigned long int pfn; } guest_table_user; struct { unsigned long int pfn; } guest_table; struct page_info *old_guest_table; pagetable_t shadow_table[4l]; struct { unsigned long int pfn; } monitor_table; unsigned long int cr3; struct xsave_struct *xsave_area; unsigned long int xcr0; unsigned long int xcr0_accum; bool_t nonlazy_xstate_used; bool_t cpuid_faulting; smap_check_policy_t smap_check_policy; unsigned __CPROVER_bitvector[40] $pad23; struct vmce { unsigned long int mcg_cap; unsigned long int mcg_status; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct vmce_bank bank[2l]; } vmce; struct paging_vcpu { const struct paging_mode *mode; const struct paging_mode *nestedmode; u32 last_write_was_pt : 1; u32 last_write_emul_ok : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad4 : 6; unsigned __CPROVER_bitvector[56] $pad5; struct shadow_vtlb *vtlb; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtlb_lock; unsigned __CPROVER_bitvector[192] $pad8; struct shadow_vcpu { l3_pgentry_t l3table[4l]; l3_pgentry_t gl3e[4l]; const void *guest_vtable; unsigned long int last_emulated_mfn_for_unshadow; unsigned long int last_writeable_pte_smfn; unsigned long int last_emulated_frame; unsigned long int last_emulated_mfn; unsigned long int oos[3l]; unsigned long int oos_snapshot[3l]; struct oos_fixup oos_fixup[3l]; bool_t pagetable_dying; unsigned __CPROVER_bitvector[120] $pad11; } shadow; } paging; u32 gdbsx_vcpu_event; u32 $pad27; struct { vcpu_time_info_t *p; } time_info_guest; struct arch_vm_event *vm_event; unsigned long int $pad30; } arch; } *)NULL) (0x0)

State 1196 file mm.c line 3963 function create_grant_pte_mapping thread 0
----------------------------------------------------
signed int rc;
----------------------------------------------------
  rc=0 (0x0)

State 1197 file mm.c line 3963 function create_grant_pte_mapping thread 0
----------------------------------------------------
rc = 0;
----------------------------------------------------
  rc=0 (0x0)

State 1198 file mm.c line 3964 function create_grant_pte_mapping thread 0
----------------------------------------------------
void *va;
----------------------------------------------------
  va=NULL (0x0)

State 1199 file mm.c line 3965 function create_grant_pte_mapping thread 0
----------------------------------------------------
unsigned long int gmfn;
----------------------------------------------------
  gmfn=0ul (0x0)

State 1200 file mm.c line 3965 function create_grant_pte_mapping thread 0
----------------------------------------------------
unsigned long int mfn;
----------------------------------------------------
  mfn=0ul (0x0)

State 1201 file mm.c line 3966 function create_grant_pte_mapping thread 0
----------------------------------------------------
struct page_info *page;
----------------------------------------------------
  page=((struct page_info { union { struct page_list_entry { u32 next; u32 prev; } list; unsigned long int up; struct page_sharing_info *sharing; } $anon0; unsigned long int count_info; union { struct { unsigned long int type_info; } inuse; struct { unsigned long int type : 5; unsigned long int pinned : 1; unsigned long int head : 1; unsigned long int count : 25; u32 $pad4; } sh; struct { bool_t need_tlbflush; } free; } u; union { struct { u32 _domain; } inuse; struct { u32 back; } sh; struct { u32 order; } free; } v; union { u32 tlbflush_timestamp; struct { unsigned short int nr_validated_ptes; const char partial_pte; u8 $pad2; } $anon0; u32 shadow_flags; u32 next_shadow; } $anon1; } *)NULL) (0x0)

State 1202 file mm.c line 3967 function create_grant_pte_mapping thread 0
----------------------------------------------------
l1_pgentry_t ol1e;
----------------------------------------------------
  ol1e={ .l1=0ul } ({ 0x0 })

State 1203 file mm.c line 3968 function create_grant_pte_mapping thread 0
----------------------------------------------------
struct domain *d;
----------------------------------------------------
  d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 1204 file mm.c line 3968 function create_grant_pte_mapping thread 0
----------------------------------------------------
d = v->domain;
----------------------------------------------------
  d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

Violated property:
  file mm.c line 3970 function create_grant_pte_mapping
  assertion
  (pte_addr & sizeof(l1_pgentry_t) /*8ul*/  - (unsigned long int)1) == (unsigned long int)0


521.628227 VERIFICATION FAILED

real	0m10.954s
user	0m10.676s
sys	0m0.276s
goto-instrument options: --aggressive-slice --aggressive-slice-call-depth 0 
cbmc options:  --stop-on-fail --object-bits 16 --trace --trace-show-function-calls --trace-show-code --trace-hex --no-sat-preprocessor --unwind 0 --havoc-undefined-functions 
End time 1537520339
