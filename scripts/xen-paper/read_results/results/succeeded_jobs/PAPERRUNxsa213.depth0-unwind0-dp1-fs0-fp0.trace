1537443457
1537443516
124.764623 CBMC version 5.10 (cbmc-5.10-163-g755b00c) 64-bit x86_64 linux
124.765275 Reading GOTO program from file
124.765284 Reading: xsa213.sliced.binary
125.801923 Generating GOTO Program
125.827018 Adding CPROVER library (x86_64)
125.836273 Removal of function pointers and virtual functions
125.985218 Generic Property Instrumentation
126.092368 Running with 16 object bits, 48 offset bits (user-specified)
126.101769 Starting Bounded Model Checking
127.352493 **** WARNING: no body for function get_cpu_info$link51; assigning non-deterministic values to any pointer arguments
127.368743 **** WARNING: no body for function do_iret; assigning non-deterministic values to any pointer arguments
127.389101 **** WARNING: no body for function get_cpu_info$link17$link2; assigning non-deterministic values to any pointer arguments
127.412931 **** WARNING: no body for function put_old_guest_table; assigning non-deterministic values to any pointer arguments
127.433601 **** WARNING: no body for function hypercall_create_continuation; assigning non-deterministic values to any pointer arguments
127.513901 **** WARNING: no body for function copy_from_user_hvm; assigning non-deterministic values to any pointer arguments
127.526178 **** WARNING: no body for function copy_from_user; assigning non-deterministic values to any pointer arguments
127.656384 **** WARNING: no body for function get_pg_owner; assigning non-deterministic values to any pointer arguments
127.707425 **** WARNING: no body for function put_pg_owner; assigning non-deterministic values to any pointer arguments
127.768093 **** WARNING: no body for function xsm_mmuext_op; assigning non-deterministic values to any pointer arguments
127.946744 **** WARNING: no body for function __copy_from_user$link1$link2; assigning non-deterministic values to any pointer arguments
127.959665 **** WARNING: no body for function gdprintk$link22; assigning non-deterministic values to any pointer arguments
128.175018 **** WARNING: no body for function get_page_from_gfn$link2$link2; assigning non-deterministic values to any pointer arguments
128.214030 **** WARNING: no body for function get_page_type_preemptible; assigning non-deterministic values to any pointer arguments
128.233041 **** WARNING: no body for function pdx_to_pfn$link3$link4; assigning non-deterministic values to any pointer arguments
128.263799 **** WARNING: no body for function put_page; assigning non-deterministic values to any pointer arguments
128.290947 **** WARNING: no body for function xsm_memory_pin_page; assigning non-deterministic values to any pointer arguments
128.332670 **** WARNING: no body for function test_and_set_bit$link1$link3; assigning non-deterministic values to any pointer arguments
128.360450 **** WARNING: no body for function paging_mark_dirty; assigning non-deterministic values to any pointer arguments
128.391814 **** WARNING: no body for function _spin_lock; assigning non-deterministic values to any pointer arguments
128.400988 **** WARNING: no body for function test_and_clear_bit$link2$link3; assigning non-deterministic values to any pointer arguments
128.427152 **** WARNING: no body for function _spin_unlock; assigning non-deterministic values to any pointer arguments
128.450626 **** WARNING: no body for function put_page_and_type$link2$link1; assigning non-deterministic values to any pointer arguments
128.672030 **** WARNING: no body for function put_page_and_type_preemptible$link1; assigning non-deterministic values to any pointer arguments
128.890901 **** WARNING: no body for function _mfn$link4$link3; assigning non-deterministic values to any pointer arguments
128.891081 **** WARNING: no body for function map_domain_page; assigning non-deterministic values to any pointer arguments
129.174761 **** WARNING: no body for function update_intpte; assigning non-deterministic values to any pointer arguments
129.238256 **** WARNING: no body for function get_page_from_l4e; assigning non-deterministic values to any pointer arguments
129.533286 **** WARNING: no body for function put_page_from_l4e; assigning non-deterministic values to any pointer arguments
129.828384 **** WARNING: no body for function unmap_domain_page; assigning non-deterministic values to any pointer arguments
129.917404 **** WARNING: no body for function invalidate_shadow_ldt; assigning non-deterministic values to any pointer arguments
129.940944 **** WARNING: no body for function write_ptbase; assigning non-deterministic values to any pointer arguments
130.135505 **** WARNING: no body for function get_page_from_pagenr; assigning non-deterministic values to any pointer arguments
130.179882 **** WARNING: no body for function get_page_and_type_from_pagenr; assigning non-deterministic values to any pointer arguments
130.339854 **** WARNING: no body for function constant_test_bit$link11$link1; assigning non-deterministic values to any pointer arguments
130.369940 **** WARNING: no body for function fill_ro_mpt; assigning non-deterministic values to any pointer arguments
130.427123 **** WARNING: no body for function update_cr3; assigning non-deterministic values to any pointer arguments
130.474262 **** WARNING: no body for function pfn_to_pdx$link8$link2; assigning non-deterministic values to any pointer arguments
131.516232 **** WARNING: no body for function zap_ro_mpt; assigning non-deterministic values to any pointer arguments
131.843895 **** WARNING: no body for function flush_area_local; assigning non-deterministic values to any pointer arguments
131.956017 **** WARNING: no body for function paging_invlpg; assigning non-deterministic values to any pointer arguments
132.083190 **** WARNING: no body for function vcpumask_to_pcpumask; assigning non-deterministic values to any pointer arguments
132.138865 **** WARNING: no body for function flush_area_mask; assigning non-deterministic values to any pointer arguments
132.480705 **** WARNING: no body for function rangeset_is_empty; assigning non-deterministic values to any pointer arguments
132.682738 **** WARNING: no body for function cpumask_clear$link1$link2; assigning non-deterministic values to any pointer arguments
132.683038 **** WARNING: no body for function cpumask_first$link2$link2; assigning non-deterministic values to any pointer arguments
132.686297 **** WARNING: no body for function cpumask_intersects$link3$link1; assigning non-deterministic values to any pointer arguments
132.688790 **** WARNING: no body for function __cpumask_set_cpu$link6; assigning non-deterministic values to any pointer arguments
132.702940 **** WARNING: no body for function cpumask_next$link2$link2; assigning non-deterministic values to any pointer arguments
132.703252 Not unwinding loop do_mmuext_op.6 iteration 1 file mm.c line 3464 function do_mmuext_op thread 0
133.046184 **** WARNING: no body for function load_LDT$link1; assigning non-deterministic values to any pointer arguments
133.288621 **** WARNING: no body for function get_page_type; assigning non-deterministic values to any pointer arguments
133.354278 **** WARNING: no body for function clear_domain_page; assigning non-deterministic values to any pointer arguments
133.578005 **** WARNING: no body for function copy_domain_page; assigning non-deterministic values to any pointer arguments
136.320049 Not unwinding loop do_mmuext_op.7 iteration 1 file mm.c line 3157 function do_mmuext_op thread 0
136.708089 **** WARNING: no body for function copy_to_user_hvm; assigning non-deterministic values to any pointer arguments
136.731289 **** WARNING: no body for function copy_to_user; assigning non-deterministic values to any pointer arguments
137.383151 Not unwinding loop do_multicall_stub.0 iteration 1 file multicallstub.c line 9 function do_multicall_stub thread 0
137.760252 size of program expression: 9097 steps
137.761463 simple slicing removed 6447 assignments
137.761467 Generated 1 VCC(s), 1 remaining after simplification
137.761474 Passing problem to propositional reduction
137.761489 converting SSA
138.173545 Running propositional reduction
138.173564 Post-processing
138.173583 Solving with MiniSAT 2.2.1 without simplifier
138.173587 663831 variables, 312929 clauses
138.233570 SAT checker: instance is SATISFIABLE
138.233599 Runtime decision procedure: 0.472095s
138.233606 Building error trace
138.675103 Counterexample:
138.737644 
#### Function call: __CPROVER_initialize() (depth 1) ####

#### Function return: __CPROVER_initialize (depth 0) ####

#### Function call: do_multicall_stub() (depth 1) ####

#### Function call: get_cpu_info$link51() (depth 2) ####

#### Function return: get_cpu_info$link51 (depth 1) ####

#### Function call: get_cpu_info$link51() (depth 2) ####

#### Function return: get_cpu_info$link51 (depth 1) ####

State 951 file multicallstub.c line 11 function do_multicall_stub thread 0
----------------------------------------------------
unsigned int call;
----------------------------------------------------
  call=0u (0x0)

State 953 file multicallstub.c line 16 function do_multicall_stub thread 0
----------------------------------------------------
__guest_handle_mmuext_op_t uops;
----------------------------------------------------
  uops={ .p=((mmuext_op_t *)NULL) } ({ 0x0 })

State 954 file multicallstub.c line 17 function do_multicall_stub thread 0
----------------------------------------------------
unsigned int count;
----------------------------------------------------
  count=1u (0x1)

State 955 file multicallstub.c line 18 function do_multicall_stub thread 0
----------------------------------------------------
__guest_handle_uint pdone;
----------------------------------------------------
  pdone={ .p=((u32 *)NULL) } ({ 0x0 })

State 956 file multicallstub.c line 19 function do_multicall_stub thread 0
----------------------------------------------------
unsigned int foreigndom;
----------------------------------------------------
  foreigndom=0u (0x0)

#### Function call: do_mmuext_op({ .p=((mmuext_op_t *)NULL) }, 1u, { .p=((u32 *)NULL) }, 0u) (depth 2) ####

State 959 file multicallstub.c line 20 function do_multicall_stub thread 0
----------------------------------------------------
do_mmuext_op(uops, count, pdone, foreigndom);
----------------------------------------------------
  uops={ .p=((mmuext_op_t *)NULL) } ({ 0x0 })

State 960 file multicallstub.c line 20 function do_multicall_stub thread 0
----------------------------------------------------
do_mmuext_op(uops, count, pdone, foreigndom);
----------------------------------------------------
  count=1u (0x1)

State 961 file multicallstub.c line 20 function do_multicall_stub thread 0
----------------------------------------------------
do_mmuext_op(uops, count, pdone, foreigndom);
----------------------------------------------------
  pdone={ .p=((u32 *)NULL) } ({ 0x0 })

State 962 file multicallstub.c line 20 function do_multicall_stub thread 0
----------------------------------------------------
do_mmuext_op(uops, count, pdone, foreigndom);
----------------------------------------------------
  foreigndom=0u (0x0)

State 963 file mm.c line 3104 function do_mmuext_op thread 0
----------------------------------------------------
struct mmuext_op op;
----------------------------------------------------
  op={ .cmd=0u, .$pad1=0u, .arg1={ .mfn=0ul }, .arg2={ .nr_ents=0u } } ({ 0x0, 0x0, 0x0, 0x0 })

State 964 file mm.c line 3105 function do_mmuext_op thread 0
----------------------------------------------------
unsigned long int type;
----------------------------------------------------
  type=0ul (0x0)

State 965 file mm.c line 3106 function do_mmuext_op thread 0
----------------------------------------------------
unsigned int i;
----------------------------------------------------
  i=0u (0x0)

State 966 file mm.c line 3106 function do_mmuext_op thread 0
----------------------------------------------------
unsigned int done;
----------------------------------------------------
  done=0u (0x0)

State 967 file mm.c line 3106 function do_mmuext_op thread 0
----------------------------------------------------
done = (unsigned int)0;
----------------------------------------------------
  done=0u (0x0)

State 968 file mm.c line 3107 function do_mmuext_op thread 0
----------------------------------------------------
struct vcpu *curr;
----------------------------------------------------
  curr=((struct vcpu { signed int vcpu_id; signed int processor; vcpu_info_t *vcpu_info; struct domain *domain; struct vcpu *next_in_list; signed long int periodic_period; signed long int periodic_last_event; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } periodic_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } singleshot_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } poll_timer; const void *sched_priv; struct vcpu_runstate_info { signed int state; u32 $pad1; unsigned long int state_entry_time; unsigned long int time[4l]; } runstate; union { struct { vcpu_runstate_info_t *p; } native; struct { vcpu_runstate_info_compat_t *p; } compat; } runstate_guest; unsigned long int last_run_time; bool_t fpu_initialised; bool_t fpu_dirtied; bool_t is_initialised; bool_t is_running; bool_t is_urgent; struct async_exception_state[2l]; u8 async_exception_mask; bool_t defer_shutdown; bool_t paused_for_shutdown; bool_t affinity_broken; unsigned __CPROVER_bitvector[24] $pad24; signed int poll_evtchn; signed int pirq_evtchn_head; unsigned long int pause_flags; struct { signed int counter; } pause_count; struct { signed int counter; } vm_event_pause_count; signed int controller_pause_count; u32 maptrack_head; u32 maptrack_tail; u32 virq_to_evtchn[24l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } virq_lock; u32 $pad35; const cpumask_t *cpu_hard_affinity; const cpumask_t *cpu_hard_affinity_tmp; const cpumask_t *cpu_hard_affinity_saved; const cpumask_t *cpu_soft_affinity; const cpumask_t *vcpu_dirty_cpumask; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } continue_hypercall_tasklet; struct mc_state { unsigned long int flags; union { struct multicall_entry { unsigned long int op; unsigned long int result; unsigned long int args[6l]; } call; struct compat_multicall_entry { u32 op; u32 result; u32 args[6l]; } compat_call; } $anon0; } mc_state; struct waitqueue_vcpu *waitqueue_vcpu; unsigned long int vcpu_info_mfn; struct evtchn_fifo_vcpu *evtchn_fifo; unsigned __CPROVER_bitvector[320] $pad46; struct arch_vcpu { const void *fpu_ctxt; unsigned long int vgc_flags; struct cpu_user_regs { unsigned long int r15; unsigned long int r14; unsigned long int r13; unsigned long int r12; union { unsigned long int rbp; unsigned long int ebp; u32 _ebp; } $anon0; union { unsigned long int rbx; unsigned long int ebx; u32 _ebx; } $anon1; unsigned long int r11; unsigned long int r10; unsigned long int r9; unsigned long int r8; union { unsigned long int rax; unsigned long int eax; u32 _eax; } $anon2; union { unsigned long int rcx; unsigned long int ecx; u32 _ecx; } $anon3; union { unsigned long int rdx; unsigned long int edx; u32 _edx; } $anon4; union { unsigned long int rsi; unsigned long int esi; u32 _esi; } $anon5; union { unsigned long int rdi; unsigned long int edi; u32 _edi; } $anon6; u32 error_code; u32 entry_vector; union { unsigned long int rip; unsigned long int eip; u32 _eip; } $anon7; unsigned short int cs; unsigned short int _pad0[1l]; u8 saved_upcall_mask; u8 _pad1[3l]; union { unsigned long int rflags; unsigned long int eflags; u32 _eflags; } $anon8; union { unsigned long int rsp; unsigned long int esp; u32 _esp; } $anon9; unsigned short int ss; unsigned short int _pad2[3l]; unsigned short int es; unsigned short int _pad3[3l]; unsigned short int ds; unsigned short int _pad4[3l]; unsigned short int fs; unsigned short int _pad5[3l]; unsigned short int gs; unsigned short int _pad6[3l]; } user_regs; unsigned long int debugreg[8l]; unsigned long int flags; const void (*schedule_tail)(struct vcpu *); const void (*ctxt_switch_from)(struct vcpu *); const void (*ctxt_switch_to)(struct vcpu *); struct vpmu_struct { u32 flags; u32 last_pcpu; u32 hw_lapic_lvtpc; u32 $pad3; const void *context; const void *priv_context; struct arch_vpmu_ops *arch_vpmu_ops; struct xen_pmu_data *xenpmu_data; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vpmu_lock; } vpmu; unsigned __int128; union { struct pv_vcpu { struct mapcache_vcpu { u32 shadow_epoch; u32 $pad1; struct vcpu_maphash_entry hash[8l]; } mapcache; struct trap_info *trap_ctxt; unsigned long int gdt_frames[14l]; unsigned long int ldt_base; u32 gdt_ents; u32 ldt_ents; unsigned long int kernel_ss; unsigned long int kernel_sp; unsigned long int ctrlreg[8l]; unsigned long int event_callback_eip; unsigned long int failsafe_callback_eip; union { unsigned long int syscall_callback_eip; struct { u32 event_callback_cs; u32 failsafe_callback_cs; } $anon0; } $anon0; unsigned long int syscall32_callback_eip; unsigned long int sysenter_callback_eip; unsigned short int syscall32_callback_cs; unsigned short int sysenter_callback_cs; bool_t syscall32_disables_events; bool_t sysenter_disables_events; unsigned short int $pad18; unsigned long int fs_base; unsigned long int gs_base_kernel; unsigned long int gs_base_user; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } trap_bounce; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } int80_bounce; struct { u8 *p; } iobmp; u32 iobmp_limit; u32 iopl; unsigned long int shadow_ldt_mapcnt; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shadow_ldt_lock; u32 dr_mask[4l]; bool_t need_update_runstate_area; unsigned __CPROVER_bitvector[56] $pad31; struct vcpu_time_info { u32 version; u32 pad0; unsigned long int tsc_timestamp; unsigned long int system_time; u32 tsc_to_system_mul; const char tsc_shift; u8 flags; u8 pad1[2l]; } pending_system_time; } pv_vcpu; struct hvm_vcpu { unsigned long int guest_cr[5l]; unsigned long int guest_efer; unsigned long int hw_cr[5l]; struct vlapic { struct hvm_hw_lapic { unsigned long int apic_base_msr; u32 disabled; u32 timer_divisor; unsigned long int tdt_msr; } hw; struct hvm_hw_lapic_regs *regs; struct { bool_t hw; bool_t regs; unsigned short int $pad2; u32 id; u32 ldr; } loaded; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } esr_lock; u32 $pad4; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt; signed long int timer_last_update; struct page_info *regs_page; struct { u32 icr; u32 dest; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } tasklet; } init_sipi; } vlapic; signed long int cache_tsc_offset; unsigned long int guest_time; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } tm_lock; struct list_head { struct list_head *next; struct list_head *prev; } tm_list; u8 flag_dr_dirty; bool_t debug_state_latch; bool_t single_step; bool_t hcall_preempted; bool_t hcall_64bit; unsigned __CPROVER_bitvector[24] $pad13; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } n1asid; u32 msr_tsc_aux; u32 $pad16; unsigned long int msr_tsc_adjust; unsigned long int msr_xss; unsigned __CPROVER_bitvector[192] $pad19; union { struct arch_vmx_struct { unsigned long int vmcs_pa; unsigned long int vmcs_shadow_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vmcs_lock; struct list_head { struct list_head *next; struct list_head *prev; } active_list; signed int active_cpu; signed int launched; u32 exec_control; u32 secondary_exec_control; u32 exception_bitmap; u32 $pad9; struct vmx_msr_state { unsigned long int flags; unsigned long int msrs[3l]; } msr_state; unsigned long int shadow_gs; unsigned long int cstar; unsigned long int *msr_bitmap; u32 msr_count; u32 $pad15; struct vmx_msr_entry *msr_area; u32 host_msr_count; u32 $pad18; struct vmx_msr_entry *host_msr_area; unsigned long int eoi_exitmap_changed; unsigned long int eoi_exit_bitmap[4l]; struct pi_desc { unsigned long int pir[4l]; union { struct { unsigned short int on : 1; unsigned short int sn : 1; unsigned short int rsvd_1 : 14; u8 nv; u8 rsvd_2; u32 ndst; } $anon0; unsigned long int control; } $anon0; u32 rsvd[6l]; } pi_desc; unsigned long int host_cr0; bool_t ept_spurious_misconfig; u8 vmx_realmode; u8 vmx_emulate; u8 $pad27; unsigned short int vm86_segment_mask; struct segment_register vm86_saved_seg[7l]; unsigned short int $pad30; u32 vm86_saved_eflags; signed int hostenv_migrated; struct page_info *vmread_bitmap; struct page_info *vmwrite_bitmap; struct page_info *pml_pg; struct pi_blocking_vcpu { struct list_head { struct list_head *next; struct list_head *prev; } list; spinlock_t *lock; } pi_blocking; unsigned long int $pad37; } vmx; struct arch_svm_struct { struct vmcb_struct *vmcb; unsigned long int vmcb_pa; unsigned long int *msrpm; signed int launch_core; bool_t vmcb_in_sync; u8 cached_insn_len; unsigned short int $pad6; unsigned long int guest_sysenter_cs; unsigned long int guest_sysenter_esp; unsigned long int guest_sysenter_eip; unsigned long int guest_lwp_cfg; unsigned long int cpu_lwp_cfg; u32 dr_mask[4l]; struct { unsigned long int length; unsigned long int status; } osvw; } svm; } u; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } assert_evtchn_irq_tasklet; struct nestedvcpu { bool_t nv_guestmode; unsigned __CPROVER_bitvector[56] $pad1; const void *nv_vvmcx; const void *nv_n1vmcx; const void *nv_n2vmcx; unsigned long int nv_vvmcxaddr; unsigned long int nv_n1vmcx_pa; unsigned long int nv_n2vmcx_pa; union { struct nestedsvm { bool_t ns_gif; unsigned __CPROVER_bitvector[56] $pad1; unsigned long int ns_msr_hsavepa; unsigned long int ns_ovvmcb_pa; unsigned long int ns_tscratio; u32 ns_cr_intercepts; u32 ns_dr_intercepts; u32 ns_exception_intercepts; u32 ns_general1_intercepts; u32 ns_general2_intercepts; union { unsigned long int bytes; struct { unsigned long int enable : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad1 : 7; unsigned __CPROVER_bitvector[56] $pad2; } fields; } ns_lbr_control; u32 $pad11; unsigned long int *ns_cached_msrpm; unsigned long int *ns_merged_msrpm; unsigned long int ns_iomap_pa; unsigned long int ns_oiomap_pa; unsigned long int *ns_iomap; unsigned long int ns_cr0; unsigned long int ns_vmcb_guestcr3; unsigned long int ns_vmcb_hostcr3; u32 ns_guest_asid; bool_t ns_hap_enabled; unsigned __CPROVER_bitvector[24] $pad22; struct { unsigned long int exitcode; unsigned long int exitinfo1; unsigned long int exitinfo2; } ns_vmexit; union { u32 bytes; struct { u32 rflagsif : 1; u32 vintrmask : 1; u32 reserved : 30; } fields; } ns_hostflags; u32 $pad25; } nsvm; struct nestedvmx { unsigned long int vmxon_region_pa; const void *iobitmap[2l]; const void *msrbitmap; struct { unsigned long int intr_info; u32 error_code; u8 source; unsigned __CPROVER_bitvector[24] $pad3; } intr; struct { bool_t enabled; unsigned __CPROVER_bitvector[24] $pad1; u32 exit_reason; u32 exit_qual; } ept; u32 guest_vpid; struct list_head { struct list_head *next; struct list_head *prev; } launched_list; } nvmx; } u; bool_t nv_flushp2m; unsigned __CPROVER_bitvector[56] $pad10; struct p2m_domain *nv_p2m; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } nv_n2asid; bool_t nv_vmentry_pending; bool_t nv_vmexit_pending; bool_t nv_vmswitch_in_progress; bool_t nv_ioport80; bool_t nv_ioportED; unsigned __CPROVER_bitvector[24] $pad18; unsigned long int guest_cr[5l]; } nvcpu; struct altp2mvcpu { unsigned short int p2midx; unsigned __CPROVER_bitvector[48] $pad1; unsigned long int veinfo_gfn; } avcpu; struct mtrr_state { struct mtrr_var_range *var_ranges; u8 fixed_ranges[88l]; u8 enabled; u8 have_fixed; u8 def_type; unsigned __CPROVER_bitvector[40] $pad5; unsigned long int mtrr_cap; bool_t overlapped; unsigned __CPROVER_bitvector[56] $pad8; } mtrr; unsigned long int pat_cr; signed long int stime_offset; u8 evtchn_upcall_vector; u8 cache_mode; unsigned __CPROVER_bitvector[48] $pad29; struct hvm_vcpu_io { enum hvm_io_completion io_completion; u32 $pad1; struct ioreq { unsigned long int addr; unsigned long int data; u32 count; u32 size; u32 vp_eport; unsigned short int _pad0; u8 state : 4; u8 data_is_ptr : 1; u8 dir : 1; u8 df : 1; u8 _pad1 : 1; u8 type; } io_req; struct npfec { u32 read_access : 1; u32 write_access : 1; u32 insn_fetch : 1; u32 present : 1; u32 gla_valid : 1; u32 kind : 2; unsigned __CPROVER_bitvector[1] $bit_field_pad6 : 1; unsigned __CPROVER_bitvector[24] $pad7; } mmio_access; u32 $pad4; unsigned long int mmio_gla; unsigned long int mmio_gpfn; struct hvm_mmio_cache mmio_cache[3l]; u32 mmio_cache_count; u32 mmio_insn_bytes; xen_domain_handle_t mmio_insn; bool_t mmio_retry; unsigned __CPROVER_bitvector[56] $pad12; unsigned long int msix_unmask_address; unsigned long int msix_snoop_address; unsigned long int msix_snoop_gpa; const struct g2m_ioport *g2m_ioport; } hvm_io; const void (*fpu_exception_callback)(const void *, struct cpu_user_regs *); const void *fpu_exception_callback_arg; struct hvm_trap { s16 vector; u8 type; u8 insn_len; u32 error_code; unsigned long int cr2; } inject_trap; struct viridian_vcpu { struct { union viridian_apic_assist { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } msr; const void *va; signed int vector; u32 $pad3; } apic_assist; } viridian; } hvm_vcpu; } $anon0; struct { unsigned long int pfn; } guest_table_user; struct { unsigned long int pfn; } guest_table; struct page_info *old_guest_table; pagetable_t shadow_table[4l]; struct { unsigned long int pfn; } monitor_table; unsigned long int cr3; struct xsave_struct *xsave_area; unsigned long int xcr0; unsigned long int xcr0_accum; bool_t nonlazy_xstate_used; bool_t cpuid_faulting; smap_check_policy_t smap_check_policy; unsigned __CPROVER_bitvector[40] $pad23; struct vmce { unsigned long int mcg_cap; unsigned long int mcg_status; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct vmce_bank bank[2l]; } vmce; struct paging_vcpu { const struct paging_mode *mode; const struct paging_mode *nestedmode; u32 last_write_was_pt : 1; u32 last_write_emul_ok : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad4 : 6; unsigned __CPROVER_bitvector[56] $pad5; struct shadow_vtlb *vtlb; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtlb_lock; unsigned __CPROVER_bitvector[192] $pad8; struct shadow_vcpu { l3_pgentry_t l3table[4l]; l3_pgentry_t gl3e[4l]; const void *guest_vtable; unsigned long int last_emulated_mfn_for_unshadow; unsigned long int last_writeable_pte_smfn; unsigned long int last_emulated_frame; unsigned long int last_emulated_mfn; unsigned long int oos[3l]; unsigned long int oos_snapshot[3l]; struct oos_fixup oos_fixup[3l]; bool_t pagetable_dying; unsigned __CPROVER_bitvector[120] $pad11; } shadow; } paging; u32 gdbsx_vcpu_event; u32 $pad27; struct { vcpu_time_info_t *p; } time_info_guest; struct arch_vm_event *vm_event; unsigned long int $pad30; } arch; } *)NULL) (0x0)

#### Function call: get_cpu_info$link17$link2() (depth 3) ####

#### Function return: get_cpu_info$link17$link2 (depth 2) ####

State 974 file mm.c line 3107 function do_mmuext_op thread 0
----------------------------------------------------
curr = return_value_get_cpu_info->current_vcpu;
----------------------------------------------------
  curr=((struct vcpu { signed int vcpu_id; signed int processor; vcpu_info_t *vcpu_info; struct domain *domain; struct vcpu *next_in_list; signed long int periodic_period; signed long int periodic_last_event; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } periodic_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } singleshot_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } poll_timer; const void *sched_priv; struct vcpu_runstate_info { signed int state; u32 $pad1; unsigned long int state_entry_time; unsigned long int time[4l]; } runstate; union { struct { vcpu_runstate_info_t *p; } native; struct { vcpu_runstate_info_compat_t *p; } compat; } runstate_guest; unsigned long int last_run_time; bool_t fpu_initialised; bool_t fpu_dirtied; bool_t is_initialised; bool_t is_running; bool_t is_urgent; struct async_exception_state[2l]; u8 async_exception_mask; bool_t defer_shutdown; bool_t paused_for_shutdown; bool_t affinity_broken; unsigned __CPROVER_bitvector[24] $pad24; signed int poll_evtchn; signed int pirq_evtchn_head; unsigned long int pause_flags; struct { signed int counter; } pause_count; struct { signed int counter; } vm_event_pause_count; signed int controller_pause_count; u32 maptrack_head; u32 maptrack_tail; u32 virq_to_evtchn[24l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } virq_lock; u32 $pad35; const cpumask_t *cpu_hard_affinity; const cpumask_t *cpu_hard_affinity_tmp; const cpumask_t *cpu_hard_affinity_saved; const cpumask_t *cpu_soft_affinity; const cpumask_t *vcpu_dirty_cpumask; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } continue_hypercall_tasklet; struct mc_state { unsigned long int flags; union { struct multicall_entry { unsigned long int op; unsigned long int result; unsigned long int args[6l]; } call; struct compat_multicall_entry { u32 op; u32 result; u32 args[6l]; } compat_call; } $anon0; } mc_state; struct waitqueue_vcpu *waitqueue_vcpu; unsigned long int vcpu_info_mfn; struct evtchn_fifo_vcpu *evtchn_fifo; unsigned __CPROVER_bitvector[320] $pad46; struct arch_vcpu { const void *fpu_ctxt; unsigned long int vgc_flags; struct cpu_user_regs { unsigned long int r15; unsigned long int r14; unsigned long int r13; unsigned long int r12; union { unsigned long int rbp; unsigned long int ebp; u32 _ebp; } $anon0; union { unsigned long int rbx; unsigned long int ebx; u32 _ebx; } $anon1; unsigned long int r11; unsigned long int r10; unsigned long int r9; unsigned long int r8; union { unsigned long int rax; unsigned long int eax; u32 _eax; } $anon2; union { unsigned long int rcx; unsigned long int ecx; u32 _ecx; } $anon3; union { unsigned long int rdx; unsigned long int edx; u32 _edx; } $anon4; union { unsigned long int rsi; unsigned long int esi; u32 _esi; } $anon5; union { unsigned long int rdi; unsigned long int edi; u32 _edi; } $anon6; u32 error_code; u32 entry_vector; union { unsigned long int rip; unsigned long int eip; u32 _eip; } $anon7; unsigned short int cs; unsigned short int _pad0[1l]; u8 saved_upcall_mask; u8 _pad1[3l]; union { unsigned long int rflags; unsigned long int eflags; u32 _eflags; } $anon8; union { unsigned long int rsp; unsigned long int esp; u32 _esp; } $anon9; unsigned short int ss; unsigned short int _pad2[3l]; unsigned short int es; unsigned short int _pad3[3l]; unsigned short int ds; unsigned short int _pad4[3l]; unsigned short int fs; unsigned short int _pad5[3l]; unsigned short int gs; unsigned short int _pad6[3l]; } user_regs; unsigned long int debugreg[8l]; unsigned long int flags; const void (*schedule_tail)(struct vcpu *); const void (*ctxt_switch_from)(struct vcpu *); const void (*ctxt_switch_to)(struct vcpu *); struct vpmu_struct { u32 flags; u32 last_pcpu; u32 hw_lapic_lvtpc; u32 $pad3; const void *context; const void *priv_context; struct arch_vpmu_ops *arch_vpmu_ops; struct xen_pmu_data *xenpmu_data; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vpmu_lock; } vpmu; unsigned __int128; union { struct pv_vcpu { struct mapcache_vcpu { u32 shadow_epoch; u32 $pad1; struct vcpu_maphash_entry hash[8l]; } mapcache; struct trap_info *trap_ctxt; unsigned long int gdt_frames[14l]; unsigned long int ldt_base; u32 gdt_ents; u32 ldt_ents; unsigned long int kernel_ss; unsigned long int kernel_sp; unsigned long int ctrlreg[8l]; unsigned long int event_callback_eip; unsigned long int failsafe_callback_eip; union { unsigned long int syscall_callback_eip; struct { u32 event_callback_cs; u32 failsafe_callback_cs; } $anon0; } $anon0; unsigned long int syscall32_callback_eip; unsigned long int sysenter_callback_eip; unsigned short int syscall32_callback_cs; unsigned short int sysenter_callback_cs; bool_t syscall32_disables_events; bool_t sysenter_disables_events; unsigned short int $pad18; unsigned long int fs_base; unsigned long int gs_base_kernel; unsigned long int gs_base_user; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } trap_bounce; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } int80_bounce; struct { u8 *p; } iobmp; u32 iobmp_limit; u32 iopl; unsigned long int shadow_ldt_mapcnt; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shadow_ldt_lock; u32 dr_mask[4l]; bool_t need_update_runstate_area; unsigned __CPROVER_bitvector[56] $pad31; struct vcpu_time_info { u32 version; u32 pad0; unsigned long int tsc_timestamp; unsigned long int system_time; u32 tsc_to_system_mul; const char tsc_shift; u8 flags; u8 pad1[2l]; } pending_system_time; } pv_vcpu; struct hvm_vcpu { unsigned long int guest_cr[5l]; unsigned long int guest_efer; unsigned long int hw_cr[5l]; struct vlapic { struct hvm_hw_lapic { unsigned long int apic_base_msr; u32 disabled; u32 timer_divisor; unsigned long int tdt_msr; } hw; struct hvm_hw_lapic_regs *regs; struct { bool_t hw; bool_t regs; unsigned short int $pad2; u32 id; u32 ldr; } loaded; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } esr_lock; u32 $pad4; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt; signed long int timer_last_update; struct page_info *regs_page; struct { u32 icr; u32 dest; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } tasklet; } init_sipi; } vlapic; signed long int cache_tsc_offset; unsigned long int guest_time; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } tm_lock; struct list_head { struct list_head *next; struct list_head *prev; } tm_list; u8 flag_dr_dirty; bool_t debug_state_latch; bool_t single_step; bool_t hcall_preempted; bool_t hcall_64bit; unsigned __CPROVER_bitvector[24] $pad13; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } n1asid; u32 msr_tsc_aux; u32 $pad16; unsigned long int msr_tsc_adjust; unsigned long int msr_xss; unsigned __CPROVER_bitvector[192] $pad19; union { struct arch_vmx_struct { unsigned long int vmcs_pa; unsigned long int vmcs_shadow_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vmcs_lock; struct list_head { struct list_head *next; struct list_head *prev; } active_list; signed int active_cpu; signed int launched; u32 exec_control; u32 secondary_exec_control; u32 exception_bitmap; u32 $pad9; struct vmx_msr_state { unsigned long int flags; unsigned long int msrs[3l]; } msr_state; unsigned long int shadow_gs; unsigned long int cstar; unsigned long int *msr_bitmap; u32 msr_count; u32 $pad15; struct vmx_msr_entry *msr_area; u32 host_msr_count; u32 $pad18; struct vmx_msr_entry *host_msr_area; unsigned long int eoi_exitmap_changed; unsigned long int eoi_exit_bitmap[4l]; struct pi_desc { unsigned long int pir[4l]; union { struct { unsigned short int on : 1; unsigned short int sn : 1; unsigned short int rsvd_1 : 14; u8 nv; u8 rsvd_2; u32 ndst; } $anon0; unsigned long int control; } $anon0; u32 rsvd[6l]; } pi_desc; unsigned long int host_cr0; bool_t ept_spurious_misconfig; u8 vmx_realmode; u8 vmx_emulate; u8 $pad27; unsigned short int vm86_segment_mask; struct segment_register vm86_saved_seg[7l]; unsigned short int $pad30; u32 vm86_saved_eflags; signed int hostenv_migrated; struct page_info *vmread_bitmap; struct page_info *vmwrite_bitmap; struct page_info *pml_pg; struct pi_blocking_vcpu { struct list_head { struct list_head *next; struct list_head *prev; } list; spinlock_t *lock; } pi_blocking; unsigned long int $pad37; } vmx; struct arch_svm_struct { struct vmcb_struct *vmcb; unsigned long int vmcb_pa; unsigned long int *msrpm; signed int launch_core; bool_t vmcb_in_sync; u8 cached_insn_len; unsigned short int $pad6; unsigned long int guest_sysenter_cs; unsigned long int guest_sysenter_esp; unsigned long int guest_sysenter_eip; unsigned long int guest_lwp_cfg; unsigned long int cpu_lwp_cfg; u32 dr_mask[4l]; struct { unsigned long int length; unsigned long int status; } osvw; } svm; } u; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } assert_evtchn_irq_tasklet; struct nestedvcpu { bool_t nv_guestmode; unsigned __CPROVER_bitvector[56] $pad1; const void *nv_vvmcx; const void *nv_n1vmcx; const void *nv_n2vmcx; unsigned long int nv_vvmcxaddr; unsigned long int nv_n1vmcx_pa; unsigned long int nv_n2vmcx_pa; union { struct nestedsvm { bool_t ns_gif; unsigned __CPROVER_bitvector[56] $pad1; unsigned long int ns_msr_hsavepa; unsigned long int ns_ovvmcb_pa; unsigned long int ns_tscratio; u32 ns_cr_intercepts; u32 ns_dr_intercepts; u32 ns_exception_intercepts; u32 ns_general1_intercepts; u32 ns_general2_intercepts; union { unsigned long int bytes; struct { unsigned long int enable : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad1 : 7; unsigned __CPROVER_bitvector[56] $pad2; } fields; } ns_lbr_control; u32 $pad11; unsigned long int *ns_cached_msrpm; unsigned long int *ns_merged_msrpm; unsigned long int ns_iomap_pa; unsigned long int ns_oiomap_pa; unsigned long int *ns_iomap; unsigned long int ns_cr0; unsigned long int ns_vmcb_guestcr3; unsigned long int ns_vmcb_hostcr3; u32 ns_guest_asid; bool_t ns_hap_enabled; unsigned __CPROVER_bitvector[24] $pad22; struct { unsigned long int exitcode; unsigned long int exitinfo1; unsigned long int exitinfo2; } ns_vmexit; union { u32 bytes; struct { u32 rflagsif : 1; u32 vintrmask : 1; u32 reserved : 30; } fields; } ns_hostflags; u32 $pad25; } nsvm; struct nestedvmx { unsigned long int vmxon_region_pa; const void *iobitmap[2l]; const void *msrbitmap; struct { unsigned long int intr_info; u32 error_code; u8 source; unsigned __CPROVER_bitvector[24] $pad3; } intr; struct { bool_t enabled; unsigned __CPROVER_bitvector[24] $pad1; u32 exit_reason; u32 exit_qual; } ept; u32 guest_vpid; struct list_head { struct list_head *next; struct list_head *prev; } launched_list; } nvmx; } u; bool_t nv_flushp2m; unsigned __CPROVER_bitvector[56] $pad10; struct p2m_domain *nv_p2m; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } nv_n2asid; bool_t nv_vmentry_pending; bool_t nv_vmexit_pending; bool_t nv_vmswitch_in_progress; bool_t nv_ioport80; bool_t nv_ioportED; unsigned __CPROVER_bitvector[24] $pad18; unsigned long int guest_cr[5l]; } nvcpu; struct altp2mvcpu { unsigned short int p2midx; unsigned __CPROVER_bitvector[48] $pad1; unsigned long int veinfo_gfn; } avcpu; struct mtrr_state { struct mtrr_var_range *var_ranges; u8 fixed_ranges[88l]; u8 enabled; u8 have_fixed; u8 def_type; unsigned __CPROVER_bitvector[40] $pad5; unsigned long int mtrr_cap; bool_t overlapped; unsigned __CPROVER_bitvector[56] $pad8; } mtrr; unsigned long int pat_cr; signed long int stime_offset; u8 evtchn_upcall_vector; u8 cache_mode; unsigned __CPROVER_bitvector[48] $pad29; struct hvm_vcpu_io { enum hvm_io_completion io_completion; u32 $pad1; struct ioreq { unsigned long int addr; unsigned long int data; u32 count; u32 size; u32 vp_eport; unsigned short int _pad0; u8 state : 4; u8 data_is_ptr : 1; u8 dir : 1; u8 df : 1; u8 _pad1 : 1; u8 type; } io_req; struct npfec { u32 read_access : 1; u32 write_access : 1; u32 insn_fetch : 1; u32 present : 1; u32 gla_valid : 1; u32 kind : 2; unsigned __CPROVER_bitvector[1] $bit_field_pad6 : 1; unsigned __CPROVER_bitvector[24] $pad7; } mmio_access; u32 $pad4; unsigned long int mmio_gla; unsigned long int mmio_gpfn; struct hvm_mmio_cache mmio_cache[3l]; u32 mmio_cache_count; u32 mmio_insn_bytes; xen_domain_handle_t mmio_insn; bool_t mmio_retry; unsigned __CPROVER_bitvector[56] $pad12; unsigned long int msix_unmask_address; unsigned long int msix_snoop_address; unsigned long int msix_snoop_gpa; const struct g2m_ioport *g2m_ioport; } hvm_io; const void (*fpu_exception_callback)(const void *, struct cpu_user_regs *); const void *fpu_exception_callback_arg; struct hvm_trap { s16 vector; u8 type; u8 insn_len; u32 error_code; unsigned long int cr2; } inject_trap; struct viridian_vcpu { struct { union viridian_apic_assist { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } msr; const void *va; signed int vector; u32 $pad3; } apic_assist; } viridian; } hvm_vcpu; } $anon0; struct { unsigned long int pfn; } guest_table_user; struct { unsigned long int pfn; } guest_table; struct page_info *old_guest_table; pagetable_t shadow_table[4l]; struct { unsigned long int pfn; } monitor_table; unsigned long int cr3; struct xsave_struct *xsave_area; unsigned long int xcr0; unsigned long int xcr0_accum; bool_t nonlazy_xstate_used; bool_t cpuid_faulting; smap_check_policy_t smap_check_policy; unsigned __CPROVER_bitvector[40] $pad23; struct vmce { unsigned long int mcg_cap; unsigned long int mcg_status; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct vmce_bank bank[2l]; } vmce; struct paging_vcpu { const struct paging_mode *mode; const struct paging_mode *nestedmode; u32 last_write_was_pt : 1; u32 last_write_emul_ok : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad4 : 6; unsigned __CPROVER_bitvector[56] $pad5; struct shadow_vtlb *vtlb; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtlb_lock; unsigned __CPROVER_bitvector[192] $pad8; struct shadow_vcpu { l3_pgentry_t l3table[4l]; l3_pgentry_t gl3e[4l]; const void *guest_vtable; unsigned long int last_emulated_mfn_for_unshadow; unsigned long int last_writeable_pte_smfn; unsigned long int last_emulated_frame; unsigned long int last_emulated_mfn; unsigned long int oos[3l]; unsigned long int oos_snapshot[3l]; struct oos_fixup oos_fixup[3l]; bool_t pagetable_dying; unsigned __CPROVER_bitvector[120] $pad11; } shadow; } paging; u32 gdbsx_vcpu_event; u32 $pad27; struct { vcpu_time_info_t *p; } time_info_guest; struct arch_vm_event *vm_event; unsigned long int $pad30; } arch; } *)NULL) (0x0)

State 975 file mm.c line 3108 function do_mmuext_op thread 0
----------------------------------------------------
struct domain *d;
----------------------------------------------------
  d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 976 file mm.c line 3108 function do_mmuext_op thread 0
----------------------------------------------------
d = curr->domain;
----------------------------------------------------
  d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) + 1l (0x1)

State 977 file mm.c line 3109 function do_mmuext_op thread 0
----------------------------------------------------
struct domain *pg_owner;
----------------------------------------------------
  pg_owner=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 978 file mm.c line 3110 function do_mmuext_op thread 0
----------------------------------------------------
signed int rc;
----------------------------------------------------
  rc=0 (0x0)

#### Function call: put_old_guest_table(((struct vcpu { signed int vcpu_id; signed int processor; vcpu_info_t *vcpu_info; struct domain *domain; struct vcpu *next_in_list; signed long int periodic_period; signed long int periodic_last_event; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } periodic_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } singleshot_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } poll_timer; const void *sched_priv; struct vcpu_runstate_info { signed int state; u32 $pad1; unsigned long int state_entry_time; unsigned long int time[4l]; } runstate; union { struct { vcpu_runstate_info_t *p; } native; struct { vcpu_runstate_info_compat_t *p; } compat; } runstate_guest; unsigned long int last_run_time; bool_t fpu_initialised; bool_t fpu_dirtied; bool_t is_initialised; bool_t is_running; bool_t is_urgent; struct async_exception_state[2l]; u8 async_exception_mask; bool_t defer_shutdown; bool_t paused_for_shutdown; bool_t affinity_broken; unsigned __CPROVER_bitvector[24] $pad24; signed int poll_evtchn; signed int pirq_evtchn_head; unsigned long int pause_flags; struct { signed int counter; } pause_count; struct { signed int counter; } vm_event_pause_count; signed int controller_pause_count; u32 maptrack_head; u32 maptrack_tail; u32 virq_to_evtchn[24l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } virq_lock; u32 $pad35; const cpumask_t *cpu_hard_affinity; const cpumask_t *cpu_hard_affinity_tmp; const cpumask_t *cpu_hard_affinity_saved; const cpumask_t *cpu_soft_affinity; const cpumask_t *vcpu_dirty_cpumask; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } continue_hypercall_tasklet; struct mc_state { unsigned long int flags; union { struct multicall_entry { unsigned long int op; unsigned long int result; unsigned long int args[6l]; } call; struct compat_multicall_entry { u32 op; u32 result; u32 args[6l]; } compat_call; } $anon0; } mc_state; struct waitqueue_vcpu *waitqueue_vcpu; unsigned long int vcpu_info_mfn; struct evtchn_fifo_vcpu *evtchn_fifo; unsigned __CPROVER_bitvector[320] $pad46; struct arch_vcpu { const void *fpu_ctxt; unsigned long int vgc_flags; struct cpu_user_regs { unsigned long int r15; unsigned long int r14; unsigned long int r13; unsigned long int r12; union { unsigned long int rbp; unsigned long int ebp; u32 _ebp; } $anon0; union { unsigned long int rbx; unsigned long int ebx; u32 _ebx; } $anon1; unsigned long int r11; unsigned long int r10; unsigned long int r9; unsigned long int r8; union { unsigned long int rax; unsigned long int eax; u32 _eax; } $anon2; union { unsigned long int rcx; unsigned long int ecx; u32 _ecx; } $anon3; union { unsigned long int rdx; unsigned long int edx; u32 _edx; } $anon4; union { unsigned long int rsi; unsigned long int esi; u32 _esi; } $anon5; union { unsigned long int rdi; unsigned long int edi; u32 _edi; } $anon6; u32 error_code; u32 entry_vector; union { unsigned long int rip; unsigned long int eip; u32 _eip; } $anon7; unsigned short int cs; unsigned short int _pad0[1l]; u8 saved_upcall_mask; u8 _pad1[3l]; union { unsigned long int rflags; unsigned long int eflags; u32 _eflags; } $anon8; union { unsigned long int rsp; unsigned long int esp; u32 _esp; } $anon9; unsigned short int ss; unsigned short int _pad2[3l]; unsigned short int es; unsigned short int _pad3[3l]; unsigned short int ds; unsigned short int _pad4[3l]; unsigned short int fs; unsigned short int _pad5[3l]; unsigned short int gs; unsigned short int _pad6[3l]; } user_regs; unsigned long int debugreg[8l]; unsigned long int flags; const void (*schedule_tail)(struct vcpu *); const void (*ctxt_switch_from)(struct vcpu *); const void (*ctxt_switch_to)(struct vcpu *); struct vpmu_struct { u32 flags; u32 last_pcpu; u32 hw_lapic_lvtpc; u32 $pad3; const void *context; const void *priv_context; struct arch_vpmu_ops *arch_vpmu_ops; struct xen_pmu_data *xenpmu_data; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vpmu_lock; } vpmu; unsigned __int128; union { struct pv_vcpu { struct mapcache_vcpu { u32 shadow_epoch; u32 $pad1; struct vcpu_maphash_entry hash[8l]; } mapcache; struct trap_info *trap_ctxt; unsigned long int gdt_frames[14l]; unsigned long int ldt_base; u32 gdt_ents; u32 ldt_ents; unsigned long int kernel_ss; unsigned long int kernel_sp; unsigned long int ctrlreg[8l]; unsigned long int event_callback_eip; unsigned long int failsafe_callback_eip; union { unsigned long int syscall_callback_eip; struct { u32 event_callback_cs; u32 failsafe_callback_cs; } $anon0; } $anon0; unsigned long int syscall32_callback_eip; unsigned long int sysenter_callback_eip; unsigned short int syscall32_callback_cs; unsigned short int sysenter_callback_cs; bool_t syscall32_disables_events; bool_t sysenter_disables_events; unsigned short int $pad18; unsigned long int fs_base; unsigned long int gs_base_kernel; unsigned long int gs_base_user; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } trap_bounce; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } int80_bounce; struct { u8 *p; } iobmp; u32 iobmp_limit; u32 iopl; unsigned long int shadow_ldt_mapcnt; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shadow_ldt_lock; u32 dr_mask[4l]; bool_t need_update_runstate_area; unsigned __CPROVER_bitvector[56] $pad31; struct vcpu_time_info { u32 version; u32 pad0; unsigned long int tsc_timestamp; unsigned long int system_time; u32 tsc_to_system_mul; const char tsc_shift; u8 flags; u8 pad1[2l]; } pending_system_time; } pv_vcpu; struct hvm_vcpu { unsigned long int guest_cr[5l]; unsigned long int guest_efer; unsigned long int hw_cr[5l]; struct vlapic { struct hvm_hw_lapic { unsigned long int apic_base_msr; u32 disabled; u32 timer_divisor; unsigned long int tdt_msr; } hw; struct hvm_hw_lapic_regs *regs; struct { bool_t hw; bool_t regs; unsigned short int $pad2; u32 id; u32 ldr; } loaded; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } esr_lock; u32 $pad4; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt; signed long int timer_last_update; struct page_info *regs_page; struct { u32 icr; u32 dest; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } tasklet; } init_sipi; } vlapic; signed long int cache_tsc_offset; unsigned long int guest_time; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } tm_lock; struct list_head { struct list_head *next; struct list_head *prev; } tm_list; u8 flag_dr_dirty; bool_t debug_state_latch; bool_t single_step; bool_t hcall_preempted; bool_t hcall_64bit; unsigned __CPROVER_bitvector[24] $pad13; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } n1asid; u32 msr_tsc_aux; u32 $pad16; unsigned long int msr_tsc_adjust; unsigned long int msr_xss; unsigned __CPROVER_bitvector[192] $pad19; union { struct arch_vmx_struct { unsigned long int vmcs_pa; unsigned long int vmcs_shadow_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vmcs_lock; struct list_head { struct list_head *next; struct list_head *prev; } active_list; signed int active_cpu; signed int launched; u32 exec_control; u32 secondary_exec_control; u32 exception_bitmap; u32 $pad9; struct vmx_msr_state { unsigned long int flags; unsigned long int msrs[3l]; } msr_state; unsigned long int shadow_gs; unsigned long int cstar; unsigned long int *msr_bitmap; u32 msr_count; u32 $pad15; struct vmx_msr_entry *msr_area; u32 host_msr_count; u32 $pad18; struct vmx_msr_entry *host_msr_area; unsigned long int eoi_exitmap_changed; unsigned long int eoi_exit_bitmap[4l]; struct pi_desc { unsigned long int pir[4l]; union { struct { unsigned short int on : 1; unsigned short int sn : 1; unsigned short int rsvd_1 : 14; u8 nv; u8 rsvd_2; u32 ndst; } $anon0; unsigned long int control; } $anon0; u32 rsvd[6l]; } pi_desc; unsigned long int host_cr0; bool_t ept_spurious_misconfig; u8 vmx_realmode; u8 vmx_emulate; u8 $pad27; unsigned short int vm86_segment_mask; struct segment_register vm86_saved_seg[7l]; unsigned short int $pad30; u32 vm86_saved_eflags; signed int hostenv_migrated; struct page_info *vmread_bitmap; struct page_info *vmwrite_bitmap; struct page_info *pml_pg; struct pi_blocking_vcpu { struct list_head { struct list_head *next; struct list_head *prev; } list; spinlock_t *lock; } pi_blocking; unsigned long int $pad37; } vmx; struct arch_svm_struct { struct vmcb_struct *vmcb; unsigned long int vmcb_pa; unsigned long int *msrpm; signed int launch_core; bool_t vmcb_in_sync; u8 cached_insn_len; unsigned short int $pad6; unsigned long int guest_sysenter_cs; unsigned long int guest_sysenter_esp; unsigned long int guest_sysenter_eip; unsigned long int guest_lwp_cfg; unsigned long int cpu_lwp_cfg; u32 dr_mask[4l]; struct { unsigned long int length; unsigned long int status; } osvw; } svm; } u; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } assert_evtchn_irq_tasklet; struct nestedvcpu { bool_t nv_guestmode; unsigned __CPROVER_bitvector[56] $pad1; const void *nv_vvmcx; const void *nv_n1vmcx; const void *nv_n2vmcx; unsigned long int nv_vvmcxaddr; unsigned long int nv_n1vmcx_pa; unsigned long int nv_n2vmcx_pa; union { struct nestedsvm { bool_t ns_gif; unsigned __CPROVER_bitvector[56] $pad1; unsigned long int ns_msr_hsavepa; unsigned long int ns_ovvmcb_pa; unsigned long int ns_tscratio; u32 ns_cr_intercepts; u32 ns_dr_intercepts; u32 ns_exception_intercepts; u32 ns_general1_intercepts; u32 ns_general2_intercepts; union { unsigned long int bytes; struct { unsigned long int enable : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad1 : 7; unsigned __CPROVER_bitvector[56] $pad2; } fields; } ns_lbr_control; u32 $pad11; unsigned long int *ns_cached_msrpm; unsigned long int *ns_merged_msrpm; unsigned long int ns_iomap_pa; unsigned long int ns_oiomap_pa; unsigned long int *ns_iomap; unsigned long int ns_cr0; unsigned long int ns_vmcb_guestcr3; unsigned long int ns_vmcb_hostcr3; u32 ns_guest_asid; bool_t ns_hap_enabled; unsigned __CPROVER_bitvector[24] $pad22; struct { unsigned long int exitcode; unsigned long int exitinfo1; unsigned long int exitinfo2; } ns_vmexit; union { u32 bytes; struct { u32 rflagsif : 1; u32 vintrmask : 1; u32 reserved : 30; } fields; } ns_hostflags; u32 $pad25; } nsvm; struct nestedvmx { unsigned long int vmxon_region_pa; const void *iobitmap[2l]; const void *msrbitmap; struct { unsigned long int intr_info; u32 error_code; u8 source; unsigned __CPROVER_bitvector[24] $pad3; } intr; struct { bool_t enabled; unsigned __CPROVER_bitvector[24] $pad1; u32 exit_reason; u32 exit_qual; } ept; u32 guest_vpid; struct list_head { struct list_head *next; struct list_head *prev; } launched_list; } nvmx; } u; bool_t nv_flushp2m; unsigned __CPROVER_bitvector[56] $pad10; struct p2m_domain *nv_p2m; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } nv_n2asid; bool_t nv_vmentry_pending; bool_t nv_vmexit_pending; bool_t nv_vmswitch_in_progress; bool_t nv_ioport80; bool_t nv_ioportED; unsigned __CPROVER_bitvector[24] $pad18; unsigned long int guest_cr[5l]; } nvcpu; struct altp2mvcpu { unsigned short int p2midx; unsigned __CPROVER_bitvector[48] $pad1; unsigned long int veinfo_gfn; } avcpu; struct mtrr_state { struct mtrr_var_range *var_ranges; u8 fixed_ranges[88l]; u8 enabled; u8 have_fixed; u8 def_type; unsigned __CPROVER_bitvector[40] $pad5; unsigned long int mtrr_cap; bool_t overlapped; unsigned __CPROVER_bitvector[56] $pad8; } mtrr; unsigned long int pat_cr; signed long int stime_offset; u8 evtchn_upcall_vector; u8 cache_mode; unsigned __CPROVER_bitvector[48] $pad29; struct hvm_vcpu_io { enum hvm_io_completion io_completion; u32 $pad1; struct ioreq { unsigned long int addr; unsigned long int data; u32 count; u32 size; u32 vp_eport; unsigned short int _pad0; u8 state : 4; u8 data_is_ptr : 1; u8 dir : 1; u8 df : 1; u8 _pad1 : 1; u8 type; } io_req; struct npfec { u32 read_access : 1; u32 write_access : 1; u32 insn_fetch : 1; u32 present : 1; u32 gla_valid : 1; u32 kind : 2; unsigned __CPROVER_bitvector[1] $bit_field_pad6 : 1; unsigned __CPROVER_bitvector[24] $pad7; } mmio_access; u32 $pad4; unsigned long int mmio_gla; unsigned long int mmio_gpfn; struct hvm_mmio_cache mmio_cache[3l]; u32 mmio_cache_count; u32 mmio_insn_bytes; xen_domain_handle_t mmio_insn; bool_t mmio_retry; unsigned __CPROVER_bitvector[56] $pad12; unsigned long int msix_unmask_address; unsigned long int msix_snoop_address; unsigned long int msix_snoop_gpa; const struct g2m_ioport *g2m_ioport; } hvm_io; const void (*fpu_exception_callback)(const void *, struct cpu_user_regs *); const void *fpu_exception_callback_arg; struct hvm_trap { s16 vector; u8 type; u8 insn_len; u32 error_code; unsigned long int cr2; } inject_trap; struct viridian_vcpu { struct { union viridian_apic_assist { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } msr; const void *va; signed int vector; u32 $pad3; } apic_assist; } viridian; } hvm_vcpu; } $anon0; struct { unsigned long int pfn; } guest_table_user; struct { unsigned long int pfn; } guest_table; struct page_info *old_guest_table; pagetable_t shadow_table[4l]; struct { unsigned long int pfn; } monitor_table; unsigned long int cr3; struct xsave_struct *xsave_area; unsigned long int xcr0; unsigned long int xcr0_accum; bool_t nonlazy_xstate_used; bool_t cpuid_faulting; smap_check_policy_t smap_check_policy; unsigned __CPROVER_bitvector[40] $pad23; struct vmce { unsigned long int mcg_cap; unsigned long int mcg_status; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct vmce_bank bank[2l]; } vmce; struct paging_vcpu { const struct paging_mode *mode; const struct paging_mode *nestedmode; u32 last_write_was_pt : 1; u32 last_write_emul_ok : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad4 : 6; unsigned __CPROVER_bitvector[56] $pad5; struct shadow_vtlb *vtlb; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtlb_lock; unsigned __CPROVER_bitvector[192] $pad8; struct shadow_vcpu { l3_pgentry_t l3table[4l]; l3_pgentry_t gl3e[4l]; const void *guest_vtable; unsigned long int last_emulated_mfn_for_unshadow; unsigned long int last_writeable_pte_smfn; unsigned long int last_emulated_frame; unsigned long int last_emulated_mfn; unsigned long int oos[3l]; unsigned long int oos_snapshot[3l]; struct oos_fixup oos_fixup[3l]; bool_t pagetable_dying; unsigned __CPROVER_bitvector[120] $pad11; } shadow; } paging; u32 gdbsx_vcpu_event; u32 $pad27; struct { vcpu_time_info_t *p; } time_info_guest; struct arch_vm_event *vm_event; unsigned long int $pad30; } arch; } *)NULL)) (depth 3) ####

#### Function return: put_old_guest_table (depth 2) ####

State 982 file mm.c line 3110 function do_mmuext_op thread 0
----------------------------------------------------
put_old_guest_table(curr);
----------------------------------------------------
  curr$object={ .vcpu_id=0, .processor=0, .vcpu_info=((vcpu_info_t *)NULL), .domain=((struct domain *)NULL),
    .next_in_list=((struct vcpu *)NULL), .periodic_period=0l,
    .periodic_last_event=0l, .periodic_timer={ .expires=0l, .$anon0={ .heap_offset=0u }, .function=((const void (*)(const void *))NULL),
    .data=NULL,
    .cpu=0, .status=0, .$pad6=0 },
    .singleshot_timer={ .expires=0l, .$anon0={ .heap_offset=0u }, .function=((const void (*)(const void *))NULL),
    .data=NULL,
    .cpu=0, .status=0, .$pad6=0 },
    .poll_timer={ .expires=0l, .$anon0={ .heap_offset=0u }, .function=((const void (*)(const void *))NULL),
    .data=NULL,
    .cpu=0, .status=0, .$pad6=0 },
    .sched_priv=NULL,
    .runstate={ .state=0, .$pad1=0u, .state_entry_time=0ul, .time={ 0ul, 0ul, 0ul, 0ul } }, .runstate_guest={ .native={ .p=((vcpu_runstate_info_t *)NULL) } },
    .last_run_time=0ul,
    .fpu_initialised=FALSE, .fpu_dirtied=FALSE,
    .is_initialised=FALSE, .is_running=FALSE,
    .is_urgent=FALSE, .async_exception_state={ ,  },
    .async_exception_mask=0, .defer_shutdown=FALSE,
    .paused_for_shutdown=FALSE, .affinity_broken=FALSE,
    .$pad24=0, .poll_evtchn=0, .pirq_evtchn_head=0,
    .pause_flags=0ul, .pause_count={ .counter=0 },
    .vm_event_pause_count={ .counter=0 }, .controller_pause_count=0,
    .maptrack_head=0u, .maptrack_tail=0u,
    .virq_to_evtchn={ 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u }, .virq_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .$pad35=0u,
    .cpu_hard_affinity=((const cpumask_t *)NULL), .cpu_hard_affinity_tmp=((const cpumask_t *)NULL),
    .cpu_hard_affinity_saved=((const cpumask_t *)NULL),
    .cpu_soft_affinity=((const cpumask_t *)NULL),
    .vcpu_dirty_cpumask=((const cpumask_t *)NULL),
    .continue_hypercall_tasklet={ .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .scheduled_on=0,
    .is_softirq=FALSE, .is_running=FALSE, .is_dead=FALSE,
    .$pad5=0, .func=((const void (*)(unsigned long int))NULL), .data=0ul },
    .mc_state={ .flags=0ul, .$anon0={ .call={ .op=0ul, .result=0ul, .args={ 0ul, 0ul, 0ul, 0ul, 0ul, 0ul } } } },
    .waitqueue_vcpu=((struct waitqueue_vcpu *)NULL),
    .vcpu_info_mfn=0ul,
    .evtchn_fifo=((struct evtchn_fifo_vcpu *)NULL), .$pad46=0,
    .arch={ .fpu_ctxt=NULL, .vgc_flags=0ul, .user_regs={ .r15=0ul, .r14=0ul, .r13=0ul, .r12=0ul, .$anon0={ .rbp=0ul },
    .$anon1={ .rbx=0ul }, .r11=0ul,
    .r10=0ul, .r9=0ul, .r8=0ul, .$anon2={ .rax=0ul },
    .$anon3={ .rcx=0ul }, .$anon4={ .rdx=0ul },
    .$anon5={ .rsi=0ul }, .$anon6={ .rdi=0ul },
    .error_code=0u, .entry_vector=0u,
    .$anon7={ .rip=0ul }, .cs=0,
    ._pad0={ 0 }, .saved_upcall_mask=0, ._pad1={ 0, 0, 0 },
    .$anon8={ .rflags=0ul }, .$anon9={ .rsp=0ul },
    .ss=0, ._pad2={ 0, 0, 0 }, .es=0,
    ._pad3={ 0, 0, 0 }, .ds=0, ._pad4={ 0, 0, 0 }, .fs=0,
    ._pad5={ 0, 0, 0 }, .gs=0, ._pad6={ 0, 0, 0 } }, .debugreg={ 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul },
    .flags=0ul,
    .schedule_tail=((const void (*)(struct vcpu *))NULL), .ctxt_switch_from=((const void (*)(struct vcpu *))NULL),
    .ctxt_switch_to=((const void (*)(struct vcpu *))NULL),
    .vpmu={ .flags=0u, .last_pcpu=0u, .hw_lapic_lvtpc=0u, .$pad3=0u,
    .context=NULL, .priv_context=NULL, .arch_vpmu_ops=((struct arch_vpmu_ops *)NULL),
    .xenpmu_data=((struct xen_pmu_data *)NULL),
    .vpmu_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } },
    .$pad9=0,
    .$anon0={ .pv_vcpu={ .mapcache={ .shadow_epoch=0u, .$pad1=0u, .hash={ , , , , , , ,  } }, .trap_ctxt=((struct trap_info *)NULL),
    .gdt_frames={ 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul },
    .ldt_base=0ul,
    .gdt_ents=0u, .ldt_ents=0u, .kernel_ss=0ul,
    .kernel_sp=0ul, .ctrlreg={ 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul, 0ul }, .event_callback_eip=0ul,
    .failsafe_callback_eip=0ul, .$anon0={ .syscall_callback_eip=0ul },
    .syscall32_callback_eip=0ul,
    .sysenter_callback_eip=0ul, .syscall32_callback_cs=0,
    .sysenter_callback_cs=0, .syscall32_disables_events=FALSE,
    .sysenter_disables_events=FALSE, .$pad18=0,
    .fs_base=0ul, .gs_base_kernel=0ul, .gs_base_user=0ul,
    .trap_bounce={ .error_code=0u, .flags=0, .$pad2=0, .cs=0, .eip=0ul }, .int80_bounce={ .error_code=0u, .flags=0, .$pad2=0, .cs=0, .eip=0ul },
    .iobmp={ .p=((u8 *)NULL) },
    .iobmp_limit=0u, .iopl=0u,
    .shadow_ldt_mapcnt=0ul, .shadow_ldt_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .dr_mask={ 0u, 0u, 0u, 0u },
    .need_update_runstate_area=FALSE, .$pad31=0,
    .pending_system_time={ .version=0u, .pad0=0u, .tsc_timestamp=0ul, .system_time=0ul,
    .tsc_to_system_mul=0u, .tsc_shift=0,
    .flags=0, .pad1={ 0, 0 } } } }, .guest_table_user={ .pfn=0ul },
    .guest_table={ .pfn=0ul }, .old_guest_table=((struct page_info *)NULL),
    .shadow_table={ , , ,  },
    .monitor_table={ .pfn=0ul }, .cr3=0ul,
    .xsave_area=((struct xsave_struct *)NULL), .xcr0=0ul,
    .xcr0_accum=0ul, .nonlazy_xstate_used=FALSE, .cpuid_faulting=FALSE,
    .smap_check_policy=/*enum*/SMAP_CHECK_HONOR_CPL_AC, .$pad23=0,
    .vmce={ .mcg_cap=0ul, .mcg_status=0ul, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .bank={ ,  } }, .paging={ .mode=((const struct paging_mode *)NULL), .nestedmode=((const struct paging_mode *)NULL),
    .last_write_was_pt=0u,
    .last_write_emul_ok=0u, .$bit_field_pad4=0,
    .$pad5=0, .vtlb=((struct shadow_vtlb *)NULL), .vtlb_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .$pad8=0,
    .shadow={ .l3table={ , , ,  }, .gl3e={ , , ,  }, .guest_vtable=NULL,
    .last_emulated_mfn_for_unshadow=0ul, .last_writeable_pte_smfn=0ul,
    .last_emulated_frame=0ul, .last_emulated_mfn=0ul,
    .oos={ 0ul, 0ul, 0ul }, .oos_snapshot={ 0ul, 0ul, 0ul },
    .oos_fixup={ , ,  }, .pagetable_dying=FALSE,
    .$pad11=0 } },
    .gdbsx_vcpu_event=0u,
    .$pad27=0u, .time_info_guest={ .p=((vcpu_time_info_t *)NULL) }, .vm_event=((struct arch_vm_event *)NULL),
    .$pad30=0ul } } ({ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0 } }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { ?, ? }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { 0x0, { 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 } } }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0 }, 0x0, { 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0 } }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, { { 0x0, 0x0, { ?, ?, ?, ?, ?, ?, ?, ? } }, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0 }, { 0x0, 0x0, 0x0, 0x0, 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, { 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0 } } }, { 0x0 }, { 0x0 }, 0x0, { ?, ?, ?, ? }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, { ?, ? } }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, { { ?, ?, ?, ? }, { ?, ?, ?, ? }, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0 }, { 0x0, 0x0, 0x0 }, { ?, ?, ? }, 0x0, 0x0 } }, 0x0, 0x0, { 0x0 }, 0x0, 0x0 } })

State 983 file mm.c line 3110 function do_mmuext_op thread 0
----------------------------------------------------
rc = NONDET(signed int);
----------------------------------------------------
  rc=0 (0x0)

#### Function call: get_cpu_info$link17$link2() (depth 3) ####

#### Function return: get_cpu_info$link17$link2 (depth 2) ####

#### Function call: get_pg_owner(0) (depth 3) ####

#### Function return: get_pg_owner (depth 2) ####

State 1003 file mm.c line 3141 function do_mmuext_op thread 0
----------------------------------------------------
pg_owner = NONDET(struct domain *);
----------------------------------------------------
  pg_owner=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) + 1l (0x1)

#### Function call: xsm_mmuext_op(/*enum*/XSM_TARGET, ((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) + 1l, ((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) + 1l) (depth 3) ####

#### Function return: xsm_mmuext_op (depth 2) ####

State 1009 file mm.c line 3150 function do_mmuext_op thread 0
----------------------------------------------------
xsm_mmuext_op((xsm_default_t)2, d, pg_owner);
----------------------------------------------------
  d$object={ .domain_id=0, .$pad1=0, .max_vcpus=0u, .vcpu=((struct vcpu **)NULL),
    .shared_info=((shared_info_t *)NULL), .domain_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .page_alloc_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .page_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .xenpage_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .tot_pages=0u,
    .xenheap_pages=0u, .outstanding_pages=0u, .max_pages=0u,
    .shr_pages={ .counter=0 }, .paged_pages={ .counter=0 },
    .sched_priv=NULL, .cpupool=((struct cpupool *)NULL),
    .next_in_list=((struct domain *)NULL), .next_in_hashbucket=((struct domain *)NULL),
    .rangesets={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) },
    .rangesets_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .evtchn=((struct evtchn *)NULL),
    .evtchn_group={ ((struct evtchn **)NULL), ((struct evtchn **)NULL), ((struct evtchn **)NULL), ((struct evtchn **)NULL) }, .max_evtchns=0u,
    .max_evtchn_port=0u, .valid_evtchns=0u,
    .event_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .$pad27=0u,
    .evtchn_port_ops=((const struct evtchn_port_ops *)NULL), .evtchn_fifo=((struct evtchn_fifo_domain *)NULL),
    .grant_table=((struct grant_table *)NULL),
    .pirq_tree={ .height=0u, .$pad1=0u, .rnode=((struct radix_tree_node *)NULL), .node_alloc=((radix_tree_alloc_fn_t (*))NULL),
    .node_free=((radix_tree_free_fn_t (*))NULL),
    .node_alloc_free_arg=NULL },
    .nr_pirqs=0u,
    .guest_type=/*enum*/guest_type_pv, .is_dying=/*enum*/DOMDYING_alive,
    .controller_pause_count=0, .time_offset_seconds=0l,
    .iommu={ .arch={ .pgd_maddr=0ul, .mapping_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .agaw=0,
    .$pad3=0u, .g2m_ioport_list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .iommu_bitmap=0ul,
    .mapped_rmrrs={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .paging_mode=0,
    .$pad8=0u, .root_table=((struct page_info *)NULL), .g_iommu=((struct guest_iommu *)NULL) }, .platform_ops=((const struct iommu_ops *)NULL),
    .features={ 0ul } }, .need_iommu=0,
    .auto_node_affinity=FALSE, .is_privileged=FALSE,
    .is_xenstore=FALSE, .is_pinned=FALSE,
    .disable_migrate=FALSE, .debugger_attached=FALSE,
    .creation_finished=FALSE, .target=((struct domain *)NULL),
    .poll_mask=((unsigned long int *)NULL), .iomem_caps=((struct rangeset *)NULL),
    .irq_caps=((struct rangeset *)NULL),
    .shutdown_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .is_shutting_down=FALSE,
    .is_shut_down=FALSE, .$pad53=0,
    .shutdown_code=0u, .suspend_evtchn=0u, .pause_count={ .counter=0 },
    .refcnt={ .counter=0 }, .$pad58=0u,
    .vm_assist=0ul, .domain_dirty_cpumask=((const cpumask_t *)NULL), .$pad61=0,
    .arch={ .perdomain_l3_pg=((struct page_info *)NULL), .hv_compat_vstart=0u,
    .physaddr_bitsize=0u, .ioport_caps=((struct rangeset *)NULL),
    .pci_cf8=0u,
    .cmos_idx=0, .s3_integrity=FALSE, .$pad7=0,
    .pdev_list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .$anon0={ .pv_domain={ .gdt_ldt_l1tab=((l1_pgentry_t **)NULL), .nr_l4_pages={ .counter=0 },
    .$pad2=0u, .mapcache={ .entries=0u, .cursor=0u, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .epoch=0u,
    .tlbflush_timestamp=0u, .inuse=((unsigned long int *)NULL), .garbage=((unsigned long int *)NULL) },
    .cpuidmasks=((struct cpuidmasks *)NULL) } },
    .paging={ .lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) }, .mode=0u,
    .p2m_alloc_failed=FALSE, .$pad3=0, .shadow={ .opt_flags=0u, .$pad1=0u, .pinned_shadows={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .freelist={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .total_pages=0u,
    .free_pages=0u, .p2m_pages=0u, .$pad7=0u,
    .unpaged_pagetable={ .pfn=0ul }, .gtable_dirty_version={ .counter=0 },
    .$pad10=0u,
    .hash_table=((struct page_info **)NULL), .hash_walking=FALSE,
    .has_fast_mmio_entries=FALSE, .oos_active=FALSE,
    .oos_off=FALSE, .pagetable_dying_op=FALSE, .$pad17=0 },
    .hap={ .freelist={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .total_pages=0u,
    .free_pages=0u, .p2m_pages=0u, .$pad4=0u },
    .log_dirty={ .top=0ul, .allocs=0u, .failed_allocs=0u, .fault_count=0u,
    .dirty_count=0u, .enable_log_dirty=((signed int (*)(struct domain *, bool_t))NULL), .disable_log_dirty=((signed int (*)(struct domain *))NULL),
    .clean_dirty_bitmap=((const void (*)(struct domain *))NULL) },
    .gfn_bits=0u,
    .$pad8=0u, .preempt={ .dom=((struct domain *)NULL), .op=0u, .$pad2=0u, .$anon0={ .log_dirty={ .done=0ul, .i4=0ul, .i3=0ul, .$bit_field_pad3=0 } } }, .alloc_page=((struct page_info * (*)(struct domain *))NULL),
    .free_page=((const void (*)(struct domain *, struct page_info *))NULL) },
    .p2m=((struct p2m_domain *)NULL),
    .page_alloc_unlock_level=0, .relmem=/*enum*/RELMEM_not_started,
    .relmem_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .nested_p2m={ ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL) },
    .nested_p2m_lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) },
    .altp2m_active=FALSE,
    .$pad18=0, .altp2m_p2m={ ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL) }, .altp2m_list_lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) },
    .altp2m_eptp=((unsigned long int *)NULL),
    .irq_pirq={ .height=0u, .$pad1=0u, .rnode=((struct radix_tree_node *)NULL), .node_alloc=((radix_tree_alloc_fn_t (*))NULL),
    .node_free=((radix_tree_free_fn_t (*))NULL),
    .node_alloc_free_arg=NULL },
    .is_32bit_pv=FALSE,
    .has_32bit_shinfo=FALSE, .suppress_spurious_page_faults=FALSE,
    .auto_unmask=FALSE,
    .x86=0, .x86_vendor=0, .x86_model=0,
    .x87_fip_width=0, .cpuids=((cpuid_input_t *)NULL), .vpit={ .hw={ .channels={ , ,  }, .speaker_data_on=0u, .pad0=0u }, .count_load_time={ 0l, 0l, 0l },
    .pt0={ .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .on_list=FALSE,
    .one_shot=FALSE, .do_not_freeze=FALSE, .irq_issued=FALSE,
    .warned_timeout_too_short=FALSE, .source=0,
    .irq=0, .$pad8=0, .vcpu=((struct vcpu *)NULL), .pending_intr_nr=0u,
    .$pad11=0u, .period=0ul, .scheduled=0l,
    .last_plt_gtime=0ul, .timer={ .expires=0l, .$anon0={ .heap_offset=0u }, .function=((const void (*)(const void *))NULL),
    .data=NULL,
    .cpu=0, .status=0, .$pad6=0 }, .cb=((time_cb (*))NULL),
    .priv=NULL }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } },
    .tsc_mode=0,
    .vtsc=FALSE, .$pad35=0, .vtsc_last=0l,
    .vtsc_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .vtsc_offset=0ul,
    .tsc_khz=0u, .vtsc_to_ns={ .shift=0, .mul_frac=0u }, .ns_to_vtsc={ .shift=0, .mul_frac=0u },
    .incarnation=0u,
    .e820_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .e820=((struct e820entry *)NULL),
    .nr_e820=0u, .psr_rmid=0u,
    .psr_cos_ids=((u32 *)NULL), .pirq_eoi_map=((unsigned long int *)NULL),
    .pirq_eoi_map_mfn=0ul,
    .monitor={ .write_ctrlreg_enabled=0u, .write_ctrlreg_sync=0u, .write_ctrlreg_onchangeonly=0u,
    .singlestep_enabled=0u, .software_breakpoint_enabled=0u,
    .debug_exception_enabled=0u, .debug_exception_sync=0u,
    .cpuid_enabled=0u, .$bit_field_pad8=0,
    .$pad9=0, .msr_bitmap=((struct monitor_msr_bitmap *)NULL) }, .mem_access_emulate_each_rep=FALSE,
    .$pad52=0, .emulation_flags=0u,
    .$pad54=0 }, .ssid=NULL,
    .handle={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .pbuf=((const char *)NULL),
    .pbuf_idx=0u, .pbuf_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .$pad68=0u,
    .xenoprof=((struct xenoprof *)NULL), .watchdog_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .watchdog_inuse_map=0u,
    .$pad72=0u, .watchdog_timer={ ,  }, .rcu={ .next=((struct rcu_head *)NULL), .func=((const void (*)(struct rcu_head *))NULL) },
    .hypercall_deadlock_mutex={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .tmem_client=((struct client *)NULL),
    .profile_head=irep("(\"nil\")"),
    .vm_event=((struct vm_event_per_domain *)NULL), .node_affinity={ .bits={ 0ul } },
    .last_alloc_node=0u, .node_affinity_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .vnuma_rwlock={ .cnts={ .counter=0 }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } },
    .vnuma=((struct vnuma_info *)NULL),
    .monitor={ .guest_request_enabled=0u, .guest_request_sync=0u, .$bit_field_pad2=0,
    .$pad3=0 }, .$pad85=0u } ({ 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, { { 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0 }, 0x0, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0, { 0x0 } }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, { 0x0 }, 0x0, { 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0 }, { { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0 } }, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { { { ?, ?, ? }, 0x0, 0x0 }, { 0x0, 0x0, 0x0 }, { { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { ?, ? }, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, ?, 0x0, { { 0x0 } }, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, { { 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, { 0x0, 0x0, 0x0, 0x0 }, 0x0 })

State 1010 file mm.c line 3150 function do_mmuext_op thread 0
----------------------------------------------------
xsm_mmuext_op((xsm_default_t)2, d, pg_owner);
----------------------------------------------------
  pg_owner$object={ .domain_id=0, .$pad1=0, .max_vcpus=0u, .vcpu=((struct vcpu **)NULL),
    .shared_info=((shared_info_t *)NULL), .domain_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .page_alloc_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .page_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .xenpage_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .tot_pages=0u,
    .xenheap_pages=0u, .outstanding_pages=0u, .max_pages=0u,
    .shr_pages={ .counter=0 }, .paged_pages={ .counter=0 },
    .sched_priv=NULL, .cpupool=((struct cpupool *)NULL),
    .next_in_list=((struct domain *)NULL), .next_in_hashbucket=((struct domain *)NULL),
    .rangesets={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) },
    .rangesets_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .evtchn=((struct evtchn *)NULL),
    .evtchn_group={ ((struct evtchn **)NULL), ((struct evtchn **)NULL), ((struct evtchn **)NULL), ((struct evtchn **)NULL) }, .max_evtchns=0u,
    .max_evtchn_port=0u, .valid_evtchns=0u,
    .event_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .$pad27=0u,
    .evtchn_port_ops=((const struct evtchn_port_ops *)NULL), .evtchn_fifo=((struct evtchn_fifo_domain *)NULL),
    .grant_table=((struct grant_table *)NULL),
    .pirq_tree={ .height=0u, .$pad1=0u, .rnode=((struct radix_tree_node *)NULL), .node_alloc=((radix_tree_alloc_fn_t (*))NULL),
    .node_free=((radix_tree_free_fn_t (*))NULL),
    .node_alloc_free_arg=NULL },
    .nr_pirqs=0u,
    .guest_type=/*enum*/guest_type_pv, .is_dying=/*enum*/DOMDYING_alive,
    .controller_pause_count=0, .time_offset_seconds=0l,
    .iommu={ .arch={ .pgd_maddr=0ul, .mapping_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .agaw=0,
    .$pad3=0u, .g2m_ioport_list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .iommu_bitmap=0ul,
    .mapped_rmrrs={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .paging_mode=0,
    .$pad8=0u, .root_table=((struct page_info *)NULL), .g_iommu=((struct guest_iommu *)NULL) }, .platform_ops=((const struct iommu_ops *)NULL),
    .features={ 0ul } }, .need_iommu=0,
    .auto_node_affinity=FALSE, .is_privileged=FALSE,
    .is_xenstore=FALSE, .is_pinned=FALSE,
    .disable_migrate=FALSE, .debugger_attached=FALSE,
    .creation_finished=FALSE, .target=((struct domain *)NULL),
    .poll_mask=((unsigned long int *)NULL), .iomem_caps=((struct rangeset *)NULL),
    .irq_caps=((struct rangeset *)NULL),
    .shutdown_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .is_shutting_down=FALSE,
    .is_shut_down=FALSE, .$pad53=0,
    .shutdown_code=0u, .suspend_evtchn=0u, .pause_count={ .counter=0 },
    .refcnt={ .counter=0 }, .$pad58=0u,
    .vm_assist=0ul, .domain_dirty_cpumask=((const cpumask_t *)NULL), .$pad61=0,
    .arch={ .perdomain_l3_pg=((struct page_info *)NULL), .hv_compat_vstart=0u,
    .physaddr_bitsize=0u, .ioport_caps=((struct rangeset *)NULL),
    .pci_cf8=0u,
    .cmos_idx=0, .s3_integrity=FALSE, .$pad7=0,
    .pdev_list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .$anon0={ .pv_domain={ .gdt_ldt_l1tab=((l1_pgentry_t **)NULL), .nr_l4_pages={ .counter=0 },
    .$pad2=0u, .mapcache={ .entries=0u, .cursor=0u, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .epoch=0u,
    .tlbflush_timestamp=0u, .inuse=((unsigned long int *)NULL), .garbage=((unsigned long int *)NULL) },
    .cpuidmasks=((struct cpuidmasks *)NULL) } },
    .paging={ .lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) }, .mode=2048u,
    .p2m_alloc_failed=FALSE, .$pad3=0,
    .shadow={ .opt_flags=0u, .$pad1=0u, .pinned_shadows={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .freelist={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) },
    .total_pages=0u,
    .free_pages=0u, .p2m_pages=0u, .$pad7=0u,
    .unpaged_pagetable={ .pfn=0ul }, .gtable_dirty_version={ .counter=0 },
    .$pad10=0u,
    .hash_table=((struct page_info **)NULL), .hash_walking=FALSE,
    .has_fast_mmio_entries=FALSE, .oos_active=FALSE,
    .oos_off=FALSE, .pagetable_dying_op=FALSE, .$pad17=0 }, .hap={ .freelist={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .total_pages=0u,
    .free_pages=0u, .p2m_pages=0u, .$pad4=0u },
    .log_dirty={ .top=0ul, .allocs=0u, .failed_allocs=0u, .fault_count=0u,
    .dirty_count=0u, .enable_log_dirty=((signed int (*)(struct domain *, bool_t))NULL), .disable_log_dirty=((signed int (*)(struct domain *))NULL),
    .clean_dirty_bitmap=((const void (*)(struct domain *))NULL) },
    .gfn_bits=0u,
    .$pad8=0u, .preempt={ .dom=((struct domain *)NULL), .op=0u, .$pad2=0u, .$anon0={ .log_dirty={ .done=0ul, .i4=0ul, .i3=0ul, .$bit_field_pad3=0 } } }, .alloc_page=((struct page_info * (*)(struct domain *))NULL),
    .free_page=((const void (*)(struct domain *, struct page_info *))NULL) },
    .p2m=((struct p2m_domain *)NULL),
    .page_alloc_unlock_level=0, .relmem=/*enum*/RELMEM_not_started,
    .relmem_list={ .next=((struct page_info *)NULL), .tail=((struct page_info *)NULL) }, .nested_p2m={ ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL) },
    .nested_p2m_lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) },
    .altp2m_active=FALSE,
    .$pad18=0, .altp2m_p2m={ ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL), ((struct p2m_domain *)NULL) }, .altp2m_list_lock={ .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .unlock_level=0,
    .locker=0, .locker_function=((const char *)NULL) },
    .altp2m_eptp=((unsigned long int *)NULL),
    .irq_pirq={ .height=0u, .$pad1=0u, .rnode=((struct radix_tree_node *)NULL), .node_alloc=((radix_tree_alloc_fn_t (*))NULL),
    .node_free=((radix_tree_free_fn_t (*))NULL),
    .node_alloc_free_arg=NULL },
    .is_32bit_pv=TRUE,
    .has_32bit_shinfo=FALSE, .suppress_spurious_page_faults=FALSE,
    .auto_unmask=FALSE,
    .x86=0, .x86_vendor=0, .x86_model=0,
    .x87_fip_width=0, .cpuids=((cpuid_input_t *)NULL), .vpit={ .hw={ .channels={ , ,  }, .speaker_data_on=0u, .pad0=0u }, .count_load_time={ 0l, 0l, 0l },
    .pt0={ .list={ .next=((struct list_head *)NULL), .prev=((struct list_head *)NULL) }, .on_list=FALSE,
    .one_shot=FALSE, .do_not_freeze=FALSE, .irq_issued=FALSE,
    .warned_timeout_too_short=FALSE, .source=0,
    .irq=0, .$pad8=0, .vcpu=((struct vcpu *)NULL), .pending_intr_nr=0u,
    .$pad11=0u, .period=0ul, .scheduled=0l,
    .last_plt_gtime=0ul, .timer={ .expires=0l, .$anon0={ .heap_offset=0u }, .function=((const void (*)(const void *))NULL),
    .data=NULL,
    .cpu=0, .status=0, .$pad6=0 }, .cb=((time_cb (*))NULL),
    .priv=NULL }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } },
    .tsc_mode=0,
    .vtsc=FALSE, .$pad35=0, .vtsc_last=0l,
    .vtsc_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .vtsc_offset=0ul,
    .tsc_khz=0u, .vtsc_to_ns={ .shift=0, .mul_frac=0u }, .ns_to_vtsc={ .shift=0, .mul_frac=0u },
    .incarnation=0u,
    .e820_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 }, .e820=((struct e820entry *)NULL),
    .nr_e820=0u, .psr_rmid=0u,
    .psr_cos_ids=((u32 *)NULL), .pirq_eoi_map=((unsigned long int *)NULL),
    .pirq_eoi_map_mfn=0ul,
    .monitor={ .write_ctrlreg_enabled=0u, .write_ctrlreg_sync=0u, .write_ctrlreg_onchangeonly=0u,
    .singlestep_enabled=0u, .software_breakpoint_enabled=0u,
    .debug_exception_enabled=0u, .debug_exception_sync=0u,
    .cpuid_enabled=0u, .$bit_field_pad8=0,
    .$pad9=0, .msr_bitmap=((struct monitor_msr_bitmap *)NULL) }, .mem_access_emulate_each_rep=FALSE,
    .$pad52=0, .emulation_flags=0u,
    .$pad54=0 }, .ssid=NULL,
    .handle={ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, .pbuf=((const char *)NULL),
    .pbuf_idx=0u, .pbuf_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .$pad68=0u,
    .xenoprof=((struct xenoprof *)NULL), .watchdog_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .watchdog_inuse_map=0u,
    .$pad72=0u, .watchdog_timer={ ,  }, .rcu={ .next=((struct rcu_head *)NULL), .func=((const void (*)(struct rcu_head *))NULL) },
    .hypercall_deadlock_mutex={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .tmem_client=((struct client *)NULL),
    .profile_head=irep("(\"nil\")"),
    .vm_event=((struct vm_event_per_domain *)NULL), .node_affinity={ .bits={ 0ul } },
    .last_alloc_node=0u, .node_affinity_lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 },
    .vnuma_rwlock={ .cnts={ .counter=0 }, .lock={ .tickets={ .head_tail=0u }, .recurse_cpu=0, .recurse_cnt=0,
    .debug=irep("(\"nil\")"), .$pad4=0 } },
    .vnuma=((struct vnuma_info *)NULL),
    .monitor={ .guest_request_enabled=0u, .guest_request_sync=0u, .$bit_field_pad2=0,
    .$pad3=0 }, .$pad85=0u } ({ 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, { { 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0 }, 0x0, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0, { 0x0 } }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, { 0x0 }, 0x0, { 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0 }, { { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x800, 0x0, 0x0, { 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, { 0x0 }, { 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0 } }, 0x0, 0x0 }, 0x0, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, { { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { { { ?, ?, ? }, 0x0, 0x0 }, { 0x0, 0x0, 0x0 }, { { 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0 }, { 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, 0x0, 0x0 }, 0x0, { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, 0x0, { ?, ? }, { 0x0, 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 }, 0x0, ?, 0x0, { { 0x0 } }, 0x0, { 0x0, 0x0, 0x0, ?, 0x0 }, { { 0x0 }, { 0x0, 0x0, 0x0, ?, 0x0 } }, 0x0, { 0x0, 0x0, 0x0, 0x0 }, 0x0 })

State 1011 file mm.c line 3150 function do_mmuext_op thread 0
----------------------------------------------------
rc = NONDET(signed int);
----------------------------------------------------
  rc=0 (0x0)

State 1013 file mm.c line 3157 function do_mmuext_op thread 0
----------------------------------------------------
i = (unsigned int)0;
----------------------------------------------------
  i=0u (0x0)

State 1023 file mm.c line 3165 function do_mmuext_op thread 0
----------------------------------------------------
const struct mmuext_op *_s;
----------------------------------------------------
  _s=((struct mmuext_op { u32 cmd; u32 $pad1; union { unsigned long int mfn; unsigned long int linear_addr; } arg1; union { u32 nr_ents; struct { const void *p; } vcpumask; unsigned long int src_mfn; } arg2; } *)NULL) (0x0)

State 1024 file mm.c line 3165 function do_mmuext_op thread 0
----------------------------------------------------
_s = uops.p;
----------------------------------------------------
  _s=((struct mmuext_op { u32 cmd; u32 $pad1; union { unsigned long int mfn; unsigned long int linear_addr; } arg1; union { u32 nr_ents; struct { const void *p; } vcpumask; unsigned long int src_mfn; } arg2; } *)NULL) (0x0)

State 1025 file mm.c line 3165 function do_mmuext_op thread 0
----------------------------------------------------
struct mmuext_op *_d;
----------------------------------------------------
  _d=((struct mmuext_op { u32 cmd; u32 $pad1; union { unsigned long int mfn; unsigned long int linear_addr; } arg1; union { u32 nr_ents; struct { const void *p; } vcpumask; unsigned long int src_mfn; } arg2; } *)NULL) (0x0)

State 1026 file mm.c line 3165 function do_mmuext_op thread 0
----------------------------------------------------
_d = &op;
----------------------------------------------------
  _d=&op!0@1.cmd (0x24400000 0000000)

#### Function call: get_cpu_info$link17$link2() (depth 3) ####

#### Function return: get_cpu_info$link17$link2 (depth 2) ####

#### Function call: copy_from_user_hvm(&op!0@1.cmd, NULL, 24u) (depth 3) ####

#### Function return: copy_from_user_hvm (depth 2) ####

State 1038 file mm.c line 3165 function do_mmuext_op thread 0
----------------------------------------------------
copy_from_user_hvm((void *)_d, (const void *)(_s + (signed long int)0), (unsigned int)(sizeof(struct mmuext_op) /*24ul*/  * (unsigned long int)1));
----------------------------------------------------
  op={ .cmd=5u, .$pad1=0u, .arg1={ .mfn=0ul }, .arg2={ .nr_ents=0u } } ({ 0x5, 0x0, 0x0, 0x0 })

State 1045 file mm.c line 3189 function do_mmuext_op thread 0
----------------------------------------------------
rc = 0;
----------------------------------------------------
  rc=0 (0x0)

#### Function call: new_guest_cr3(0ul) (depth 3) ####

State 1057 file mm.c line 3323 function do_mmuext_op thread 0
----------------------------------------------------
new_guest_cr3(byte_extract_little_endian(op.arg1, 0l, xen_pfn_t));
----------------------------------------------------
  mfn=0ul (0x0)

State 1058 file mm.c line 2913 function new_guest_cr3 thread 0
----------------------------------------------------
struct vcpu *curr;
----------------------------------------------------
  curr=((struct vcpu { signed int vcpu_id; signed int processor; vcpu_info_t *vcpu_info; struct domain *domain; struct vcpu *next_in_list; signed long int periodic_period; signed long int periodic_last_event; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } periodic_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } singleshot_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } poll_timer; const void *sched_priv; struct vcpu_runstate_info { signed int state; u32 $pad1; unsigned long int state_entry_time; unsigned long int time[4l]; } runstate; union { struct { vcpu_runstate_info_t *p; } native; struct { vcpu_runstate_info_compat_t *p; } compat; } runstate_guest; unsigned long int last_run_time; bool_t fpu_initialised; bool_t fpu_dirtied; bool_t is_initialised; bool_t is_running; bool_t is_urgent; struct async_exception_state[2l]; u8 async_exception_mask; bool_t defer_shutdown; bool_t paused_for_shutdown; bool_t affinity_broken; unsigned __CPROVER_bitvector[24] $pad24; signed int poll_evtchn; signed int pirq_evtchn_head; unsigned long int pause_flags; struct { signed int counter; } pause_count; struct { signed int counter; } vm_event_pause_count; signed int controller_pause_count; u32 maptrack_head; u32 maptrack_tail; u32 virq_to_evtchn[24l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } virq_lock; u32 $pad35; const cpumask_t *cpu_hard_affinity; const cpumask_t *cpu_hard_affinity_tmp; const cpumask_t *cpu_hard_affinity_saved; const cpumask_t *cpu_soft_affinity; const cpumask_t *vcpu_dirty_cpumask; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } continue_hypercall_tasklet; struct mc_state { unsigned long int flags; union { struct multicall_entry { unsigned long int op; unsigned long int result; unsigned long int args[6l]; } call; struct compat_multicall_entry { u32 op; u32 result; u32 args[6l]; } compat_call; } $anon0; } mc_state; struct waitqueue_vcpu *waitqueue_vcpu; unsigned long int vcpu_info_mfn; struct evtchn_fifo_vcpu *evtchn_fifo; unsigned __CPROVER_bitvector[320] $pad46; struct arch_vcpu { const void *fpu_ctxt; unsigned long int vgc_flags; struct cpu_user_regs { unsigned long int r15; unsigned long int r14; unsigned long int r13; unsigned long int r12; union { unsigned long int rbp; unsigned long int ebp; u32 _ebp; } $anon0; union { unsigned long int rbx; unsigned long int ebx; u32 _ebx; } $anon1; unsigned long int r11; unsigned long int r10; unsigned long int r9; unsigned long int r8; union { unsigned long int rax; unsigned long int eax; u32 _eax; } $anon2; union { unsigned long int rcx; unsigned long int ecx; u32 _ecx; } $anon3; union { unsigned long int rdx; unsigned long int edx; u32 _edx; } $anon4; union { unsigned long int rsi; unsigned long int esi; u32 _esi; } $anon5; union { unsigned long int rdi; unsigned long int edi; u32 _edi; } $anon6; u32 error_code; u32 entry_vector; union { unsigned long int rip; unsigned long int eip; u32 _eip; } $anon7; unsigned short int cs; unsigned short int _pad0[1l]; u8 saved_upcall_mask; u8 _pad1[3l]; union { unsigned long int rflags; unsigned long int eflags; u32 _eflags; } $anon8; union { unsigned long int rsp; unsigned long int esp; u32 _esp; } $anon9; unsigned short int ss; unsigned short int _pad2[3l]; unsigned short int es; unsigned short int _pad3[3l]; unsigned short int ds; unsigned short int _pad4[3l]; unsigned short int fs; unsigned short int _pad5[3l]; unsigned short int gs; unsigned short int _pad6[3l]; } user_regs; unsigned long int debugreg[8l]; unsigned long int flags; const void (*schedule_tail)(struct vcpu *); const void (*ctxt_switch_from)(struct vcpu *); const void (*ctxt_switch_to)(struct vcpu *); struct vpmu_struct { u32 flags; u32 last_pcpu; u32 hw_lapic_lvtpc; u32 $pad3; const void *context; const void *priv_context; struct arch_vpmu_ops *arch_vpmu_ops; struct xen_pmu_data *xenpmu_data; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vpmu_lock; } vpmu; unsigned __int128; union { struct pv_vcpu { struct mapcache_vcpu { u32 shadow_epoch; u32 $pad1; struct vcpu_maphash_entry hash[8l]; } mapcache; struct trap_info *trap_ctxt; unsigned long int gdt_frames[14l]; unsigned long int ldt_base; u32 gdt_ents; u32 ldt_ents; unsigned long int kernel_ss; unsigned long int kernel_sp; unsigned long int ctrlreg[8l]; unsigned long int event_callback_eip; unsigned long int failsafe_callback_eip; union { unsigned long int syscall_callback_eip; struct { u32 event_callback_cs; u32 failsafe_callback_cs; } $anon0; } $anon0; unsigned long int syscall32_callback_eip; unsigned long int sysenter_callback_eip; unsigned short int syscall32_callback_cs; unsigned short int sysenter_callback_cs; bool_t syscall32_disables_events; bool_t sysenter_disables_events; unsigned short int $pad18; unsigned long int fs_base; unsigned long int gs_base_kernel; unsigned long int gs_base_user; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } trap_bounce; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } int80_bounce; struct { u8 *p; } iobmp; u32 iobmp_limit; u32 iopl; unsigned long int shadow_ldt_mapcnt; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shadow_ldt_lock; u32 dr_mask[4l]; bool_t need_update_runstate_area; unsigned __CPROVER_bitvector[56] $pad31; struct vcpu_time_info { u32 version; u32 pad0; unsigned long int tsc_timestamp; unsigned long int system_time; u32 tsc_to_system_mul; const char tsc_shift; u8 flags; u8 pad1[2l]; } pending_system_time; } pv_vcpu; struct hvm_vcpu { unsigned long int guest_cr[5l]; unsigned long int guest_efer; unsigned long int hw_cr[5l]; struct vlapic { struct hvm_hw_lapic { unsigned long int apic_base_msr; u32 disabled; u32 timer_divisor; unsigned long int tdt_msr; } hw; struct hvm_hw_lapic_regs *regs; struct { bool_t hw; bool_t regs; unsigned short int $pad2; u32 id; u32 ldr; } loaded; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } esr_lock; u32 $pad4; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt; signed long int timer_last_update; struct page_info *regs_page; struct { u32 icr; u32 dest; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } tasklet; } init_sipi; } vlapic; signed long int cache_tsc_offset; unsigned long int guest_time; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } tm_lock; struct list_head { struct list_head *next; struct list_head *prev; } tm_list; u8 flag_dr_dirty; bool_t debug_state_latch; bool_t single_step; bool_t hcall_preempted; bool_t hcall_64bit; unsigned __CPROVER_bitvector[24] $pad13; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } n1asid; u32 msr_tsc_aux; u32 $pad16; unsigned long int msr_tsc_adjust; unsigned long int msr_xss; unsigned __CPROVER_bitvector[192] $pad19; union { struct arch_vmx_struct { unsigned long int vmcs_pa; unsigned long int vmcs_shadow_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vmcs_lock; struct list_head { struct list_head *next; struct list_head *prev; } active_list; signed int active_cpu; signed int launched; u32 exec_control; u32 secondary_exec_control; u32 exception_bitmap; u32 $pad9; struct vmx_msr_state { unsigned long int flags; unsigned long int msrs[3l]; } msr_state; unsigned long int shadow_gs; unsigned long int cstar; unsigned long int *msr_bitmap; u32 msr_count; u32 $pad15; struct vmx_msr_entry *msr_area; u32 host_msr_count; u32 $pad18; struct vmx_msr_entry *host_msr_area; unsigned long int eoi_exitmap_changed; unsigned long int eoi_exit_bitmap[4l]; struct pi_desc { unsigned long int pir[4l]; union { struct { unsigned short int on : 1; unsigned short int sn : 1; unsigned short int rsvd_1 : 14; u8 nv; u8 rsvd_2; u32 ndst; } $anon0; unsigned long int control; } $anon0; u32 rsvd[6l]; } pi_desc; unsigned long int host_cr0; bool_t ept_spurious_misconfig; u8 vmx_realmode; u8 vmx_emulate; u8 $pad27; unsigned short int vm86_segment_mask; struct segment_register vm86_saved_seg[7l]; unsigned short int $pad30; u32 vm86_saved_eflags; signed int hostenv_migrated; struct page_info *vmread_bitmap; struct page_info *vmwrite_bitmap; struct page_info *pml_pg; struct pi_blocking_vcpu { struct list_head { struct list_head *next; struct list_head *prev; } list; spinlock_t *lock; } pi_blocking; unsigned long int $pad37; } vmx; struct arch_svm_struct { struct vmcb_struct *vmcb; unsigned long int vmcb_pa; unsigned long int *msrpm; signed int launch_core; bool_t vmcb_in_sync; u8 cached_insn_len; unsigned short int $pad6; unsigned long int guest_sysenter_cs; unsigned long int guest_sysenter_esp; unsigned long int guest_sysenter_eip; unsigned long int guest_lwp_cfg; unsigned long int cpu_lwp_cfg; u32 dr_mask[4l]; struct { unsigned long int length; unsigned long int status; } osvw; } svm; } u; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } assert_evtchn_irq_tasklet; struct nestedvcpu { bool_t nv_guestmode; unsigned __CPROVER_bitvector[56] $pad1; const void *nv_vvmcx; const void *nv_n1vmcx; const void *nv_n2vmcx; unsigned long int nv_vvmcxaddr; unsigned long int nv_n1vmcx_pa; unsigned long int nv_n2vmcx_pa; union { struct nestedsvm { bool_t ns_gif; unsigned __CPROVER_bitvector[56] $pad1; unsigned long int ns_msr_hsavepa; unsigned long int ns_ovvmcb_pa; unsigned long int ns_tscratio; u32 ns_cr_intercepts; u32 ns_dr_intercepts; u32 ns_exception_intercepts; u32 ns_general1_intercepts; u32 ns_general2_intercepts; union { unsigned long int bytes; struct { unsigned long int enable : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad1 : 7; unsigned __CPROVER_bitvector[56] $pad2; } fields; } ns_lbr_control; u32 $pad11; unsigned long int *ns_cached_msrpm; unsigned long int *ns_merged_msrpm; unsigned long int ns_iomap_pa; unsigned long int ns_oiomap_pa; unsigned long int *ns_iomap; unsigned long int ns_cr0; unsigned long int ns_vmcb_guestcr3; unsigned long int ns_vmcb_hostcr3; u32 ns_guest_asid; bool_t ns_hap_enabled; unsigned __CPROVER_bitvector[24] $pad22; struct { unsigned long int exitcode; unsigned long int exitinfo1; unsigned long int exitinfo2; } ns_vmexit; union { u32 bytes; struct { u32 rflagsif : 1; u32 vintrmask : 1; u32 reserved : 30; } fields; } ns_hostflags; u32 $pad25; } nsvm; struct nestedvmx { unsigned long int vmxon_region_pa; const void *iobitmap[2l]; const void *msrbitmap; struct { unsigned long int intr_info; u32 error_code; u8 source; unsigned __CPROVER_bitvector[24] $pad3; } intr; struct { bool_t enabled; unsigned __CPROVER_bitvector[24] $pad1; u32 exit_reason; u32 exit_qual; } ept; u32 guest_vpid; struct list_head { struct list_head *next; struct list_head *prev; } launched_list; } nvmx; } u; bool_t nv_flushp2m; unsigned __CPROVER_bitvector[56] $pad10; struct p2m_domain *nv_p2m; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } nv_n2asid; bool_t nv_vmentry_pending; bool_t nv_vmexit_pending; bool_t nv_vmswitch_in_progress; bool_t nv_ioport80; bool_t nv_ioportED; unsigned __CPROVER_bitvector[24] $pad18; unsigned long int guest_cr[5l]; } nvcpu; struct altp2mvcpu { unsigned short int p2midx; unsigned __CPROVER_bitvector[48] $pad1; unsigned long int veinfo_gfn; } avcpu; struct mtrr_state { struct mtrr_var_range *var_ranges; u8 fixed_ranges[88l]; u8 enabled; u8 have_fixed; u8 def_type; unsigned __CPROVER_bitvector[40] $pad5; unsigned long int mtrr_cap; bool_t overlapped; unsigned __CPROVER_bitvector[56] $pad8; } mtrr; unsigned long int pat_cr; signed long int stime_offset; u8 evtchn_upcall_vector; u8 cache_mode; unsigned __CPROVER_bitvector[48] $pad29; struct hvm_vcpu_io { enum hvm_io_completion io_completion; u32 $pad1; struct ioreq { unsigned long int addr; unsigned long int data; u32 count; u32 size; u32 vp_eport; unsigned short int _pad0; u8 state : 4; u8 data_is_ptr : 1; u8 dir : 1; u8 df : 1; u8 _pad1 : 1; u8 type; } io_req; struct npfec { u32 read_access : 1; u32 write_access : 1; u32 insn_fetch : 1; u32 present : 1; u32 gla_valid : 1; u32 kind : 2; unsigned __CPROVER_bitvector[1] $bit_field_pad6 : 1; unsigned __CPROVER_bitvector[24] $pad7; } mmio_access; u32 $pad4; unsigned long int mmio_gla; unsigned long int mmio_gpfn; struct hvm_mmio_cache mmio_cache[3l]; u32 mmio_cache_count; u32 mmio_insn_bytes; xen_domain_handle_t mmio_insn; bool_t mmio_retry; unsigned __CPROVER_bitvector[56] $pad12; unsigned long int msix_unmask_address; unsigned long int msix_snoop_address; unsigned long int msix_snoop_gpa; const struct g2m_ioport *g2m_ioport; } hvm_io; const void (*fpu_exception_callback)(const void *, struct cpu_user_regs *); const void *fpu_exception_callback_arg; struct hvm_trap { s16 vector; u8 type; u8 insn_len; u32 error_code; unsigned long int cr2; } inject_trap; struct viridian_vcpu { struct { union viridian_apic_assist { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } msr; const void *va; signed int vector; u32 $pad3; } apic_assist; } viridian; } hvm_vcpu; } $anon0; struct { unsigned long int pfn; } guest_table_user; struct { unsigned long int pfn; } guest_table; struct page_info *old_guest_table; pagetable_t shadow_table[4l]; struct { unsigned long int pfn; } monitor_table; unsigned long int cr3; struct xsave_struct *xsave_area; unsigned long int xcr0; unsigned long int xcr0_accum; bool_t nonlazy_xstate_used; bool_t cpuid_faulting; smap_check_policy_t smap_check_policy; unsigned __CPROVER_bitvector[40] $pad23; struct vmce { unsigned long int mcg_cap; unsigned long int mcg_status; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct vmce_bank bank[2l]; } vmce; struct paging_vcpu { const struct paging_mode *mode; const struct paging_mode *nestedmode; u32 last_write_was_pt : 1; u32 last_write_emul_ok : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad4 : 6; unsigned __CPROVER_bitvector[56] $pad5; struct shadow_vtlb *vtlb; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtlb_lock; unsigned __CPROVER_bitvector[192] $pad8; struct shadow_vcpu { l3_pgentry_t l3table[4l]; l3_pgentry_t gl3e[4l]; const void *guest_vtable; unsigned long int last_emulated_mfn_for_unshadow; unsigned long int last_writeable_pte_smfn; unsigned long int last_emulated_frame; unsigned long int last_emulated_mfn; unsigned long int oos[3l]; unsigned long int oos_snapshot[3l]; struct oos_fixup oos_fixup[3l]; bool_t pagetable_dying; unsigned __CPROVER_bitvector[120] $pad11; } shadow; } paging; u32 gdbsx_vcpu_event; u32 $pad27; struct { vcpu_time_info_t *p; } time_info_guest; struct arch_vm_event *vm_event; unsigned long int $pad30; } arch; } *)NULL) (0x0)

#### Function call: get_cpu_info$link17$link2() (depth 4) ####

#### Function return: get_cpu_info$link17$link2 (depth 3) ####

State 1064 file mm.c line 2913 function new_guest_cr3 thread 0
----------------------------------------------------
curr = return_value_get_cpu_info->current_vcpu;
----------------------------------------------------
  curr=((struct vcpu { signed int vcpu_id; signed int processor; vcpu_info_t *vcpu_info; struct domain *domain; struct vcpu *next_in_list; signed long int periodic_period; signed long int periodic_last_event; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } periodic_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } singleshot_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } poll_timer; const void *sched_priv; struct vcpu_runstate_info { signed int state; u32 $pad1; unsigned long int state_entry_time; unsigned long int time[4l]; } runstate; union { struct { vcpu_runstate_info_t *p; } native; struct { vcpu_runstate_info_compat_t *p; } compat; } runstate_guest; unsigned long int last_run_time; bool_t fpu_initialised; bool_t fpu_dirtied; bool_t is_initialised; bool_t is_running; bool_t is_urgent; struct async_exception_state[2l]; u8 async_exception_mask; bool_t defer_shutdown; bool_t paused_for_shutdown; bool_t affinity_broken; unsigned __CPROVER_bitvector[24] $pad24; signed int poll_evtchn; signed int pirq_evtchn_head; unsigned long int pause_flags; struct { signed int counter; } pause_count; struct { signed int counter; } vm_event_pause_count; signed int controller_pause_count; u32 maptrack_head; u32 maptrack_tail; u32 virq_to_evtchn[24l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } virq_lock; u32 $pad35; const cpumask_t *cpu_hard_affinity; const cpumask_t *cpu_hard_affinity_tmp; const cpumask_t *cpu_hard_affinity_saved; const cpumask_t *cpu_soft_affinity; const cpumask_t *vcpu_dirty_cpumask; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } continue_hypercall_tasklet; struct mc_state { unsigned long int flags; union { struct multicall_entry { unsigned long int op; unsigned long int result; unsigned long int args[6l]; } call; struct compat_multicall_entry { u32 op; u32 result; u32 args[6l]; } compat_call; } $anon0; } mc_state; struct waitqueue_vcpu *waitqueue_vcpu; unsigned long int vcpu_info_mfn; struct evtchn_fifo_vcpu *evtchn_fifo; unsigned __CPROVER_bitvector[320] $pad46; struct arch_vcpu { const void *fpu_ctxt; unsigned long int vgc_flags; struct cpu_user_regs { unsigned long int r15; unsigned long int r14; unsigned long int r13; unsigned long int r12; union { unsigned long int rbp; unsigned long int ebp; u32 _ebp; } $anon0; union { unsigned long int rbx; unsigned long int ebx; u32 _ebx; } $anon1; unsigned long int r11; unsigned long int r10; unsigned long int r9; unsigned long int r8; union { unsigned long int rax; unsigned long int eax; u32 _eax; } $anon2; union { unsigned long int rcx; unsigned long int ecx; u32 _ecx; } $anon3; union { unsigned long int rdx; unsigned long int edx; u32 _edx; } $anon4; union { unsigned long int rsi; unsigned long int esi; u32 _esi; } $anon5; union { unsigned long int rdi; unsigned long int edi; u32 _edi; } $anon6; u32 error_code; u32 entry_vector; union { unsigned long int rip; unsigned long int eip; u32 _eip; } $anon7; unsigned short int cs; unsigned short int _pad0[1l]; u8 saved_upcall_mask; u8 _pad1[3l]; union { unsigned long int rflags; unsigned long int eflags; u32 _eflags; } $anon8; union { unsigned long int rsp; unsigned long int esp; u32 _esp; } $anon9; unsigned short int ss; unsigned short int _pad2[3l]; unsigned short int es; unsigned short int _pad3[3l]; unsigned short int ds; unsigned short int _pad4[3l]; unsigned short int fs; unsigned short int _pad5[3l]; unsigned short int gs; unsigned short int _pad6[3l]; } user_regs; unsigned long int debugreg[8l]; unsigned long int flags; const void (*schedule_tail)(struct vcpu *); const void (*ctxt_switch_from)(struct vcpu *); const void (*ctxt_switch_to)(struct vcpu *); struct vpmu_struct { u32 flags; u32 last_pcpu; u32 hw_lapic_lvtpc; u32 $pad3; const void *context; const void *priv_context; struct arch_vpmu_ops *arch_vpmu_ops; struct xen_pmu_data *xenpmu_data; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vpmu_lock; } vpmu; unsigned __int128; union { struct pv_vcpu { struct mapcache_vcpu { u32 shadow_epoch; u32 $pad1; struct vcpu_maphash_entry hash[8l]; } mapcache; struct trap_info *trap_ctxt; unsigned long int gdt_frames[14l]; unsigned long int ldt_base; u32 gdt_ents; u32 ldt_ents; unsigned long int kernel_ss; unsigned long int kernel_sp; unsigned long int ctrlreg[8l]; unsigned long int event_callback_eip; unsigned long int failsafe_callback_eip; union { unsigned long int syscall_callback_eip; struct { u32 event_callback_cs; u32 failsafe_callback_cs; } $anon0; } $anon0; unsigned long int syscall32_callback_eip; unsigned long int sysenter_callback_eip; unsigned short int syscall32_callback_cs; unsigned short int sysenter_callback_cs; bool_t syscall32_disables_events; bool_t sysenter_disables_events; unsigned short int $pad18; unsigned long int fs_base; unsigned long int gs_base_kernel; unsigned long int gs_base_user; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } trap_bounce; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } int80_bounce; struct { u8 *p; } iobmp; u32 iobmp_limit; u32 iopl; unsigned long int shadow_ldt_mapcnt; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shadow_ldt_lock; u32 dr_mask[4l]; bool_t need_update_runstate_area; unsigned __CPROVER_bitvector[56] $pad31; struct vcpu_time_info { u32 version; u32 pad0; unsigned long int tsc_timestamp; unsigned long int system_time; u32 tsc_to_system_mul; const char tsc_shift; u8 flags; u8 pad1[2l]; } pending_system_time; } pv_vcpu; struct hvm_vcpu { unsigned long int guest_cr[5l]; unsigned long int guest_efer; unsigned long int hw_cr[5l]; struct vlapic { struct hvm_hw_lapic { unsigned long int apic_base_msr; u32 disabled; u32 timer_divisor; unsigned long int tdt_msr; } hw; struct hvm_hw_lapic_regs *regs; struct { bool_t hw; bool_t regs; unsigned short int $pad2; u32 id; u32 ldr; } loaded; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } esr_lock; u32 $pad4; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt; signed long int timer_last_update; struct page_info *regs_page; struct { u32 icr; u32 dest; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } tasklet; } init_sipi; } vlapic; signed long int cache_tsc_offset; unsigned long int guest_time; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } tm_lock; struct list_head { struct list_head *next; struct list_head *prev; } tm_list; u8 flag_dr_dirty; bool_t debug_state_latch; bool_t single_step; bool_t hcall_preempted; bool_t hcall_64bit; unsigned __CPROVER_bitvector[24] $pad13; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } n1asid; u32 msr_tsc_aux; u32 $pad16; unsigned long int msr_tsc_adjust; unsigned long int msr_xss; unsigned __CPROVER_bitvector[192] $pad19; union { struct arch_vmx_struct { unsigned long int vmcs_pa; unsigned long int vmcs_shadow_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vmcs_lock; struct list_head { struct list_head *next; struct list_head *prev; } active_list; signed int active_cpu; signed int launched; u32 exec_control; u32 secondary_exec_control; u32 exception_bitmap; u32 $pad9; struct vmx_msr_state { unsigned long int flags; unsigned long int msrs[3l]; } msr_state; unsigned long int shadow_gs; unsigned long int cstar; unsigned long int *msr_bitmap; u32 msr_count; u32 $pad15; struct vmx_msr_entry *msr_area; u32 host_msr_count; u32 $pad18; struct vmx_msr_entry *host_msr_area; unsigned long int eoi_exitmap_changed; unsigned long int eoi_exit_bitmap[4l]; struct pi_desc { unsigned long int pir[4l]; union { struct { unsigned short int on : 1; unsigned short int sn : 1; unsigned short int rsvd_1 : 14; u8 nv; u8 rsvd_2; u32 ndst; } $anon0; unsigned long int control; } $anon0; u32 rsvd[6l]; } pi_desc; unsigned long int host_cr0; bool_t ept_spurious_misconfig; u8 vmx_realmode; u8 vmx_emulate; u8 $pad27; unsigned short int vm86_segment_mask; struct segment_register vm86_saved_seg[7l]; unsigned short int $pad30; u32 vm86_saved_eflags; signed int hostenv_migrated; struct page_info *vmread_bitmap; struct page_info *vmwrite_bitmap; struct page_info *pml_pg; struct pi_blocking_vcpu { struct list_head { struct list_head *next; struct list_head *prev; } list; spinlock_t *lock; } pi_blocking; unsigned long int $pad37; } vmx; struct arch_svm_struct { struct vmcb_struct *vmcb; unsigned long int vmcb_pa; unsigned long int *msrpm; signed int launch_core; bool_t vmcb_in_sync; u8 cached_insn_len; unsigned short int $pad6; unsigned long int guest_sysenter_cs; unsigned long int guest_sysenter_esp; unsigned long int guest_sysenter_eip; unsigned long int guest_lwp_cfg; unsigned long int cpu_lwp_cfg; u32 dr_mask[4l]; struct { unsigned long int length; unsigned long int status; } osvw; } svm; } u; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } assert_evtchn_irq_tasklet; struct nestedvcpu { bool_t nv_guestmode; unsigned __CPROVER_bitvector[56] $pad1; const void *nv_vvmcx; const void *nv_n1vmcx; const void *nv_n2vmcx; unsigned long int nv_vvmcxaddr; unsigned long int nv_n1vmcx_pa; unsigned long int nv_n2vmcx_pa; union { struct nestedsvm { bool_t ns_gif; unsigned __CPROVER_bitvector[56] $pad1; unsigned long int ns_msr_hsavepa; unsigned long int ns_ovvmcb_pa; unsigned long int ns_tscratio; u32 ns_cr_intercepts; u32 ns_dr_intercepts; u32 ns_exception_intercepts; u32 ns_general1_intercepts; u32 ns_general2_intercepts; union { unsigned long int bytes; struct { unsigned long int enable : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad1 : 7; unsigned __CPROVER_bitvector[56] $pad2; } fields; } ns_lbr_control; u32 $pad11; unsigned long int *ns_cached_msrpm; unsigned long int *ns_merged_msrpm; unsigned long int ns_iomap_pa; unsigned long int ns_oiomap_pa; unsigned long int *ns_iomap; unsigned long int ns_cr0; unsigned long int ns_vmcb_guestcr3; unsigned long int ns_vmcb_hostcr3; u32 ns_guest_asid; bool_t ns_hap_enabled; unsigned __CPROVER_bitvector[24] $pad22; struct { unsigned long int exitcode; unsigned long int exitinfo1; unsigned long int exitinfo2; } ns_vmexit; union { u32 bytes; struct { u32 rflagsif : 1; u32 vintrmask : 1; u32 reserved : 30; } fields; } ns_hostflags; u32 $pad25; } nsvm; struct nestedvmx { unsigned long int vmxon_region_pa; const void *iobitmap[2l]; const void *msrbitmap; struct { unsigned long int intr_info; u32 error_code; u8 source; unsigned __CPROVER_bitvector[24] $pad3; } intr; struct { bool_t enabled; unsigned __CPROVER_bitvector[24] $pad1; u32 exit_reason; u32 exit_qual; } ept; u32 guest_vpid; struct list_head { struct list_head *next; struct list_head *prev; } launched_list; } nvmx; } u; bool_t nv_flushp2m; unsigned __CPROVER_bitvector[56] $pad10; struct p2m_domain *nv_p2m; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } nv_n2asid; bool_t nv_vmentry_pending; bool_t nv_vmexit_pending; bool_t nv_vmswitch_in_progress; bool_t nv_ioport80; bool_t nv_ioportED; unsigned __CPROVER_bitvector[24] $pad18; unsigned long int guest_cr[5l]; } nvcpu; struct altp2mvcpu { unsigned short int p2midx; unsigned __CPROVER_bitvector[48] $pad1; unsigned long int veinfo_gfn; } avcpu; struct mtrr_state { struct mtrr_var_range *var_ranges; u8 fixed_ranges[88l]; u8 enabled; u8 have_fixed; u8 def_type; unsigned __CPROVER_bitvector[40] $pad5; unsigned long int mtrr_cap; bool_t overlapped; unsigned __CPROVER_bitvector[56] $pad8; } mtrr; unsigned long int pat_cr; signed long int stime_offset; u8 evtchn_upcall_vector; u8 cache_mode; unsigned __CPROVER_bitvector[48] $pad29; struct hvm_vcpu_io { enum hvm_io_completion io_completion; u32 $pad1; struct ioreq { unsigned long int addr; unsigned long int data; u32 count; u32 size; u32 vp_eport; unsigned short int _pad0; u8 state : 4; u8 data_is_ptr : 1; u8 dir : 1; u8 df : 1; u8 _pad1 : 1; u8 type; } io_req; struct npfec { u32 read_access : 1; u32 write_access : 1; u32 insn_fetch : 1; u32 present : 1; u32 gla_valid : 1; u32 kind : 2; unsigned __CPROVER_bitvector[1] $bit_field_pad6 : 1; unsigned __CPROVER_bitvector[24] $pad7; } mmio_access; u32 $pad4; unsigned long int mmio_gla; unsigned long int mmio_gpfn; struct hvm_mmio_cache mmio_cache[3l]; u32 mmio_cache_count; u32 mmio_insn_bytes; xen_domain_handle_t mmio_insn; bool_t mmio_retry; unsigned __CPROVER_bitvector[56] $pad12; unsigned long int msix_unmask_address; unsigned long int msix_snoop_address; unsigned long int msix_snoop_gpa; const struct g2m_ioport *g2m_ioport; } hvm_io; const void (*fpu_exception_callback)(const void *, struct cpu_user_regs *); const void *fpu_exception_callback_arg; struct hvm_trap { s16 vector; u8 type; u8 insn_len; u32 error_code; unsigned long int cr2; } inject_trap; struct viridian_vcpu { struct { union viridian_apic_assist { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } msr; const void *va; signed int vector; u32 $pad3; } apic_assist; } viridian; } hvm_vcpu; } $anon0; struct { unsigned long int pfn; } guest_table_user; struct { unsigned long int pfn; } guest_table; struct page_info *old_guest_table; pagetable_t shadow_table[4l]; struct { unsigned long int pfn; } monitor_table; unsigned long int cr3; struct xsave_struct *xsave_area; unsigned long int xcr0; unsigned long int xcr0_accum; bool_t nonlazy_xstate_used; bool_t cpuid_faulting; smap_check_policy_t smap_check_policy; unsigned __CPROVER_bitvector[40] $pad23; struct vmce { unsigned long int mcg_cap; unsigned long int mcg_status; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct vmce_bank bank[2l]; } vmce; struct paging_vcpu { const struct paging_mode *mode; const struct paging_mode *nestedmode; u32 last_write_was_pt : 1; u32 last_write_emul_ok : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad4 : 6; unsigned __CPROVER_bitvector[56] $pad5; struct shadow_vtlb *vtlb; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtlb_lock; unsigned __CPROVER_bitvector[192] $pad8; struct shadow_vcpu { l3_pgentry_t l3table[4l]; l3_pgentry_t gl3e[4l]; const void *guest_vtable; unsigned long int last_emulated_mfn_for_unshadow; unsigned long int last_writeable_pte_smfn; unsigned long int last_emulated_frame; unsigned long int last_emulated_mfn; unsigned long int oos[3l]; unsigned long int oos_snapshot[3l]; struct oos_fixup oos_fixup[3l]; bool_t pagetable_dying; unsigned __CPROVER_bitvector[120] $pad11; } shadow; } paging; u32 gdbsx_vcpu_event; u32 $pad27; struct { vcpu_time_info_t *p; } time_info_guest; struct arch_vm_event *vm_event; unsigned long int $pad30; } arch; } *)NULL) (0x0)

State 1065 file mm.c line 2914 function new_guest_cr3 thread 0
----------------------------------------------------
struct domain *d;
----------------------------------------------------
  d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 1066 file mm.c line 2914 function new_guest_cr3 thread 0
----------------------------------------------------
d = curr->domain;
----------------------------------------------------
  d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 1067 file mm.c line 2915 function new_guest_cr3 thread 0
----------------------------------------------------
signed int rc;
----------------------------------------------------
  rc=0 (0x0)

State 1068 file mm.c line 2916 function new_guest_cr3 thread 0
----------------------------------------------------
unsigned long int old_base_mfn;
----------------------------------------------------
  old_base_mfn=0ul (0x0)

State 1070 file mm.c line 2920 function new_guest_cr3 thread 0
----------------------------------------------------
unsigned long int gt_mfn;
----------------------------------------------------
  gt_mfn=0ul (0x0)

State 1071 file mm.c line 2920 function new_guest_cr3 thread 0
----------------------------------------------------
gt_mfn = curr->arch.guest_table.pfn;
----------------------------------------------------
  gt_mfn=0ul (0x0)

State 1072 file mm.c line 2921 function new_guest_cr3 thread 0
----------------------------------------------------
l4_pgentry_t *pl4e;
----------------------------------------------------
  pl4e=((struct { unsigned long int l4; } *)NULL) (0x0)

#### Function call: _mfn$link4$link3(0ul) (depth 4) ####

#### Function return: _mfn$link4$link3 (depth 3) ####

#### Function call: map_domain_page(0ul) (depth 4) ####

#### Function return: map_domain_page (depth 3) ####

State 1083 file mm.c line 2921 function new_guest_cr3 thread 0
----------------------------------------------------
pl4e = (l4_pgentry_t *)return_value_map_domain_page;
----------------------------------------------------
  pl4e=((struct { unsigned long int l4; } *)NULL) (0x0)

#### Function call: mod_l4_entry(((struct { unsigned long int l4; } *)NULL), { .l4=39ul }, 0ul, 0, ((struct vcpu { signed int vcpu_id; signed int processor; vcpu_info_t *vcpu_info; struct domain *domain; struct vcpu *next_in_list; signed long int periodic_period; signed long int periodic_last_event; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } periodic_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } singleshot_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } poll_timer; const void *sched_priv; struct vcpu_runstate_info { signed int state; u32 $pad1; unsigned long int state_entry_time; unsigned long int time[4l]; } runstate; union { struct { vcpu_runstate_info_t *p; } native; struct { vcpu_runstate_info_compat_t *p; } compat; } runstate_guest; unsigned long int last_run_time; bool_t fpu_initialised; bool_t fpu_dirtied; bool_t is_initialised; bool_t is_running; bool_t is_urgent; struct async_exception_state[2l]; u8 async_exception_mask; bool_t defer_shutdown; bool_t paused_for_shutdown; bool_t affinity_broken; unsigned __CPROVER_bitvector[24] $pad24; signed int poll_evtchn; signed int pirq_evtchn_head; unsigned long int pause_flags; struct { signed int counter; } pause_count; struct { signed int counter; } vm_event_pause_count; signed int controller_pause_count; u32 maptrack_head; u32 maptrack_tail; u32 virq_to_evtchn[24l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } virq_lock; u32 $pad35; const cpumask_t *cpu_hard_affinity; const cpumask_t *cpu_hard_affinity_tmp; const cpumask_t *cpu_hard_affinity_saved; const cpumask_t *cpu_soft_affinity; const cpumask_t *vcpu_dirty_cpumask; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } continue_hypercall_tasklet; struct mc_state { unsigned long int flags; union { struct multicall_entry { unsigned long int op; unsigned long int result; unsigned long int args[6l]; } call; struct compat_multicall_entry { u32 op; u32 result; u32 args[6l]; } compat_call; } $anon0; } mc_state; struct waitqueue_vcpu *waitqueue_vcpu; unsigned long int vcpu_info_mfn; struct evtchn_fifo_vcpu *evtchn_fifo; unsigned __CPROVER_bitvector[320] $pad46; struct arch_vcpu { const void *fpu_ctxt; unsigned long int vgc_flags; struct cpu_user_regs { unsigned long int r15; unsigned long int r14; unsigned long int r13; unsigned long int r12; union { unsigned long int rbp; unsigned long int ebp; u32 _ebp; } $anon0; union { unsigned long int rbx; unsigned long int ebx; u32 _ebx; } $anon1; unsigned long int r11; unsigned long int r10; unsigned long int r9; unsigned long int r8; union { unsigned long int rax; unsigned long int eax; u32 _eax; } $anon2; union { unsigned long int rcx; unsigned long int ecx; u32 _ecx; } $anon3; union { unsigned long int rdx; unsigned long int edx; u32 _edx; } $anon4; union { unsigned long int rsi; unsigned long int esi; u32 _esi; } $anon5; union { unsigned long int rdi; unsigned long int edi; u32 _edi; } $anon6; u32 error_code; u32 entry_vector; union { unsigned long int rip; unsigned long int eip; u32 _eip; } $anon7; unsigned short int cs; unsigned short int _pad0[1l]; u8 saved_upcall_mask; u8 _pad1[3l]; union { unsigned long int rflags; unsigned long int eflags; u32 _eflags; } $anon8; union { unsigned long int rsp; unsigned long int esp; u32 _esp; } $anon9; unsigned short int ss; unsigned short int _pad2[3l]; unsigned short int es; unsigned short int _pad3[3l]; unsigned short int ds; unsigned short int _pad4[3l]; unsigned short int fs; unsigned short int _pad5[3l]; unsigned short int gs; unsigned short int _pad6[3l]; } user_regs; unsigned long int debugreg[8l]; unsigned long int flags; const void (*schedule_tail)(struct vcpu *); const void (*ctxt_switch_from)(struct vcpu *); const void (*ctxt_switch_to)(struct vcpu *); struct vpmu_struct { u32 flags; u32 last_pcpu; u32 hw_lapic_lvtpc; u32 $pad3; const void *context; const void *priv_context; struct arch_vpmu_ops *arch_vpmu_ops; struct xen_pmu_data *xenpmu_data; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vpmu_lock; } vpmu; unsigned __int128; union { struct pv_vcpu { struct mapcache_vcpu { u32 shadow_epoch; u32 $pad1; struct vcpu_maphash_entry hash[8l]; } mapcache; struct trap_info *trap_ctxt; unsigned long int gdt_frames[14l]; unsigned long int ldt_base; u32 gdt_ents; u32 ldt_ents; unsigned long int kernel_ss; unsigned long int kernel_sp; unsigned long int ctrlreg[8l]; unsigned long int event_callback_eip; unsigned long int failsafe_callback_eip; union { unsigned long int syscall_callback_eip; struct { u32 event_callback_cs; u32 failsafe_callback_cs; } $anon0; } $anon0; unsigned long int syscall32_callback_eip; unsigned long int sysenter_callback_eip; unsigned short int syscall32_callback_cs; unsigned short int sysenter_callback_cs; bool_t syscall32_disables_events; bool_t sysenter_disables_events; unsigned short int $pad18; unsigned long int fs_base; unsigned long int gs_base_kernel; unsigned long int gs_base_user; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } trap_bounce; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } int80_bounce; struct { u8 *p; } iobmp; u32 iobmp_limit; u32 iopl; unsigned long int shadow_ldt_mapcnt; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shadow_ldt_lock; u32 dr_mask[4l]; bool_t need_update_runstate_area; unsigned __CPROVER_bitvector[56] $pad31; struct vcpu_time_info { u32 version; u32 pad0; unsigned long int tsc_timestamp; unsigned long int system_time; u32 tsc_to_system_mul; const char tsc_shift; u8 flags; u8 pad1[2l]; } pending_system_time; } pv_vcpu; struct hvm_vcpu { unsigned long int guest_cr[5l]; unsigned long int guest_efer; unsigned long int hw_cr[5l]; struct vlapic { struct hvm_hw_lapic { unsigned long int apic_base_msr; u32 disabled; u32 timer_divisor; unsigned long int tdt_msr; } hw; struct hvm_hw_lapic_regs *regs; struct { bool_t hw; bool_t regs; unsigned short int $pad2; u32 id; u32 ldr; } loaded; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } esr_lock; u32 $pad4; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt; signed long int timer_last_update; struct page_info *regs_page; struct { u32 icr; u32 dest; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } tasklet; } init_sipi; } vlapic; signed long int cache_tsc_offset; unsigned long int guest_time; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } tm_lock; struct list_head { struct list_head *next; struct list_head *prev; } tm_list; u8 flag_dr_dirty; bool_t debug_state_latch; bool_t single_step; bool_t hcall_preempted; bool_t hcall_64bit; unsigned __CPROVER_bitvector[24] $pad13; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } n1asid; u32 msr_tsc_aux; u32 $pad16; unsigned long int msr_tsc_adjust; unsigned long int msr_xss; unsigned __CPROVER_bitvector[192] $pad19; union { struct arch_vmx_struct { unsigned long int vmcs_pa; unsigned long int vmcs_shadow_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vmcs_lock; struct list_head { struct list_head *next; struct list_head *prev; } active_list; signed int active_cpu; signed int launched; u32 exec_control; u32 secondary_exec_control; u32 exception_bitmap; u32 $pad9; struct vmx_msr_state { unsigned long int flags; unsigned long int msrs[3l]; } msr_state; unsigned long int shadow_gs; unsigned long int cstar; unsigned long int *msr_bitmap; u32 msr_count; u32 $pad15; struct vmx_msr_entry *msr_area; u32 host_msr_count; u32 $pad18; struct vmx_msr_entry *host_msr_area; unsigned long int eoi_exitmap_changed; unsigned long int eoi_exit_bitmap[4l]; struct pi_desc { unsigned long int pir[4l]; union { struct { unsigned short int on : 1; unsigned short int sn : 1; unsigned short int rsvd_1 : 14; u8 nv; u8 rsvd_2; u32 ndst; } $anon0; unsigned long int control; } $anon0; u32 rsvd[6l]; } pi_desc; unsigned long int host_cr0; bool_t ept_spurious_misconfig; u8 vmx_realmode; u8 vmx_emulate; u8 $pad27; unsigned short int vm86_segment_mask; struct segment_register vm86_saved_seg[7l]; unsigned short int $pad30; u32 vm86_saved_eflags; signed int hostenv_migrated; struct page_info *vmread_bitmap; struct page_info *vmwrite_bitmap; struct page_info *pml_pg; struct pi_blocking_vcpu { struct list_head { struct list_head *next; struct list_head *prev; } list; spinlock_t *lock; } pi_blocking; unsigned long int $pad37; } vmx; struct arch_svm_struct { struct vmcb_struct *vmcb; unsigned long int vmcb_pa; unsigned long int *msrpm; signed int launch_core; bool_t vmcb_in_sync; u8 cached_insn_len; unsigned short int $pad6; unsigned long int guest_sysenter_cs; unsigned long int guest_sysenter_esp; unsigned long int guest_sysenter_eip; unsigned long int guest_lwp_cfg; unsigned long int cpu_lwp_cfg; u32 dr_mask[4l]; struct { unsigned long int length; unsigned long int status; } osvw; } svm; } u; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } assert_evtchn_irq_tasklet; struct nestedvcpu { bool_t nv_guestmode; unsigned __CPROVER_bitvector[56] $pad1; const void *nv_vvmcx; const void *nv_n1vmcx; const void *nv_n2vmcx; unsigned long int nv_vvmcxaddr; unsigned long int nv_n1vmcx_pa; unsigned long int nv_n2vmcx_pa; union { struct nestedsvm { bool_t ns_gif; unsigned __CPROVER_bitvector[56] $pad1; unsigned long int ns_msr_hsavepa; unsigned long int ns_ovvmcb_pa; unsigned long int ns_tscratio; u32 ns_cr_intercepts; u32 ns_dr_intercepts; u32 ns_exception_intercepts; u32 ns_general1_intercepts; u32 ns_general2_intercepts; union { unsigned long int bytes; struct { unsigned long int enable : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad1 : 7; unsigned __CPROVER_bitvector[56] $pad2; } fields; } ns_lbr_control; u32 $pad11; unsigned long int *ns_cached_msrpm; unsigned long int *ns_merged_msrpm; unsigned long int ns_iomap_pa; unsigned long int ns_oiomap_pa; unsigned long int *ns_iomap; unsigned long int ns_cr0; unsigned long int ns_vmcb_guestcr3; unsigned long int ns_vmcb_hostcr3; u32 ns_guest_asid; bool_t ns_hap_enabled; unsigned __CPROVER_bitvector[24] $pad22; struct { unsigned long int exitcode; unsigned long int exitinfo1; unsigned long int exitinfo2; } ns_vmexit; union { u32 bytes; struct { u32 rflagsif : 1; u32 vintrmask : 1; u32 reserved : 30; } fields; } ns_hostflags; u32 $pad25; } nsvm; struct nestedvmx { unsigned long int vmxon_region_pa; const void *iobitmap[2l]; const void *msrbitmap; struct { unsigned long int intr_info; u32 error_code; u8 source; unsigned __CPROVER_bitvector[24] $pad3; } intr; struct { bool_t enabled; unsigned __CPROVER_bitvector[24] $pad1; u32 exit_reason; u32 exit_qual; } ept; u32 guest_vpid; struct list_head { struct list_head *next; struct list_head *prev; } launched_list; } nvmx; } u; bool_t nv_flushp2m; unsigned __CPROVER_bitvector[56] $pad10; struct p2m_domain *nv_p2m; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } nv_n2asid; bool_t nv_vmentry_pending; bool_t nv_vmexit_pending; bool_t nv_vmswitch_in_progress; bool_t nv_ioport80; bool_t nv_ioportED; unsigned __CPROVER_bitvector[24] $pad18; unsigned long int guest_cr[5l]; } nvcpu; struct altp2mvcpu { unsigned short int p2midx; unsigned __CPROVER_bitvector[48] $pad1; unsigned long int veinfo_gfn; } avcpu; struct mtrr_state { struct mtrr_var_range *var_ranges; u8 fixed_ranges[88l]; u8 enabled; u8 have_fixed; u8 def_type; unsigned __CPROVER_bitvector[40] $pad5; unsigned long int mtrr_cap; bool_t overlapped; unsigned __CPROVER_bitvector[56] $pad8; } mtrr; unsigned long int pat_cr; signed long int stime_offset; u8 evtchn_upcall_vector; u8 cache_mode; unsigned __CPROVER_bitvector[48] $pad29; struct hvm_vcpu_io { enum hvm_io_completion io_completion; u32 $pad1; struct ioreq { unsigned long int addr; unsigned long int data; u32 count; u32 size; u32 vp_eport; unsigned short int _pad0; u8 state : 4; u8 data_is_ptr : 1; u8 dir : 1; u8 df : 1; u8 _pad1 : 1; u8 type; } io_req; struct npfec { u32 read_access : 1; u32 write_access : 1; u32 insn_fetch : 1; u32 present : 1; u32 gla_valid : 1; u32 kind : 2; unsigned __CPROVER_bitvector[1] $bit_field_pad6 : 1; unsigned __CPROVER_bitvector[24] $pad7; } mmio_access; u32 $pad4; unsigned long int mmio_gla; unsigned long int mmio_gpfn; struct hvm_mmio_cache mmio_cache[3l]; u32 mmio_cache_count; u32 mmio_insn_bytes; xen_domain_handle_t mmio_insn; bool_t mmio_retry; unsigned __CPROVER_bitvector[56] $pad12; unsigned long int msix_unmask_address; unsigned long int msix_snoop_address; unsigned long int msix_snoop_gpa; const struct g2m_ioport *g2m_ioport; } hvm_io; const void (*fpu_exception_callback)(const void *, struct cpu_user_regs *); const void *fpu_exception_callback_arg; struct hvm_trap { s16 vector; u8 type; u8 insn_len; u32 error_code; unsigned long int cr2; } inject_trap; struct viridian_vcpu { struct { union viridian_apic_assist { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } msr; const void *va; signed int vector; u32 $pad3; } apic_assist; } viridian; } hvm_vcpu; } $anon0; struct { unsigned long int pfn; } guest_table_user; struct { unsigned long int pfn; } guest_table; struct page_info *old_guest_table; pagetable_t shadow_table[4l]; struct { unsigned long int pfn; } monitor_table; unsigned long int cr3; struct xsave_struct *xsave_area; unsigned long int xcr0; unsigned long int xcr0_accum; bool_t nonlazy_xstate_used; bool_t cpuid_faulting; smap_check_policy_t smap_check_policy; unsigned __CPROVER_bitvector[40] $pad23; struct vmce { unsigned long int mcg_cap; unsigned long int mcg_status; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct vmce_bank bank[2l]; } vmce; struct paging_vcpu { const struct paging_mode *mode; const struct paging_mode *nestedmode; u32 last_write_was_pt : 1; u32 last_write_emul_ok : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad4 : 6; unsigned __CPROVER_bitvector[56] $pad5; struct shadow_vtlb *vtlb; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtlb_lock; unsigned __CPROVER_bitvector[192] $pad8; struct shadow_vcpu { l3_pgentry_t l3table[4l]; l3_pgentry_t gl3e[4l]; const void *guest_vtable; unsigned long int last_emulated_mfn_for_unshadow; unsigned long int last_writeable_pte_smfn; unsigned long int last_emulated_frame; unsigned long int last_emulated_mfn; unsigned long int oos[3l]; unsigned long int oos_snapshot[3l]; struct oos_fixup oos_fixup[3l]; bool_t pagetable_dying; unsigned __CPROVER_bitvector[120] $pad11; } shadow; } paging; u32 gdbsx_vcpu_event; u32 $pad27; struct { vcpu_time_info_t *p; } time_info_guest; struct arch_vm_event *vm_event; unsigned long int $pad30; } arch; } *)NULL)) (depth 4) ####

State 1089 file mm.c line 2925 function new_guest_cr3 thread 0
----------------------------------------------------
mod_l4_entry(pl4e, { .l4=(intpte_t)mfn << 12 | (intpte_t)((0x1u | 0x2u | 0x4u | 0x20u) & (unsigned int)~0xFFF) << 40 | (unsigned long int)((0x1u | 0x2u | 0x4u | 0x20u) & (unsigned int)0xFFF) }, gt_mfn, 0, curr);
----------------------------------------------------
  pl4e=((struct { unsigned long int l4; } *)NULL) (0x0)

State 1090 file mm.c line 2925 function new_guest_cr3 thread 0
----------------------------------------------------
mod_l4_entry(pl4e, { .l4=(intpte_t)mfn << 12 | (intpte_t)((0x1u | 0x2u | 0x4u | 0x20u) & (unsigned int)~0xFFF) << 40 | (unsigned long int)((0x1u | 0x2u | 0x4u | 0x20u) & (unsigned int)0xFFF) }, gt_mfn, 0, curr);
----------------------------------------------------
  nl4e={ .l4=39ul } ({ 0x27 })

State 1091 file mm.c line 2925 function new_guest_cr3 thread 0
----------------------------------------------------
mod_l4_entry(pl4e, { .l4=(intpte_t)mfn << 12 | (intpte_t)((0x1u | 0x2u | 0x4u | 0x20u) & (unsigned int)~0xFFF) << 40 | (unsigned long int)((0x1u | 0x2u | 0x4u | 0x20u) & (unsigned int)0xFFF) }, gt_mfn, 0, curr);
----------------------------------------------------
  pfn=0ul (0x0)

State 1092 file mm.c line 2925 function new_guest_cr3 thread 0
----------------------------------------------------
mod_l4_entry(pl4e, { .l4=(intpte_t)mfn << 12 | (intpte_t)((0x1u | 0x2u | 0x4u | 0x20u) & (unsigned int)~0xFFF) << 40 | (unsigned long int)((0x1u | 0x2u | 0x4u | 0x20u) & (unsigned int)0xFFF) }, gt_mfn, 0, curr);
----------------------------------------------------
  preserve_ad=0 (0x0)

State 1093 file mm.c line 2925 function new_guest_cr3 thread 0
----------------------------------------------------
mod_l4_entry(pl4e, { .l4=(intpte_t)mfn << 12 | (intpte_t)((0x1u | 0x2u | 0x4u | 0x20u) & (unsigned int)~0xFFF) << 40 | (unsigned long int)((0x1u | 0x2u | 0x4u | 0x20u) & (unsigned int)0xFFF) }, gt_mfn, 0, curr);
----------------------------------------------------
  vcpu=((struct vcpu { signed int vcpu_id; signed int processor; vcpu_info_t *vcpu_info; struct domain *domain; struct vcpu *next_in_list; signed long int periodic_period; signed long int periodic_last_event; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } periodic_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } singleshot_timer; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } poll_timer; const void *sched_priv; struct vcpu_runstate_info { signed int state; u32 $pad1; unsigned long int state_entry_time; unsigned long int time[4l]; } runstate; union { struct { vcpu_runstate_info_t *p; } native; struct { vcpu_runstate_info_compat_t *p; } compat; } runstate_guest; unsigned long int last_run_time; bool_t fpu_initialised; bool_t fpu_dirtied; bool_t is_initialised; bool_t is_running; bool_t is_urgent; struct async_exception_state[2l]; u8 async_exception_mask; bool_t defer_shutdown; bool_t paused_for_shutdown; bool_t affinity_broken; unsigned __CPROVER_bitvector[24] $pad24; signed int poll_evtchn; signed int pirq_evtchn_head; unsigned long int pause_flags; struct { signed int counter; } pause_count; struct { signed int counter; } vm_event_pause_count; signed int controller_pause_count; u32 maptrack_head; u32 maptrack_tail; u32 virq_to_evtchn[24l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } virq_lock; u32 $pad35; const cpumask_t *cpu_hard_affinity; const cpumask_t *cpu_hard_affinity_tmp; const cpumask_t *cpu_hard_affinity_saved; const cpumask_t *cpu_soft_affinity; const cpumask_t *vcpu_dirty_cpumask; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } continue_hypercall_tasklet; struct mc_state { unsigned long int flags; union { struct multicall_entry { unsigned long int op; unsigned long int result; unsigned long int args[6l]; } call; struct compat_multicall_entry { u32 op; u32 result; u32 args[6l]; } compat_call; } $anon0; } mc_state; struct waitqueue_vcpu *waitqueue_vcpu; unsigned long int vcpu_info_mfn; struct evtchn_fifo_vcpu *evtchn_fifo; unsigned __CPROVER_bitvector[320] $pad46; struct arch_vcpu { const void *fpu_ctxt; unsigned long int vgc_flags; struct cpu_user_regs { unsigned long int r15; unsigned long int r14; unsigned long int r13; unsigned long int r12; union { unsigned long int rbp; unsigned long int ebp; u32 _ebp; } $anon0; union { unsigned long int rbx; unsigned long int ebx; u32 _ebx; } $anon1; unsigned long int r11; unsigned long int r10; unsigned long int r9; unsigned long int r8; union { unsigned long int rax; unsigned long int eax; u32 _eax; } $anon2; union { unsigned long int rcx; unsigned long int ecx; u32 _ecx; } $anon3; union { unsigned long int rdx; unsigned long int edx; u32 _edx; } $anon4; union { unsigned long int rsi; unsigned long int esi; u32 _esi; } $anon5; union { unsigned long int rdi; unsigned long int edi; u32 _edi; } $anon6; u32 error_code; u32 entry_vector; union { unsigned long int rip; unsigned long int eip; u32 _eip; } $anon7; unsigned short int cs; unsigned short int _pad0[1l]; u8 saved_upcall_mask; u8 _pad1[3l]; union { unsigned long int rflags; unsigned long int eflags; u32 _eflags; } $anon8; union { unsigned long int rsp; unsigned long int esp; u32 _esp; } $anon9; unsigned short int ss; unsigned short int _pad2[3l]; unsigned short int es; unsigned short int _pad3[3l]; unsigned short int ds; unsigned short int _pad4[3l]; unsigned short int fs; unsigned short int _pad5[3l]; unsigned short int gs; unsigned short int _pad6[3l]; } user_regs; unsigned long int debugreg[8l]; unsigned long int flags; const void (*schedule_tail)(struct vcpu *); const void (*ctxt_switch_from)(struct vcpu *); const void (*ctxt_switch_to)(struct vcpu *); struct vpmu_struct { u32 flags; u32 last_pcpu; u32 hw_lapic_lvtpc; u32 $pad3; const void *context; const void *priv_context; struct arch_vpmu_ops *arch_vpmu_ops; struct xen_pmu_data *xenpmu_data; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vpmu_lock; } vpmu; unsigned __int128; union { struct pv_vcpu { struct mapcache_vcpu { u32 shadow_epoch; u32 $pad1; struct vcpu_maphash_entry hash[8l]; } mapcache; struct trap_info *trap_ctxt; unsigned long int gdt_frames[14l]; unsigned long int ldt_base; u32 gdt_ents; u32 ldt_ents; unsigned long int kernel_ss; unsigned long int kernel_sp; unsigned long int ctrlreg[8l]; unsigned long int event_callback_eip; unsigned long int failsafe_callback_eip; union { unsigned long int syscall_callback_eip; struct { u32 event_callback_cs; u32 failsafe_callback_cs; } $anon0; } $anon0; unsigned long int syscall32_callback_eip; unsigned long int sysenter_callback_eip; unsigned short int syscall32_callback_cs; unsigned short int sysenter_callback_cs; bool_t syscall32_disables_events; bool_t sysenter_disables_events; unsigned short int $pad18; unsigned long int fs_base; unsigned long int gs_base_kernel; unsigned long int gs_base_user; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } trap_bounce; struct trap_bounce { u32 error_code; u8 flags; u8 $pad2; unsigned short int cs; unsigned long int eip; } int80_bounce; struct { u8 *p; } iobmp; u32 iobmp_limit; u32 iopl; unsigned long int shadow_ldt_mapcnt; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shadow_ldt_lock; u32 dr_mask[4l]; bool_t need_update_runstate_area; unsigned __CPROVER_bitvector[56] $pad31; struct vcpu_time_info { u32 version; u32 pad0; unsigned long int tsc_timestamp; unsigned long int system_time; u32 tsc_to_system_mul; const char tsc_shift; u8 flags; u8 pad1[2l]; } pending_system_time; } pv_vcpu; struct hvm_vcpu { unsigned long int guest_cr[5l]; unsigned long int guest_efer; unsigned long int hw_cr[5l]; struct vlapic { struct hvm_hw_lapic { unsigned long int apic_base_msr; u32 disabled; u32 timer_divisor; unsigned long int tdt_msr; } hw; struct hvm_hw_lapic_regs *regs; struct { bool_t hw; bool_t regs; unsigned short int $pad2; u32 id; u32 ldr; } loaded; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } esr_lock; u32 $pad4; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt; signed long int timer_last_update; struct page_info *regs_page; struct { u32 icr; u32 dest; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } tasklet; } init_sipi; } vlapic; signed long int cache_tsc_offset; unsigned long int guest_time; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } tm_lock; struct list_head { struct list_head *next; struct list_head *prev; } tm_list; u8 flag_dr_dirty; bool_t debug_state_latch; bool_t single_step; bool_t hcall_preempted; bool_t hcall_64bit; unsigned __CPROVER_bitvector[24] $pad13; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } n1asid; u32 msr_tsc_aux; u32 $pad16; unsigned long int msr_tsc_adjust; unsigned long int msr_xss; unsigned __CPROVER_bitvector[192] $pad19; union { struct arch_vmx_struct { unsigned long int vmcs_pa; unsigned long int vmcs_shadow_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vmcs_lock; struct list_head { struct list_head *next; struct list_head *prev; } active_list; signed int active_cpu; signed int launched; u32 exec_control; u32 secondary_exec_control; u32 exception_bitmap; u32 $pad9; struct vmx_msr_state { unsigned long int flags; unsigned long int msrs[3l]; } msr_state; unsigned long int shadow_gs; unsigned long int cstar; unsigned long int *msr_bitmap; u32 msr_count; u32 $pad15; struct vmx_msr_entry *msr_area; u32 host_msr_count; u32 $pad18; struct vmx_msr_entry *host_msr_area; unsigned long int eoi_exitmap_changed; unsigned long int eoi_exit_bitmap[4l]; struct pi_desc { unsigned long int pir[4l]; union { struct { unsigned short int on : 1; unsigned short int sn : 1; unsigned short int rsvd_1 : 14; u8 nv; u8 rsvd_2; u32 ndst; } $anon0; unsigned long int control; } $anon0; u32 rsvd[6l]; } pi_desc; unsigned long int host_cr0; bool_t ept_spurious_misconfig; u8 vmx_realmode; u8 vmx_emulate; u8 $pad27; unsigned short int vm86_segment_mask; struct segment_register vm86_saved_seg[7l]; unsigned short int $pad30; u32 vm86_saved_eflags; signed int hostenv_migrated; struct page_info *vmread_bitmap; struct page_info *vmwrite_bitmap; struct page_info *pml_pg; struct pi_blocking_vcpu { struct list_head { struct list_head *next; struct list_head *prev; } list; spinlock_t *lock; } pi_blocking; unsigned long int $pad37; } vmx; struct arch_svm_struct { struct vmcb_struct *vmcb; unsigned long int vmcb_pa; unsigned long int *msrpm; signed int launch_core; bool_t vmcb_in_sync; u8 cached_insn_len; unsigned short int $pad6; unsigned long int guest_sysenter_cs; unsigned long int guest_sysenter_esp; unsigned long int guest_sysenter_eip; unsigned long int guest_lwp_cfg; unsigned long int cpu_lwp_cfg; u32 dr_mask[4l]; struct { unsigned long int length; unsigned long int status; } osvw; } svm; } u; struct tasklet { struct list_head { struct list_head *next; struct list_head *prev; } list; signed int scheduled_on; bool_t is_softirq; bool_t is_running; bool_t is_dead; u8 $pad5; const void (*func)(unsigned long int); unsigned long int data; } assert_evtchn_irq_tasklet; struct nestedvcpu { bool_t nv_guestmode; unsigned __CPROVER_bitvector[56] $pad1; const void *nv_vvmcx; const void *nv_n1vmcx; const void *nv_n2vmcx; unsigned long int nv_vvmcxaddr; unsigned long int nv_n1vmcx_pa; unsigned long int nv_n2vmcx_pa; union { struct nestedsvm { bool_t ns_gif; unsigned __CPROVER_bitvector[56] $pad1; unsigned long int ns_msr_hsavepa; unsigned long int ns_ovvmcb_pa; unsigned long int ns_tscratio; u32 ns_cr_intercepts; u32 ns_dr_intercepts; u32 ns_exception_intercepts; u32 ns_general1_intercepts; u32 ns_general2_intercepts; union { unsigned long int bytes; struct { unsigned long int enable : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad1 : 7; unsigned __CPROVER_bitvector[56] $pad2; } fields; } ns_lbr_control; u32 $pad11; unsigned long int *ns_cached_msrpm; unsigned long int *ns_merged_msrpm; unsigned long int ns_iomap_pa; unsigned long int ns_oiomap_pa; unsigned long int *ns_iomap; unsigned long int ns_cr0; unsigned long int ns_vmcb_guestcr3; unsigned long int ns_vmcb_hostcr3; u32 ns_guest_asid; bool_t ns_hap_enabled; unsigned __CPROVER_bitvector[24] $pad22; struct { unsigned long int exitcode; unsigned long int exitinfo1; unsigned long int exitinfo2; } ns_vmexit; union { u32 bytes; struct { u32 rflagsif : 1; u32 vintrmask : 1; u32 reserved : 30; } fields; } ns_hostflags; u32 $pad25; } nsvm; struct nestedvmx { unsigned long int vmxon_region_pa; const void *iobitmap[2l]; const void *msrbitmap; struct { unsigned long int intr_info; u32 error_code; u8 source; unsigned __CPROVER_bitvector[24] $pad3; } intr; struct { bool_t enabled; unsigned __CPROVER_bitvector[24] $pad1; u32 exit_reason; u32 exit_qual; } ept; u32 guest_vpid; struct list_head { struct list_head *next; struct list_head *prev; } launched_list; } nvmx; } u; bool_t nv_flushp2m; unsigned __CPROVER_bitvector[56] $pad10; struct p2m_domain *nv_p2m; struct hvm_vcpu_asid { unsigned long int generation; u32 asid; u32 $pad2; } nv_n2asid; bool_t nv_vmentry_pending; bool_t nv_vmexit_pending; bool_t nv_vmswitch_in_progress; bool_t nv_ioport80; bool_t nv_ioportED; unsigned __CPROVER_bitvector[24] $pad18; unsigned long int guest_cr[5l]; } nvcpu; struct altp2mvcpu { unsigned short int p2midx; unsigned __CPROVER_bitvector[48] $pad1; unsigned long int veinfo_gfn; } avcpu; struct mtrr_state { struct mtrr_var_range *var_ranges; u8 fixed_ranges[88l]; u8 enabled; u8 have_fixed; u8 def_type; unsigned __CPROVER_bitvector[40] $pad5; unsigned long int mtrr_cap; bool_t overlapped; unsigned __CPROVER_bitvector[56] $pad8; } mtrr; unsigned long int pat_cr; signed long int stime_offset; u8 evtchn_upcall_vector; u8 cache_mode; unsigned __CPROVER_bitvector[48] $pad29; struct hvm_vcpu_io { enum hvm_io_completion io_completion; u32 $pad1; struct ioreq { unsigned long int addr; unsigned long int data; u32 count; u32 size; u32 vp_eport; unsigned short int _pad0; u8 state : 4; u8 data_is_ptr : 1; u8 dir : 1; u8 df : 1; u8 _pad1 : 1; u8 type; } io_req; struct npfec { u32 read_access : 1; u32 write_access : 1; u32 insn_fetch : 1; u32 present : 1; u32 gla_valid : 1; u32 kind : 2; unsigned __CPROVER_bitvector[1] $bit_field_pad6 : 1; unsigned __CPROVER_bitvector[24] $pad7; } mmio_access; u32 $pad4; unsigned long int mmio_gla; unsigned long int mmio_gpfn; struct hvm_mmio_cache mmio_cache[3l]; u32 mmio_cache_count; u32 mmio_insn_bytes; xen_domain_handle_t mmio_insn; bool_t mmio_retry; unsigned __CPROVER_bitvector[56] $pad12; unsigned long int msix_unmask_address; unsigned long int msix_snoop_address; unsigned long int msix_snoop_gpa; const struct g2m_ioport *g2m_ioport; } hvm_io; const void (*fpu_exception_callback)(const void *, struct cpu_user_regs *); const void *fpu_exception_callback_arg; struct hvm_trap { s16 vector; u8 type; u8 insn_len; u32 error_code; unsigned long int cr2; } inject_trap; struct viridian_vcpu { struct { union viridian_apic_assist { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } msr; const void *va; signed int vector; u32 $pad3; } apic_assist; } viridian; } hvm_vcpu; } $anon0; struct { unsigned long int pfn; } guest_table_user; struct { unsigned long int pfn; } guest_table; struct page_info *old_guest_table; pagetable_t shadow_table[4l]; struct { unsigned long int pfn; } monitor_table; unsigned long int cr3; struct xsave_struct *xsave_area; unsigned long int xcr0; unsigned long int xcr0_accum; bool_t nonlazy_xstate_used; bool_t cpuid_faulting; smap_check_policy_t smap_check_policy; unsigned __CPROVER_bitvector[40] $pad23; struct vmce { unsigned long int mcg_cap; unsigned long int mcg_status; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct vmce_bank bank[2l]; } vmce; struct paging_vcpu { const struct paging_mode *mode; const struct paging_mode *nestedmode; u32 last_write_was_pt : 1; u32 last_write_emul_ok : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad4 : 6; unsigned __CPROVER_bitvector[56] $pad5; struct shadow_vtlb *vtlb; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtlb_lock; unsigned __CPROVER_bitvector[192] $pad8; struct shadow_vcpu { l3_pgentry_t l3table[4l]; l3_pgentry_t gl3e[4l]; const void *guest_vtable; unsigned long int last_emulated_mfn_for_unshadow; unsigned long int last_writeable_pte_smfn; unsigned long int last_emulated_frame; unsigned long int last_emulated_mfn; unsigned long int oos[3l]; unsigned long int oos_snapshot[3l]; struct oos_fixup oos_fixup[3l]; bool_t pagetable_dying; unsigned __CPROVER_bitvector[120] $pad11; } shadow; } paging; u32 gdbsx_vcpu_event; u32 $pad27; struct { vcpu_time_info_t *p; } time_info_guest; struct arch_vm_event *vm_event; unsigned long int $pad30; } arch; } *)NULL) (0x0)

State 1094 file mm.c line 2091 function mod_l4_entry thread 0
----------------------------------------------------
struct domain *d;
----------------------------------------------------
  d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 1095 file mm.c line 2091 function mod_l4_entry thread 0
----------------------------------------------------
d = vcpu->domain;
----------------------------------------------------
  d=((struct domain { unsigned short int domain_id; unsigned short int $pad1; u32 max_vcpus; struct vcpu **vcpu; shared_info_t *shared_info; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } domain_lock; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } page_alloc_lock; struct page_list_head { struct page_info *next; struct page_info *tail; } page_list; struct page_list_head { struct page_info *next; struct page_info *tail; } xenpage_list; u32 tot_pages; u32 xenheap_pages; u32 outstanding_pages; u32 max_pages; struct { signed int counter; } shr_pages; struct { signed int counter; } paged_pages; const void *sched_priv; struct cpupool *cpupool; struct domain *next_in_list; struct domain *next_in_hashbucket; struct list_head { struct list_head *next; struct list_head *prev; } rangesets; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } rangesets_lock; struct evtchn *evtchn; struct evtchn **evtchn_group[4l]; u32 max_evtchns; u32 max_evtchn_port; u32 valid_evtchns; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } event_lock; u32 $pad27; const struct evtchn_port_ops *evtchn_port_ops; struct evtchn_fifo_domain *evtchn_fifo; struct grant_table *grant_table; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } pirq_tree; u32 nr_pirqs; enum guest_type guest_type; enum  is_dying; signed int controller_pause_count; signed long int time_offset_seconds; struct domain_iommu { struct arch_iommu { unsigned long int pgd_maddr; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } mapping_lock; signed int agaw; u32 $pad3; struct list_head { struct list_head *next; struct list_head *prev; } g2m_ioport_list; unsigned long int iommu_bitmap; struct list_head { struct list_head *next; struct list_head *prev; } mapped_rmrrs; signed int paging_mode; u32 $pad8; struct page_info *root_table; struct guest_iommu *g_iommu; } arch; const struct iommu_ops *platform_ops; unsigned long int features[1l]; } iommu; const char need_iommu; bool_t auto_node_affinity; bool_t is_privileged; bool_t is_xenstore; bool_t is_pinned; bool_t disable_migrate; bool_t debugger_attached; bool_t creation_finished; struct domain *target; unsigned long int *poll_mask; struct rangeset *iomem_caps; struct rangeset *irq_caps; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } shutdown_lock; bool_t is_shutting_down; bool_t is_shut_down; unsigned short int $pad53; u32 shutdown_code; u32 suspend_evtchn; struct { signed int counter; } pause_count; struct { signed int counter; } refcnt; u32 $pad58; unsigned long int vm_assist; const cpumask_t *domain_dirty_cpumask; unsigned __int128; struct arch_domain { struct page_info *perdomain_l3_pg; u32 hv_compat_vstart; u32 physaddr_bitsize; struct rangeset *ioport_caps; u32 pci_cf8; u8 cmos_idx; bool_t s3_integrity; unsigned short int $pad7; struct list_head { struct list_head *next; struct list_head *prev; } pdev_list; union { struct pv_domain { l1_pgentry_t **gdt_ldt_l1tab; struct { signed int counter; } nr_l4_pages; u32 $pad2; struct mapcache_domain { u32 entries; u32 cursor; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; u32 epoch; u32 tlbflush_timestamp; unsigned long int *inuse; unsigned long int *garbage; } mapcache; struct cpuidmasks *cpuidmasks; } pv_domain; struct hvm_domain { struct { unsigned long int base; unsigned long int mask; } ioreq_gmfn; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; unsigned short int id; unsigned __CPROVER_bitvector[48] $pad2; struct list_head { struct list_head *next; struct list_head *prev; } list; } ioreq_server; struct hvm_ioreq_server *default_ioreq_server; u32 pci_cf8; u32 $pad4; struct pl_time *pl_time; struct hvm_io_handler *io_handler; u32 io_handler_count; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } irq_lock; u32 $pad9; struct hvm_irq { struct hvm_hw_pci_irqs { union { unsigned long int i[2l]; unsigned long int pad[2l]; } $anon0; } pci_intx; struct hvm_hw_isa_irqs { union { unsigned long int i[1l]; unsigned long int pad[1l]; } $anon0; } isa_irq; struct hvm_hw_pci_link { u8 route[4l]; u8 pad0[4l]; } pci_link; u32 callback_via_asserted; union { enum  callback_via_type; } $anon0; union { u32 gsi; struct { u8 dev; u8 intx; } pci; u32 vector; } callback_via; u8 pci_link_assert_count[4l]; u8 gsi_assert_count[48l]; u8 round_robin_prev_vcpu; unsigned __CPROVER_bitvector[56] $pad9; struct hvm_irq_dpci *dpci; } irq; struct hvm_hw_vpic vpic[2l]; struct hvm_vioapic *vioapic; struct hvm_hw_stdvga { u8 sr_index; u8 sr[8l]; u8 gr_index; u8 gr[9l]; bool_t stdvga; enum stdvga_cache_state cache; u32 latch; u32 $pad7; struct page_info *vram_page[64l]; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } stdvga; struct vcpu *i8259_target; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } emuirq_pirq; unsigned long int *params; struct list_head { struct list_head *next; struct list_head *prev; } pinned_cacheattr_ranges; struct sh_dirty_vram *dirty_vram; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } uc_lock; bool_t is_in_uc_mode; unsigned __CPROVER_bitvector[56] $pad21; struct list_head { struct list_head *next; struct list_head *prev; } msixtbl_list; struct viridian_domain { union viridian_guest_os_id { unsigned long int raw; struct { unsigned long int build_number : 16; unsigned long int service_pack : 8; unsigned long int minor : 8; unsigned long int major : 8; unsigned long int os : 8; unsigned long int vendor : 16; } fields; } guest_os_id; union viridian_hypercall_gpa { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } hypercall_gpa; struct viridian_time_ref_count { unsigned long int flags; unsigned long int val; signed long int off; } time_ref_count; union viridian_reference_tsc { unsigned long int raw; struct { unsigned long int enabled : 1; unsigned long int reserved_preserved : 11; unsigned long int pfn : 48; unsigned __CPROVER_bitvector[4] $bit_field_pad3 : 4; } fields; } reference_tsc; } viridian; bool_t hap_enabled; bool_t mem_sharing_enabled; bool_t qemu_mapcache_invalidate; bool_t is_s3_suspended; u32 $pad28; unsigned long int sync_tsc; unsigned long int tsc_scaling_ratio; unsigned long int *io_bitmap; struct { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; struct list_head { struct list_head *next; struct list_head *prev; } list; } write_map; union { struct vmx_domain { unsigned long int apic_access_mfn; u32 status; u32 $pad2; const void (*vcpu_block)(struct vcpu *); const void (*pi_switch_from)(struct vcpu *); const void (*pi_switch_to)(struct vcpu *); const void (*pi_do_resume)(struct vcpu *); } vmx; struct svm_domain { } svm; } $anon0; } hvm_domain; } $anon0; struct paging_domain { struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } lock; u32 mode; bool_t p2m_alloc_failed; unsigned __CPROVER_bitvector[24] $pad3; struct shadow_domain { u32 opt_flags; u32 $pad1; struct page_list_head { struct page_info *next; struct page_info *tail; } pinned_shadows; struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad7; struct { unsigned long int pfn; } unpaged_pagetable; struct { signed int counter; } gtable_dirty_version; u32 $pad10; struct page_info **hash_table; bool_t hash_walking; bool_t has_fast_mmio_entries; bool_t oos_active; bool_t oos_off; bool_t pagetable_dying_op; unsigned __CPROVER_bitvector[24] $pad17; } shadow; struct hap_domain { struct page_list_head { struct page_info *next; struct page_info *tail; } freelist; u32 total_pages; u32 free_pages; u32 p2m_pages; u32 $pad4; } hap; struct log_dirty_domain { unsigned long int top; u32 allocs; u32 failed_allocs; u32 fault_count; u32 dirty_count; signed int (*enable_log_dirty)(struct domain *, bool_t); signed int (*disable_log_dirty)(struct domain *); const void (*clean_dirty_bitmap)(struct domain *); } log_dirty; u32 gfn_bits; u32 $pad8; struct { struct domain *dom; u32 op; u32 $pad2; union { struct { unsigned long int done : 40; unsigned long int i4 : 9; unsigned long int i3 : 9; unsigned __CPROVER_bitvector[6] $bit_field_pad3 : 6; } log_dirty; } $anon0; } preempt; struct page_info * (*alloc_page)(struct domain *); const void (*free_page)(struct domain *, struct page_info *); } paging; struct p2m_domain *p2m; signed int page_alloc_unlock_level; enum  relmem; struct page_list_head { struct page_info *next; struct page_info *tail; } relmem_list; struct p2m_domain *nested_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } nested_p2m_lock; bool_t altp2m_active; unsigned __CPROVER_bitvector[56] $pad18; struct p2m_domain *altp2m_p2m[10l]; struct mm_lock { struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; signed int unlock_level; signed int locker; const char *locker_function; } altp2m_list_lock; unsigned long int *altp2m_eptp; struct radix_tree_root { u32 height; u32 $pad1; struct radix_tree_node *rnode; radix_tree_alloc_fn_t (*node_alloc); radix_tree_free_fn_t (*node_free); const void *node_alloc_free_arg; } irq_pirq; bool_t is_32bit_pv; bool_t has_32bit_shinfo; bool_t suppress_spurious_page_faults; bool_t auto_unmask; u8 x86; u8 x86_vendor; u8 x86_model; u8 x87_fip_width; cpuid_input_t *cpuids; struct PITState { struct hvm_hw_pit { struct hvm_hw_pit_channel channels[3l]; u32 speaker_data_on; u32 pad0; } hw; signed long int count_load_time[3l]; struct periodic_time { struct list_head { struct list_head *next; struct list_head *prev; } list; bool_t on_list; bool_t one_shot; bool_t do_not_freeze; bool_t irq_issued; bool_t warned_timeout_too_short; u8 source; u8 irq; u8 $pad8; struct vcpu *vcpu; u32 pending_intr_nr; u32 $pad11; unsigned long int period; signed long int scheduled; unsigned long int last_plt_gtime; struct timer { signed long int expires; union { u32 heap_offset; struct timer *list_next; struct list_head { struct list_head *next; struct list_head *prev; } inactive; } $anon0; const void (*function)(const void *); const void *data; unsigned short int cpu; u8 status; unsigned __CPROVER_bitvector[40] $pad6; } timer; time_cb (*cb); const void *priv; } pt0; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vpit; signed int tsc_mode; bool_t vtsc; unsigned __CPROVER_bitvector[24] $pad35; signed long int vtsc_last; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } vtsc_lock; unsigned long int vtsc_offset; u32 tsc_khz; struct time_scale { signed int shift; u32 mul_frac; } vtsc_to_ns; struct time_scale { signed int shift; u32 mul_frac; } ns_to_vtsc; u32 incarnation; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } e820_lock; struct e820entry *e820; u32 nr_e820; u32 psr_rmid; u32 *psr_cos_ids; unsigned long int *pirq_eoi_map; unsigned long int pirq_eoi_map_mfn; struct { u32 write_ctrlreg_enabled : 4; u32 write_ctrlreg_sync : 4; u32 write_ctrlreg_onchangeonly : 4; u32 singlestep_enabled : 1; u32 software_breakpoint_enabled : 1; u32 debug_exception_enabled : 1; u32 debug_exception_sync : 1; u32 cpuid_enabled : 1; unsigned __CPROVER_bitvector[7] $bit_field_pad8 : 7; unsigned __CPROVER_bitvector[40] $pad9; struct monitor_msr_bitmap *msr_bitmap; } monitor; bool_t mem_access_emulate_each_rep; unsigned __CPROVER_bitvector[24] $pad52; u32 emulation_flags; unsigned __CPROVER_bitvector[384] $pad54; } arch; const void *ssid; xen_domain_handle_t handle; const char *pbuf; u32 pbuf_idx; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } pbuf_lock; u32 $pad68; struct xenoprof *xenoprof; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } watchdog_lock; u32 watchdog_inuse_map; u32 $pad72; struct timer watchdog_timer[2l]; struct rcu_head { struct rcu_head *next; const void (*func)(struct rcu_head *); } rcu; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } hypercall_deadlock_mutex; struct client *tmem_client; struct lock_profile_qhead { } profile_head; struct vm_event_per_domain *vm_event; struct { unsigned long int bits[1l]; } node_affinity; u32 last_alloc_node; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } node_affinity_lock; struct { struct { signed int counter; } cnts; struct spinlock { union { u32 head_tail; struct { unsigned short int head; unsigned short int tail; } $anon0; } tickets; unsigned short int recurse_cpu : 12; unsigned short int recurse_cnt : 4; struct lock_debug { } debug; unsigned short int $pad4; } lock; } vnuma_rwlock; struct vnuma_info *vnuma; struct { u32 guest_request_enabled : 1; u32 guest_request_sync : 1; unsigned __CPROVER_bitvector[6] $bit_field_pad2 : 6; unsigned __CPROVER_bitvector[24] $pad3; } monitor; u32 $pad85; } *)NULL) (0x0)

State 1096 file mm.c line 2092 function mod_l4_entry thread 0
----------------------------------------------------
l4_pgentry_t ol4e;
----------------------------------------------------
  ol4e={ .l4=0ul } ({ 0x0 })

State 1097 file mm.c line 2093 function mod_l4_entry thread 0
----------------------------------------------------
signed int rc;
----------------------------------------------------
  rc=0 (0x0)

State 1098 file mm.c line 2093 function mod_l4_entry thread 0
----------------------------------------------------
rc = 0;
----------------------------------------------------
  rc=0 (0x0)

#### Function call: get_cpu_info$link17$link2() (depth 5) ####

#### Function return: get_cpu_info$link17$link2 (depth 4) ####

Violated property:
  file mm.c line 2101 function mod_l4_entry
  access mod_l4 as guest
  (((struct vcpu *)return_value_get_cpu_info->current_vcpu)->arch.flags & (unsigned long int)(1 << 0 == 0)) != 0ul


138.738369 VERIFICATION FAILED

real	0m14.448s
user	0m14.228s
sys	0m0.216s
goto-instrument options: --aggressive-slice --aggressive-slice-call-depth 0  --aggressive-slice-preserve-all-direct-paths 
cbmc options:  --stop-on-fail --object-bits 16 --trace --trace-show-function-calls --trace-show-code --trace-hex --no-sat-preprocessor --unwind 0 --havoc-undefined-functions 
Reading GOTO program from `xsa213.sliced.binary'
Effective lines of code: 1280
Reading GOTO program from `xsa213.binary'
Effective lines of code: 101725
1537443538
